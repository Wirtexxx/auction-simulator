{"version":3,"file":"index.iife.js","sources":["../../signals/dist/index.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/function.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/internal.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Apply.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Functor.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Chain.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Option.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Either.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/EitherT.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Json.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Task.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/TaskEither.js","../src/helpers/access.ts","../src/composables/Mountable.ts","../src/helpers/removeUndefined.ts","../src/helpers/shallowEqual.ts","../src/composables/Stateful.ts","../../../node_modules/.pnpm/valibot@1.1.0_typescript@5.9.2/node_modules/valibot/dist/index.js","../../../node_modules/.pnpm/better-promises@1.0.0/node_modules/better-promises/dist/index.js","../../toolkit/dist/index.js","../../../node_modules/.pnpm/error-kid@1.0.2/node_modules/error-kid/dist/index.js","../../transformers/dist/index.js","../../../node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs","../../bridge/dist/index.js","../src/helpers/createIsSupportedSignal.ts","../src/with-checks/throwifyWithChecksFp.ts","../src/errors.ts","../src/with-checks/withChecksFp.ts","../src/composables/Button.ts","../src/features/BackButton/BackButton.ts","../src/fn-options/sharedFeatureOptions.ts","../src/fn-options/createFnOption.ts","../src/globals/signals-registry.ts","../src/globals/postEvent.ts","../src/fn-options/withPostEvent.ts","../src/helpers/component-storage.ts","../src/helpers/navigation.ts","../src/fn-options/withStateRestore.ts","../src/globals/version.ts","../src/fn-options/withVersion.ts","../src/fn-options/buttonOptions.ts","../src/features/BackButton/instance.ts","../src/composables/AsyncMountable.ts","../src/features/Biometry/Biometry.ts","../src/globals/request.ts","../src/fn-options/withRequest.ts","../src/features/Biometry/instance.ts","../src/features/ClosingBehavior/ClosingBehavior.ts","../src/features/ClosingBehavior/instance.ts","../src/features/CloudStorage/CloudStorage.ts","../src/globals/createRequestId.ts","../src/globals/invokeCustomMethod.ts","../src/fn-options/withInvokeCustomMethod.ts","../src/features/CloudStorage/instance.ts","../src/features/DeviceStorage/DeviceStorage.ts","../src/fn-options/withCreateRequestId.ts","../src/features/DeviceStorage/instance.ts","../src/features/emoji-status/requestEmojiStatusAccess.ts","../src/features/emoji-status/setEmojiStatus.ts","../src/features/HapticFeedback/HapticFeedback.ts","../src/features/HapticFeedback/instance.ts","../src/features/home-screen/addToHomeScreen.ts","../src/features/home-screen/checkHomeScreenStatus.ts","../src/features/InitData/InitData.ts","../src/features/InitData/instance.ts","../src/features/Invoice/Invoice.ts","../src/features/Invoice/instance.ts","../src/features/links/openLink.ts","../src/features/links/openTelegramLink.ts","../src/features/links/shareURL.ts","../src/features/LocationManager/LocationManager.ts","../src/features/LocationManager/instance.ts","../src/features/MainButton/MainButton.ts","../src/helpers/css-vars.ts","../src/helpers/isColorDark.ts","../src/features/ThemeParams/ThemeParams.ts","../src/globals/themeParams.ts","../src/features/ThemeParams/instance.ts","../src/fn-options/bottomButtonOptions.ts","../src/features/MainButton/instance.ts","../src/features/MiniApp/MiniApp.ts","../src/features/MiniApp/instance.ts","../src/features/Popup/prepareParams.ts","../src/features/Popup/Popup.ts","../src/features/Popup/instance.ts","../src/features/privacy/requestPhoneAccess.ts","../src/features/privacy/requestContact.ts","../src/features/privacy/requestWriteAccess.ts","../src/features/QrScanner/QrScanner.ts","../src/features/QrScanner/instance.ts","../src/features/SecondaryButton/SecondaryButton.ts","../src/features/SecondaryButton/instance.ts","../src/features/SecureStorage/SecureStorage.ts","../src/features/SecureStorage/instance.ts","../src/features/SettingsButton/SettingsButton.ts","../src/features/SettingsButton/instance.ts","../src/features/SwipeBehavior/SwipeBehavior.ts","../src/features/SwipeBehavior/instance.ts","../src/features/uncategorized/copyTextToClipboard.ts","../src/features/uncategorized/downloadFile.ts","../src/features/uncategorized/getCurrentTime.ts","../src/features/uncategorized/hideKeyboard.ts","../src/features/uncategorized/readTextFromClipboard.ts","../src/features/uncategorized/retrieveAndroidDeviceDataFrom.ts","../src/features/uncategorized/retrieveAndroidDeviceData.ts","../src/features/uncategorized/sendData.ts","../src/features/uncategorized/shareMessage.ts","../src/features/uncategorized/shareStory.ts","../src/globals/isInlineMode.ts","../src/features/uncategorized/switchInlineQuery.ts","../src/features/Viewport/Viewport.ts","../src/features/Viewport/instance.ts","../src/init.ts"],"sourcesContent":["let r;\nfunction y(e, c) {\n  r ? r.set(e, c) : c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n","/**\n * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.\n *\n * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor\n * `f`.\n *\n * Instances must satisfy the following law in addition to the `Functor` laws:\n *\n * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`\n *\n * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)\n * const fa: O.Option<string> = O.some('s')\n * const fb: O.Option<number> = O.some(1)\n * const fc: O.Option<boolean> = O.some(true)\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     // lift a function\n *     O.some(f),\n *     // apply the first argument\n *     O.ap(fa),\n *     // apply the second argument\n *     O.ap(fb),\n *     // apply the third argument\n *     O.ap(fc)\n *   ),\n *   O.some('s1true')\n * )\n *\n * @since 2.0.0\n */\nimport { tuple } from './function';\nimport * as _ from './internal';\nexport function ap(F, G) {\n    return function (fa) {\n        return function (fab) {\n            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);\n        };\n    };\n}\nexport function apFirst(A) {\n    return function (second) { return function (first) {\n        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);\n    }; };\n}\nexport function apSecond(A) {\n    return function (second) {\n        return function (first) {\n            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);\n        };\n    };\n}\nexport function apS(F) {\n    return function (name, fb) {\n        return function (fa) {\n            return F.ap(F.map(fa, function (a) { return function (b) {\n                var _a;\n                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n            }; }), fb);\n        };\n    };\n}\nexport function getApplySemigroup(F) {\n    return function (S) { return ({\n        concat: function (first, second) {\n            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);\n        }\n    }); };\n}\nfunction curried(f, n, acc) {\n    return function (x) {\n        var combined = Array(acc.length + 1);\n        for (var i = 0; i < acc.length; i++) {\n            combined[i] = acc[i];\n        }\n        combined[acc.length] = x;\n        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);\n    };\n}\nvar tupleConstructors = {\n    1: function (a) { return [a]; },\n    2: function (a) { return function (b) { return [a, b]; }; },\n    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },\n    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },\n    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }\n};\nfunction getTupleConstructor(len) {\n    if (!_.has.call(tupleConstructors, len)) {\n        tupleConstructors[len] = curried(tuple, len - 1, []);\n    }\n    return tupleConstructors[len];\n}\nexport function sequenceT(F) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var len = args.length;\n        var f = getTupleConstructor(len);\n        var fas = F.map(args[0], f);\n        for (var i = 1; i < len; i++) {\n            fas = F.ap(fas, args[i]);\n        }\n        return fas;\n    };\n}\nfunction getRecordConstructor(keys) {\n    var len = keys.length;\n    switch (len) {\n        case 1:\n            return function (a) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a);\n            };\n        case 2:\n            return function (a) { return function (b) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);\n            }; };\n        case 3:\n            return function (a) { return function (b) { return function (c) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);\n            }; }; };\n        case 4:\n            return function (a) { return function (b) { return function (c) { return function (d) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a);\n            }; }; }; };\n        case 5:\n            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a[keys[4]] = e,\n                    _a);\n            }; }; }; }; };\n        default:\n            return curried(function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var r = {};\n                for (var i = 0; i < len; i++) {\n                    r[keys[i]] = args[i];\n                }\n                return r;\n            }, len - 1, []);\n    }\n}\nexport function sequenceS(F) {\n    return function (r) {\n        var keys = Object.keys(r);\n        var len = keys.length;\n        var f = getRecordConstructor(keys);\n        var fr = F.map(r[keys[0]], f);\n        for (var i = 1; i < len; i++) {\n            fr = F.ap(fr, r[keys[i]]);\n        }\n        return fr;\n    };\n}\n","/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport { pipe } from './function';\nexport function map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexport function flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexport function bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\nexport { \n/**\n * @since 2.13.0\n */\nlet_ as let };\n/** @deprecated */\nexport function getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return pipe(fga, _map(f)); }\n    };\n}\n/** @internal */\nexport function as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\n/** @internal */\nexport function asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\n","export function chainFirst(M) {\n    var tapM = tap(M);\n    return function (f) { return function (first) { return tapM(first, f); }; };\n}\n/** @internal */\nexport function tap(M) {\n    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };\n}\nexport function bind(M) {\n    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n    }); }); }; };\n}\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, tapEither as tapEither_ } from './FromEither';\nimport { constNull, constUndefined, dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { not } from './Predicate';\nimport { first, last } from './Semigroup';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = _.some;\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getLeft = function (ma) { return (ma._tag === 'Right' ? none : some(ma.left)); };\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getRight = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (S) { return ({\n    show: function (ma) { return (isNone(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n}); };\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = function (O) { return ({\n    equals: getEq(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : isSome(y) ? -1 : 0); }\n}); };\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function (S) { return ({\n    concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n    empty: none\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isNone(ma) ? none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var orElse = dual(2, function (self, that) { return (isNone(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var altW = orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var alt = orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ flatMap(identity);\nvar defaultSeparated = /*#__PURE__*/ separated(none, none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    return isNone(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return separated(_filter(fa, not(predicate)), _filter(fa, predicate));\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n        };\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onNone, onSome) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : onSome(ma.value);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : ma.value;\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainEitherK = \n/*#__PURE__*/ chainEitherK_(FromEither, Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (a) { return (a == null ? none : some(a)); };\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); });\n    };\n};\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function (f) { return flow(f, fromNullable); };\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function (f) {\n    return function (ma) {\n        return isNone(ma) ? none : fromNullable(f(ma.value));\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toNullable = /*#__PURE__*/ match(constNull, identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toUndefined = /*#__PURE__*/ match(constUndefined, identity);\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isNone(ma) ? false : E.equals(a, ma.value);\n    };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isNone(ma) ? false : predicate(ma.value);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if (isNone(o)) {\n            return none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if (isNone(o_1)) {\n                return none;\n            }\n            out.push(o_1.value);\n        }\n        return some(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var option = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: _alt,\n    extend: _extend,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = /*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = /*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstMonoid = function () { return getMonoid(first()); };\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastMonoid = function () { return getMonoid(last()); };\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    try {\n        return e instanceof Error ? e : new Error(String(e));\n    }\n    catch (error) {\n        return new Error();\n    }\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n","import { ap as ap_ } from './Apply';\nimport * as E from './Either';\nimport { flow, pipe } from './function';\nimport { map as map_ } from './Functor';\nexport function right(F) {\n    return flow(E.right, F.of);\n}\nexport function left(F) {\n    return flow(E.left, F.of);\n}\nexport function rightF(F) {\n    return function (fa) { return F.map(fa, E.right); };\n}\nexport function leftF(F) {\n    return function (fe) { return F.map(fe, E.left); };\n}\nexport function fromNullable(F) {\n    return function (e) { return flow(E.fromNullable(e), F.of); };\n}\nexport function fromNullableK(F) {\n    var fromNullableF = fromNullable(F);\n    return function (e) {\n        var fromNullableFE = fromNullableF(e);\n        return function (f) { return flow(f, fromNullableFE); };\n    };\n}\nexport function chainNullableK(M) {\n    var chainM = chain(M);\n    var fromNullableKM = fromNullableK(M);\n    return function (e) {\n        var fromNullableKMe = fromNullableKM(e);\n        return function (f) { return chainM(fromNullableKMe(f)); };\n    };\n}\nexport function map(F) {\n    return map_(F, E.Functor);\n}\nexport function ap(F) {\n    return ap_(F, E.Apply);\n}\nexport function chain(M) {\n    var flatMapM = flatMap(M);\n    return function (f) { return function (ma) { return flatMapM(ma, f); }; };\n}\n/** @internal */\nexport function flatMap(M) {\n    return function (ma, f) { return M.chain(ma, function (e) { return (E.isLeft(e) ? M.of(e) : f(e.right)); }); };\n}\nexport function alt(M) {\n    return function (second) { return function (first) { return M.chain(first, function (e) { return (E.isLeft(e) ? second() : M.of(e)); }); }; };\n}\nexport function bimap(F) {\n    var mapBothF = mapBoth(F);\n    return function (f, g) { return function (self) { return mapBothF(self, f, g); }; };\n}\n/** @internal */\nexport function mapBoth(F) {\n    return function (self, f, g) { return F.map(self, E.bimap(f, g)); };\n}\nexport function mapLeft(F) {\n    var mapErrorF = mapError(F);\n    return function (f) { return function (self) { return mapErrorF(self, f); }; };\n}\n/** @internal */\nexport function mapError(F) {\n    return function (self, f) { return F.map(self, E.mapLeft(f)); };\n}\nexport function altValidation(M, S) {\n    return function (second) { return function (first) {\n        return M.chain(first, E.match(function (e1) {\n            return M.map(second(), E.mapLeft(function (e2) { return S.concat(e1, e2); }));\n        }, right(M)));\n    }; };\n}\nexport function match(F) {\n    return function (onLeft, onRight) { return function (ma) { return F.map(ma, E.match(onLeft, onRight)); }; };\n}\nexport function matchE(M) {\n    return function (onLeft, onRight) { return function (ma) { return M.chain(ma, E.match(onLeft, onRight)); }; };\n}\nexport function getOrElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, E.match(onLeft, M.of)); }; };\n}\nexport function orElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, function (e) { return (E.isLeft(e) ? onLeft(e.left) : M.of(e)); }); }; };\n}\nexport function orElseFirst(M) {\n    var tapErrorM = tapError(M);\n    return function (onLeft) { return function (ma) { return tapErrorM(ma, onLeft); }; };\n}\n/** @internal */\nexport function tapError(M) {\n    var orElseM = orElse(M);\n    return function (ma, onLeft) {\n        return pipe(ma, orElseM(function (e) { return M.map(onLeft(e), function (eb) { return (E.isLeft(eb) ? eb : E.left(e)); }); }));\n    };\n}\nexport function orLeft(M) {\n    return function (onLeft) { return function (ma) {\n        return M.chain(ma, E.match(function (e) { return M.map(onLeft(e), E.left); }, function (a) { return M.of(E.right(a)); }));\n    }; };\n}\nexport function swap(F) {\n    return function (ma) { return F.map(ma, E.swap); };\n}\nexport function toUnion(F) {\n    return function (fa) { return F.map(fa, E.toUnion); };\n}\n/** @deprecated  */\n/* istanbul ignore next */\nexport function getEitherM(M) {\n    var _ap = ap(M);\n    var _map = map(M);\n    var _chain = chain(M);\n    var _alt = alt(M);\n    var _bimap = bimap(M);\n    var _mapLeft = mapLeft(M);\n    var _fold = matchE(M);\n    var _getOrElse = getOrElse(M);\n    var _orElse = orElse(M);\n    return {\n        map: function (fa, f) { return pipe(fa, _map(f)); },\n        ap: function (fab, fa) { return pipe(fab, _ap(fa)); },\n        of: right(M),\n        chain: function (ma, f) { return pipe(ma, _chain(f)); },\n        alt: function (fa, that) { return pipe(fa, _alt(that)); },\n        bimap: function (fea, f, g) { return pipe(fea, _bimap(f, g)); },\n        mapLeft: function (fea, f) { return pipe(fea, _mapLeft(f)); },\n        fold: function (fa, onLeft, onRight) { return pipe(fa, _fold(onLeft, onRight)); },\n        getOrElse: function (fa, onLeft) { return pipe(fa, _getOrElse(onLeft)); },\n        orElse: function (fa, f) { return pipe(fa, _orElse(f)); },\n        swap: swap(M),\n        rightM: rightF(M),\n        leftM: leftF(M),\n        left: left(M)\n    };\n}\n","/**\n * @since 2.10.0\n */\nimport { tryCatch } from './Either';\nimport { identity } from './function';\n/**\n * Converts a JavaScript Object Notation (JSON) string into a `Json` type.\n *\n * @example\n * import * as J from 'fp-ts/Json'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('{\"a\":1}', J.parse), E.right({ a: 1 }))\n * assert.deepStrictEqual(pipe('{\"a\":}', J.parse), E.left(new SyntaxError(`Unexpected token '}', \"{\"a\":}\" is not valid JSON`)))\n *\n * @since 2.10.0\n */\nexport var parse = function (s) { return tryCatch(function () { return JSON.parse(s); }, identity); };\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import * as J from 'fp-ts/Json'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(J.stringify({ a: 1 }), E.right('{\"a\":1}'))\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(\n *   pipe(\n *     J.stringify(circular),\n *     E.mapLeft(e => e instanceof Error && e.message.includes('Converting circular structure to JSON'))\n *   ),\n *   E.left(true)\n * )\n *\n *  @since 2.10.0\n */\nexport var stringify = function (a) {\n    return tryCatch(function () {\n        var s = JSON.stringify(a);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, identity);\n};\n","/**\n * ```ts\n * interface Task<A> {\n *   (): Promise<A>\n * }\n * ```\n *\n * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.\n * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.\n *\n * @since 2.0.0\n */\nimport { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { dual, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIO = function (ma) { return function () { return Promise.resolve().then(ma); }; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n * import { takeRight } from 'fp-ts/Array'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = T.delay(20)(append('b'))\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])\n * }\n *\n * test()\n *\n * @since 2.0.0\n */\nexport function delay(millis) {\n    return function (ma) { return function () {\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                Promise.resolve().then(ma).then(resolve);\n            }, millis);\n        });\n    }; };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return function () {\n    return Promise.resolve().then(fa).then(f);\n}; }; };\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) { return function () {\n    return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {\n        var f = _a[0], a = _a[1];\n        return f(a);\n    });\n}; }; };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return function () { return Promise.resolve(a); }; };\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return function () {\n        return Promise.resolve()\n            .then(ma)\n            .then(function (a) { return f(a)(); });\n    };\n});\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Task';\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid() {\n    return {\n        concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },\n        empty: never\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the value to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the value to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO\n};\n/**\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var fromTask = identity;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIO = _.flatMapIO(_FromIO, _FlatMap);\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as T from 'fp-ts/Task'\n * import * as Console from 'fp-ts/Console'\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effect = pipe(\n *   T.of('fp-ts'),\n *   T.tapIO((value) => Console.log(`Hello, ${value}`)),\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), 'fp-ts')\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOK = \n/*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * A `Task` that never completes.\n *\n * @since 2.0.0\n */\nexport var never = function () { return new Promise(function (_) { return undefined; }); };\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        return function () {\n            return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); }));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (bs) {\n                    return Promise.resolve()\n                        .then(f(i + 1, a))\n                        .then(function (b) {\n                        bs.push(b);\n                        return bs;\n                    });\n                });\n            }, Promise.resolve()\n                .then(f(0, _.head(as)))\n                .then(_.singleton));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) {\n    return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.task`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var task = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.taskSeq`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskSeq = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = /*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMonoid = /*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { getApplicativeMonoid } from './Applicative';\nimport { ap as ap_, apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { compact as compact_, separate as separate_ } from './Compactable';\nimport * as E from './Either';\nimport * as ET from './EitherT';\nimport { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, tapEither as tapEither_ } from './FromEither';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { fromTaskK as fromTaskK_, tapTask as tapTask_ } from './FromTask';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as T from './Task';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var left = /*#__PURE__*/ ET.left(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var right = /*#__PURE__*/ ET.right(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightTask = /*#__PURE__*/ ET.rightF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftTask = /*#__PURE__*/ ET.leftF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightIO = /*#__PURE__*/ flow(T.fromIO, rightTask);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftIO = /*#__PURE__*/ flow(T.fromIO, leftTask);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromIO = rightIO;\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromTask = rightTask;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = T.of;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIOEither = T.fromIO;\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromTaskOption = function (onNone) {\n    return T.map(E.fromOption(onNone));\n};\n/**\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = \n/*#__PURE__*/ ET.match(T.Functor);\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = match;\n/**\n * The `E` suffix (short for **E**ffect) means that the handlers return an effect (`Task`).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchE = /*#__PURE__*/ ET.matchE(T.Monad);\n/**\n * Alias of [`matchE`](#matche).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = matchE;\n/**\n * Less strict version of [`matchE`](#matche).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchEW = matchE;\n/**\n * Alias of [`matchEW`](#matchew).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchEW;\n/**\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = \n/*#__PURE__*/ ET.getOrElse(T.Monad);\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = getOrElse;\n/**\n * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { left, right } from 'fp-ts/Either'\n * import { tryCatch } from 'fp-ts/TaskEither'\n *\n * tryCatch(() => Promise.resolve(1), String)().then(result => {\n *   assert.deepStrictEqual(result, right(1))\n * })\n * tryCatch(() => Promise.reject('error'), String)().then(result => {\n *   assert.deepStrictEqual(result, left('error'))\n * })\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onRejected) {\n    return function () { return __awaiter(void 0, void 0, void 0, function () {\n        var reason_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, f().then(_.right)];\n                case 1: return [2 /*return*/, _a.sent()];\n                case 2:\n                    reason_1 = _a.sent();\n                    return [2 /*return*/, _.left(onRejected(reason_1))];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\n/**\n * Converts a function returning a `Promise` to one returning a `TaskEither`.\n *\n * @category interop\n * @since 2.5.0\n */\nexport var tryCatchK = function (f, onRejected) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onRejected);\n    };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ ET.toUnion(T.Functor);\n/**\n * @category conversions\n * @since 2.12.0\n */\nexport var fromNullable = /*#__PURE__*/ ET.fromNullable(T.Pointed);\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var fromNullableK = /*#__PURE__*/ ET.fromNullableK(T.Pointed);\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainNullableK = \n/*#__PURE__*/ ET.chainNullableK(T.Monad);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.\n *\n * See also [alt](#alt).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   const errorHandler = TE.orElse((error: string) => TE.right(`recovering from ${error}...`))\n *   assert.deepStrictEqual(await pipe(TE.right('ok'), errorHandler)(), E.right('ok'))\n *   assert.deepStrictEqual(await pipe(TE.left('ko'), errorHandler)(), E.right('recovering from ko...'))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = \n/*#__PURE__*/ ET.orElse(T.Monad);\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = orElse;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @category error handling\n * @since 2.15.0\n */\nexport var tapError = /*#__PURE__*/ dual(2, ET.tapError(T.Monad));\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstIOK = function (onLeft) { return tapError(fromIOK(onLeft)); };\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstTaskK = function (onLeft) { return tapError(fromTaskK(onLeft)); };\n/**\n * @category error handling\n * @since 2.11.0\n */\nexport var orLeft = \n/*#__PURE__*/ ET.orLeft(T.Monad);\n/**\n * @since 2.0.0\n */\nexport var swap = /*#__PURE__*/ ET.swap(T.Functor);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromTaskOptionK = function (onNone) {\n    var from = fromTaskOption(onNone);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.3\n */\nexport var chainTaskOptionKW = function (onNone) {\n    return function (f) {\n        return function (ma) {\n            return flatMap(ma, fromTaskOptionK(onNone)(f));\n        };\n    };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainTaskOptionK = chainTaskOptionKW;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOEitherK = function (f) { return flow(f, fromIOEither); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = /*#__PURE__*/ ET.map(T.Functor);\n/**\n * Returns a `TaskEither` whose failure and success channels have been mapped by the specified pair of functions, `f` and `g`.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n * const g = (n: number) => n * 2\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.right(1), f, g)(), Either.right(2))\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.left('err'), f, g)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapBoth = /*#__PURE__*/ dual(3, ET.mapBoth(T.Functor));\n/**\n * Alias of `mapBoth`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var bimap = mapBoth;\n/**\n * Returns a `TaskEither` with its error channel mapped using the specified function.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.right(1), f)(), Either.right(1))\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.left('err'), f)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapError = /*#__PURE__*/ dual(2, ET.mapError(T.Functor));\n/**\n * Alias of `mapError`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var mapLeft = mapError;\n/**\n * @since 2.0.0\n */\nexport var ap = \n/*#__PURE__*/ ET.ap(T.ApplyPar);\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = ap;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, ET.flatMap(T.Monad));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `TaskEither` returns `fa` if is a `Right` or the value returned by `that` otherwise.\n *\n * See also [orElse](#orelse).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.right(1),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(1)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(2)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.left('b'))\n *     )(),\n *     E.left('b')\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = \n/*#__PURE__*/ ET.alt(T.Monad);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = alt;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = right;\n/**\n * @since 2.7.0\n */\nexport var throwError = left;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'TaskEither';\n/**\n * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n * import * as T from 'fp-ts/Task'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const remoteDatabase: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'John' },\n *   { id: 'id2', name: 'Mary' },\n *   { id: 'id3', name: 'Joey' }\n * ]\n *\n * const fetchUser = (id: string): TE.TaskEither<string, User> =>\n *   pipe(\n *     remoteDatabase,\n *     RA.findFirst((user) => user.id === id),\n *     TE.fromOption(() => `${id} not found`)\n *   )\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(TE.ApplicativePar)(fetchUser))(),\n *     E.left('id4 not found') // <= first error\n *   )\n *\n *   const Applicative = TE.getApplicativeTaskValidation(\n *     T.ApplyPar,\n *     pipe(string.Semigroup, S.intercalate(', '))\n *   )\n *\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(Applicative)(fetchUser))(),\n *     E.left('id4 not found, id5 not found') // <= all errors\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getApplicativeTaskValidation(A, S) {\n    var ap = ap_(A, E.getApplicativeValidation(S));\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return pipe(fab, ap(fa)); },\n        of: of\n    };\n}\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * See [`getAltValidation`](./Either.ts.html#getaltvalidation).\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getAltTaskValidation(S) {\n    var alt = ET.altValidation(T.Monad, S);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        alt: function (fa, that) { return pipe(fa, alt(that)); }\n    };\n}\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var C = E.getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: compact_(T.Functor, C),\n        separate: separate_(T.Functor, C, E.Functor)\n    };\n};\n/**\n * @category filtering\n * @since 2.1.0\n */\nexport function getFilterable(M) {\n    var F = E.getFilterable(M);\n    var C = getCompactable(M);\n    var filter = filter_(T.Functor, F);\n    var filterMap = filterMap_(T.Functor, F);\n    var partition = partition_(T.Functor, F);\n    var partitionMap = partitionMap_(T.Functor, F);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: C.compact,\n        separate: C.separate,\n        filter: function (fa, predicate) { return pipe(fa, filter(predicate)); },\n        filterMap: function (fa, f) { return pipe(fa, filterMap(f)); },\n        partition: function (fa, predicate) { return pipe(fa, partition(predicate)); },\n        partitionMap: function (fa, f) { return pipe(fa, partitionMap(f)); }\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `TaskEither` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `TaskEither` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Less strict version of [`apFirst`](#apfirst).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Less strict version of [`apSecond`](#apsecond).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * const checkString = (value: string) => pipe(\n *   TE.of(value),\n *   TE.tapEither(() => value.length > 0 ? E.right('ok') : E.left('error'))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await checkString('')(), E.left('error'))\n *   assert.deepStrictEqual(await checkString('fp-ts')(), E.right('fp-ts'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n * import * as E from 'fp-ts/Either'\n * import * as Console from 'fp-ts/Console'\n *\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effectA = TE.tapIO(\n *   TE.of(1),\n *   (value) => Console.log(`Hello, ${value}`)\n * )\n *\n * // No output to the stdout\n * const effectB = pipe(\n *   TE.left('error'),\n *   TE.tapIO((value) => Console.log(`Hello, ${value}`))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effectA(), E.of(1))\n *   assert.deepStrictEqual(await effectB(), E.left('error'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as TE from 'fp-ts/TaskEither'\n * import * as T from 'fp-ts/Task'\n * import * as E from 'fp-ts/Either'\n *\n *\n * const effect = TE.tapIO(\n *   TE.of(1),\n *   (value) => T.of(value + 1)\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), E.of(1))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapTask = /*#__PURE__*/ dual(2, tapTask_(FromTask, Chain));\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/** @internal */\nvar _FromTask = {\n    fromTask: fromTask\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapEither = /*#__PURE__*/ _.flatMapEither(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapIO = /*#__PURE__*/ _.flatMapIO(_FromIO, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTask = /*#__PURE__*/ _.flatMapTask(_FromTask, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIOEither = /*#__PURE__*/ dual(2, function (self, f) {\n    return flatMap(self, fromIOEitherK(f));\n});\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTaskOption = /*#__PURE__*/ dual(3, function (self, f, onNone) {\n    return flatMap(self, function (a) { return fromTaskOption(function () { return onNone(a); })(f(a)); });\n});\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainEitherK = flatMapEither;\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainEitherKW = flatMapEither;\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Alias of `tapEither`.\n *\n * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherKW = tapEither;\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromIOK = /*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromTaskK = /*#__PURE__*/ fromTaskK_(FromTask);\n/**\n * Alias of `flatMapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainTaskK = flatMapTask;\n/**\n * Alias of `tapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstTaskK = tapTask;\n/**\n * Alias of `flatMapIOEither`.\n *\n * Less strict version of [`chainIOEitherK`](#chainioeitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainIOEitherKW = flatMapIOEither;\n/**\n * Alias of `flatMapIOEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOEitherK = flatMapIOEither;\nexport function taskify(f) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        return function () {\n            return new Promise(function (resolve) {\n                var cbResolver = function (e, r) { return (e != null ? resolve(_.left(e)) : resolve(_.right(r))); };\n                f.apply(null, args.concat(cbResolver));\n            });\n        };\n    };\n}\n/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @since 2.0.0\n */\nexport var bracket = function (acquire, use, release) { return bracketW(acquire, use, release); };\n/**\n * Less strict version of [`bracket`](#bracket).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var bracketW = function (acquire, use, release) {\n    return flatMap(acquire, function (a) { return T.flatMap(use(a), function (e) { return flatMap(release(a, e), function () { return T.of(e); }); }); });\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return flow(T.traverseReadonlyNonEmptyArrayWithIndex(f), T.map(E.traverseReadonlyNonEmptyArrayWithIndex(SK)));\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (ebs) {\n                    return _.isLeft(ebs)\n                        ? acc\n                        : f(i + 1, a)().then(function (eb) {\n                            if (_.isLeft(eb)) {\n                                return eb;\n                            }\n                            ebs.right.push(eb.right);\n                            return ebs;\n                        });\n                });\n            }, f(0, _.head(as))().then(E.map(_.singleton)));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) { return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirst = tapError;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirstW = tapError;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEither`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEither = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEitherSeq`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEitherSeq = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = function (S) {\n    return getApplySemigroup_(T.ApplySeq)(E.getSemigroup(S));\n};\n/**\n * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getTaskValidation(SE) {\n    var applicativeTaskValidation = getApplicativeTaskValidation(T.ApplicativePar, SE);\n    var altTaskValidation = getAltTaskValidation(SE);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: applicativeTaskValidation.ap,\n        of: of,\n        chain: flatMap,\n        bimap: mapBoth,\n        mapLeft: mapError,\n        alt: altTaskValidation.alt,\n        fromIO: fromIO,\n        fromTask: fromTask,\n        throwError: throwError\n    };\n}\n","import type { MaybeAccessor } from '@/types.js';\n\nexport function access<T>(value: MaybeAccessor<T>): T {\n  return typeof value === 'function' ? (value as any)() as T : value;\n}\n","import { batch, computed, signal } from '@tma.js/signals';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport interface MountableOptions<S, Err> {\n  /**\n   * A state to use if the `restoreState` function returned falsy value or\n   * `isPageReload` returned false.\n   */\n  initialState: S | (() => E.Either<Err, S>);\n  /**\n   * @returns True if the current page was reloaded.\n   */\n  isPageReload: MaybeAccessor<boolean>;\n  /**\n   * A function to call whenever the component was mounted.\n   * @param state - restored state.\n   */\n  onMounted?: (state: S) => void;\n  /**\n   * A function to call whenever the component was unmounted.\n   */\n  onUnmounted?: VoidFunction;\n  /**\n   * Attempts to restore previously saved component state. This function\n   * will only be called if the current page was reloaded.\n   */\n  restoreState: () => (S | undefined);\n}\n\nexport class Mountable<S extends object, Err = never> {\n  constructor({\n    onMounted,\n    restoreState,\n    initialState,\n    onUnmounted,\n    isPageReload,\n  }: MountableOptions<S, Err>) {\n    this.mount = () => {\n      if (this.isMounted()) {\n        return E.right(undefined);\n      }\n      const restored = access(isPageReload) ? restoreState() : undefined;\n      const state = restored\n        ? E.right(restored)\n        : (typeof initialState === 'function' ? initialState() : E.right(initialState));\n\n      return fn.pipe(state, E.map(s => {\n        batch(() => {\n          this._isMounted.set(true);\n          onMounted?.(s);\n        });\n      }));\n    };\n\n    this.unmount = () => {\n      if (this._isMounted()) {\n        batch(() => {\n          this._isMounted.set(false);\n          onUnmounted?.();\n        });\n      }\n    };\n  }\n\n  private readonly _isMounted = signal(false);\n\n  /**\n   * Signal indicating if the component is mounted.\n   */\n  readonly isMounted = computed(this._isMounted);\n\n  /**\n   * Mounts the component restoring its state and calling required side effects.\n   */\n  readonly mount: () => E.Either<Err, void>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n}\n","import type { UnionRequiredKeys } from '@tma.js/toolkit';\n\ntype RemoveUndefined<T> = {\n  [K in UnionRequiredKeys<T>]-?: T[K]\n};\n\n/**\n * @returns Object with keys having undefined values.\n * @param value - an object to remove undefined values from.\n */\nexport function removeUndefined<T extends {}>(value: T): RemoveUndefined<T> {\n  const result = {} as RemoveUndefined<T>;\n  for (const k in value) {\n    const v = value[k];\n    v !== undefined && ((result as any)[k] = v);\n  }\n  return result;\n}\n","export function shallowEqual<T extends object>(a: T, b: T): boolean {\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  return aKeys.length !== bKeys.length\n    ? false\n    : aKeys.every(aKey => {\n      return Object.prototype.hasOwnProperty.call(b, aKey)\n        && (a as any)[aKey] === (b as any)[aKey];\n    });\n}\n","import { type Computed, computed, type Signal, signal } from '@tma.js/signals';\n\nimport { removeUndefined } from '@/helpers/removeUndefined.js';\nimport { shallowEqual } from '@/helpers/shallowEqual.js';\n\nexport interface StatefulOptions<S> {\n  /**\n   * The initial state.\n   */\n  initialState: S;\n  /**\n   * A function to call whenever the state changes.\n   * @param state - updated state.\n   */\n  onChange: (state: S) => void;\n}\n\nexport class Stateful<S extends object> {\n  constructor({ initialState, onChange }: StatefulOptions<S>) {\n    this._state = signal(initialState, { equals: shallowEqual });\n    this.state = computed(this._state);\n    this.state.sub(onChange);\n  }\n\n  protected readonly _state: Signal<S>;\n\n  /**\n   * The current state.\n   */\n  readonly state: Computed<S>;\n\n  /**\n   * Creates a computed signal based on the state.\n   * @param key - a state key to use as a source.\n   */\n  getter<K extends keyof S>(key: K): Computed<S[K]> {\n    return computed(() => this._state()[key]);\n  }\n\n  /**\n   * Updates the state.\n   * @param state - updates to apply.\n   */\n  readonly setState = (state: Partial<S>): void => {\n    const nextState = { ...this.state(), ...removeUndefined(state) };\n    if (!shallowEqual(nextState, this.state())) {\n      this._state.set(nextState);\n    }\n  };\n\n  /**\n   * @returns True if specified payload will update the state.\n   * @param state\n   */\n  hasDiff(state: Partial<S>): boolean {\n    return !shallowEqual({ ...this.state(), ...removeUndefined(state) }, this.state());\n  }\n}\n","// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message2, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message2);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message2, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message2);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message2, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message2);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message2 = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message2 !== void 0) {\n    issue.message = typeof message2 === \"function\" ? (\n      // @ts-expect-error\n      message2(issue)\n    ) : message2;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getLastMetadata/_getLastMetadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getLastMetadata(schema, type) {\n  if (\"pipe\" in schema) {\n    const nestedSchemas = [];\n    for (let index = schema.pipe.length - 1; index >= 0; index--) {\n      const item = schema.pipe[index];\n      if (item.kind === \"schema\" && \"pipe\" in item) {\n        nestedSchemas.push(item);\n      } else if (item.kind === \"metadata\" && item.type === type) {\n        return item[type];\n      }\n    }\n    for (const nestedSchema of nestedSchemas) {\n      const result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n  }\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values2, separator) {\n  const list = [...new Set(values2)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries2 = {};\n  for (const key of list) {\n    entries2[key] = schema;\n  }\n  return entries2;\n}\n\n// src/utils/entriesFromObjects/entriesFromObjects.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromObjects(schemas) {\n  const entries2 = {};\n  for (const schema of schemas) {\n    Object.assign(entries2, schema.entries);\n  }\n  return entries2;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = (\n  // eslint-disable-next-line regexp/prefer-w, no-useless-escape, regexp/no-useless-escape, regexp/require-unicode-regexp\n  /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n);\nvar SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message2) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message2) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message: message2,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message: message2,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message2) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message2) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message2) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message2) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message2) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message2) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message2) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/entries/entries.ts\n// @__NO_SIDE_EFFECTS__\nfunction entries(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"entries\",\n    reference: entries,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (!dataset.typed) return dataset;\n      const count = Object.keys(dataset.value).length;\n      if (dataset.typed && count !== this.requirement) {\n        _addIssue(this, \"entries\", dataset, config2, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message2) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message2) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/flavor/flavor.ts\n// @__NO_SIDE_EFFECTS__\nfunction flavor(name) {\n  return {\n    kind: \"transformation\",\n    type: \"flavor\",\n    reference: flavor,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/gtValue/gtValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction gtValue(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"gt_value\",\n    reference: gtValue,\n    async: false,\n    expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value > this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message2) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message2) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message2) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message2) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message2) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message2) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message2) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message2) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message2) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message2) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message2) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message2) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message2) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message2) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message2) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ltValue/ltValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction ltValue(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"lt_value\",\n    reference: ltValue,\n    async: false,\n    expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value < this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message2) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message2) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message2) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxEntries/maxEntries.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxEntries(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"max_entries\",\n    reference: maxEntries,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (!dataset.typed) return dataset;\n      const count = Object.keys(dataset.value).length;\n      if (dataset.typed && count > this.requirement) {\n        _addIssue(this, \"entries\", dataset, config2, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minEntries/minEntries.ts\n// @__NO_SIDE_EFFECTS__\nfunction minEntries(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"min_entries\",\n    reference: minEntries,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (!dataset.typed) return dataset;\n      const count = Object.keys(dataset.value).length;\n      if (dataset.typed && count < this.requirement) {\n        _addIssue(this, \"entries\", dataset, config2, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement != 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message2) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message2) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notEntries/notEntries.ts\n// @__NO_SIDE_EFFECTS__\nfunction notEntries(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"not_entries\",\n    reference: notEntries,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (!dataset.typed) return dataset;\n      const count = Object.keys(dataset.value).length;\n      if (dataset.typed && count === this.requirement) {\n        _addIssue(this, \"entries\", dataset, config2, {\n          received: `${count}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValues/notValues.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValues(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"not_values\",\n    reference: notValues,\n    async: false,\n    expects: `!${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message2) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/parseJson/parseJson.ts\n// @__NO_SIDE_EFFECTS__\nfunction parseJson(config2, message2) {\n  return {\n    kind: \"transformation\",\n    type: \"parse_json\",\n    reference: parseJson,\n    config: config2,\n    message: message2,\n    async: false,\n    \"~run\"(dataset, config3) {\n      try {\n        dataset.value = JSON.parse(dataset.value, this.config?.reviver);\n      } catch (error) {\n        if (error instanceof Error) {\n          _addIssue(this, \"JSON\", dataset, config3, {\n            received: `\"${error.message}\"`\n          });\n          dataset.typed = false;\n        } else {\n          throw error;\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, paths) {\n  if (dataset.issues) {\n    for (const path of paths) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (\n            // @ts-expect-error\n            path[index] !== issue.path[index].key && // @ts-expect-error\n            (path[index] !== \"$\" || issue.path[index].type !== \"array\")\n          ) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(paths, requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    paths,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(paths, requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    paths,\n    requirement,\n    message: message2,\n    async \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message2) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message2) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/slug/slug.ts\n// @__NO_SIDE_EFFECTS__\nfunction slug(message2) {\n  return {\n    kind: \"validation\",\n    type: \"slug\",\n    reference: slug,\n    async: false,\n    expects: null,\n    requirement: SLUG_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"slug\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/stringifyJson/stringifyJson.ts\n// @__NO_SIDE_EFFECTS__\nfunction stringifyJson(config2, message2) {\n  return {\n    kind: \"transformation\",\n    type: \"stringify_json\",\n    reference: stringifyJson,\n    message: message2,\n    config: config2,\n    async: false,\n    \"~run\"(dataset, config3) {\n      try {\n        const output = JSON.stringify(\n          dataset.value,\n          // @ts-expect-error\n          this.config?.replacer,\n          this.config?.space\n        );\n        if (output === void 0) {\n          _addIssue(this, \"JSON\", dataset, config3);\n          dataset.typed = false;\n        }\n        dataset.value = output;\n      } catch (error) {\n        if (error instanceof Error) {\n          _addIssue(this, \"JSON\", dataset, config3, {\n            received: `\"${error.message}\"`\n          });\n          dataset.typed = false;\n        } else {\n          throw error;\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message2) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message2) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message2) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/values/values.ts\n// @__NO_SIDE_EFFECTS__\nfunction values(requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"values\",\n    reference: values,\n    async: false,\n    expects: `${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message2) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message: message2,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, path) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, path) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDescription/getDescription.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDescription(schema) {\n  return _getLastMetadata(schema, \"description\");\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getMetadata/getMetadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction getMetadata(schema) {\n  const result = {};\n  function depthFirstMerge(schema2) {\n    if (\"pipe\" in schema2) {\n      for (const item of schema2.pipe) {\n        if (item.kind === \"schema\" && \"pipe\" in item) {\n          depthFirstMerge(item);\n        } else if (item.kind === \"metadata\" && item.type === \"metadata\") {\n          Object.assign(result, item.metadata);\n        }\n      }\n    }\n  }\n  depthFirstMerge(schema);\n  return result;\n}\n\n// src/methods/getTitle/getTitle.ts\n// @__NO_SIDE_EFFECTS__\nfunction getTitle(schema) {\n  return _getLastMetadata(schema, \"title\");\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message2) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message2) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message2) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message2) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message2) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message2) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message2) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message2) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message2) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message2) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message2) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message2) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message2) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries: entries2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries: entries2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message2) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message2) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message2) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message2) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message2) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message2) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message2) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message2) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message2) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message2) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message2) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message2) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries: entries2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries: entries2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries2, rest, message2) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries: entries2,\n    rest,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries2, rest, message2) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries: entries2,\n    rest,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message2) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message2) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries: entries2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries2, message2) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries: entries2,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message2) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message2) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message2) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message2) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message2) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message2) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message2) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message2) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message2) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message2) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message2) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message2) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  { abortEarly: true }\n                ).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message2) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? (await discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  { abortEarly: true }\n                )).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message2) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message: message2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message2) {\n  return picklist(Object.keys(schema.entries), message2);\n}\n\n// src/methods/message/message.ts\n// @__NO_SIDE_EFFECTS__\nfunction message(schema, message_) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return schema[\"~run\"](dataset, { ...config2, message: message_ });\n    }\n  };\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries2 = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries2[key];\n  }\n  return {\n    ...schema,\n    entries: entries2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries2 = {};\n  for (const key in schema.entries) {\n    entries2[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries: entries2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries2 = {};\n  for (const key in schema.entries) {\n    entries2[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries: entries2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries2 = {};\n  for (const key of keys) {\n    entries2[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries: entries2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message2 = Array.isArray(arg2) ? arg3 : arg2;\n  const entries2 = {};\n  for (const key in schema.entries) {\n    entries2[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message2) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries: entries2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message2 = Array.isArray(arg2) ? arg3 : arg2;\n  const entries2 = {};\n  for (const key in schema.entries) {\n    entries2[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message2) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries: entries2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/summarize/summarize.ts\n// @__NO_SIDE_EFFECTS__\nfunction summarize(issues) {\n  let summary = \"\";\n  for (const issue of issues) {\n    if (summary) {\n      summary += \"\\n\";\n    }\n    summary += `\\xD7 ${issue.message}`;\n    const dotPath = getDotPath(issue);\n    if (dotPath) {\n      summary += `\n  \\u2192 at ${dotPath}`;\n    }\n  }\n  return summary;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  SLUG_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getLastMetadata,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entries,\n  entriesFromList,\n  entriesFromObjects,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  flavor,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDescription,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getMetadata,\n  getSchemaMessage,\n  getSpecificMessage,\n  getTitle,\n  graphemes,\n  gtValue,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  ltValue,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxEntries,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  message,\n  metadata,\n  mimeType,\n  minBytes,\n  minEntries,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notEntries,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notValues,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parseJson,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  slug,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  stringifyJson,\n  summarize,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  values,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n","var $ = Object.defineProperty;\nvar q = (r, e, t) => e in r ? $(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar w = (r, e, t) => q(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nvar D = Object.defineProperty, G = (r, e, t) => e in r ? D(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, E = (r, e, t) => G(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nfunction I(r) {\n  return (e) => e instanceof r;\n}\nfunction L(r, e) {\n  const t = class extends Error {\n    constructor(...d) {\n      const l = typeof e == \"function\" ? e(...d) : typeof e == \"string\" ? [e] : e || [];\n      super(...l), this.name = r;\n    }\n  };\n  E(t, \"is\", I(t));\n  let c = t;\n  return Object.defineProperty(c, \"name\", { value: r }), c;\n}\nfunction H(r, e, t) {\n  const c = class extends L(r, t) {\n    constructor(...l) {\n      super(...l), E(this, \"data\"), this.data = e(...l);\n    }\n  };\n  E(c, \"is\", I(c));\n  let o = c;\n  return Object.defineProperty(o, \"name\", { value: r }), o;\n}\nclass J extends L(\"CancelledError\", \"Promise was canceled\") {\n}\nclass K extends H(\n  \"TimeoutError\",\n  (e) => ({ timeout: e }),\n  (e, t) => [`Timeout reached: ${e}ms`, { cause: t }]\n) {\n}\nconst S = Symbol(\"resolved\");\nfunction V(r) {\n  return typeof r == \"object\" && !!r && \"tag\" in r && r.tag === S;\n}\nfunction M(r) {\n  return { tag: S, value: r };\n}\nfunction C(r, e) {\n  return r.reject = e.reject, r.resolve = e.resolve, r;\n}\nclass g extends Promise {\n  constructor(t, c) {\n    let o, d, l, p;\n    typeof t == \"function\" ? (l = t, p = c || {}) : p = t || {};\n    let u, a;\n    const x = () => !!a, O = () => !!u;\n    let f = {};\n    const b = [], T = () => {\n      b.forEach((m) => m()), b.splice(0, b.length), f = {};\n    }, y = new AbortController(), k = () => O() || x();\n    super((m, F) => {\n      const { abortOnResolve: P = !0, abortOnReject: A = !0 } = p;\n      d = (n) => {\n        var h, s;\n        k() || (m(n), u = [n], (h = f.resolved) == null || h.forEach((i) => i(n)), (s = f.finalized) == null || s.forEach((i) => i({ kind: \"resolved\", result: n })), T(), P && y.abort(M(n)));\n      }, o = (n) => {\n        var h, s;\n        k() || (F(n), a = [n], (h = f.rejected) == null || h.forEach((i) => i(n)), (s = f.finalized) == null || s.forEach((i) => i({ kind: \"rejected\", reason: n })), T(), A && y.abort(n));\n      };\n      const { abortSignal: j } = p;\n      if (j) {\n        if (j.aborted)\n          return o(j.reason);\n        const n = () => {\n          o(j.reason);\n        };\n        j.addEventListener(\"abort\", n, !0), b.push(() => {\n          j.removeEventListener(\"abort\", n, !0);\n        });\n      }\n      const { timeout: R } = p;\n      if (R) {\n        const n = setTimeout(() => {\n          o(new K(R));\n        }, R);\n        b.push(() => {\n          clearTimeout(n);\n        });\n      }\n      try {\n        const n = () => {\n        }, h = l && l(d, o, {\n          abortSignal: y.signal,\n          get isRejected() {\n            return x();\n          },\n          get isResolved() {\n            return O();\n          },\n          on(s, i) {\n            if (u || a) {\n              if (s === \"finalized\") {\n                const v = u ? { kind: \"resolved\", result: u[0] } : { kind: \"rejected\", reason: a[0] };\n                i(v);\n              } else s === \"resolved\" && u ? i(u[0]) : s === \"rejected\" && a && i(a[0]);\n              return n;\n            }\n            return f[s] || (f[s] = []), f[s].push(i), () => {\n              const v = f[s] || [], z = v.indexOf(i);\n              z >= 0 && v.splice(z, 1);\n            };\n          },\n          get result() {\n            return u == null ? void 0 : u[0];\n          },\n          get rejectReason() {\n            return a == null ? void 0 : a[0];\n          },\n          throwIfRejected() {\n            if (a)\n              throw a[0];\n          }\n        });\n        h instanceof Promise && h.catch(o);\n      } catch (n) {\n        o(n);\n      }\n    });\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    w(this, \"reject\");\n    /**\n     * Resolves the promise.\n     */\n    w(this, \"resolve\");\n    this.reject = o, this.resolve = d;\n  }\n  static fn(t, c) {\n    return new g(async (o, d, l) => {\n      try {\n        o(await t(l));\n      } catch (p) {\n        d(p);\n      }\n    }, c);\n  }\n  static resolve(t) {\n    return this.fn(() => t);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new g((c, o) => {\n      o(t);\n    });\n  }\n  /**\n   * Rejects the promise with the `CancelledError` error.\n   */\n  cancel() {\n    this.reject(new J());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return C(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, c) {\n    return C(\n      super.then(t, c),\n      this\n    );\n  }\n}\nexport {\n  g as BetterPromise,\n  J as CancelledError,\n  K as TimeoutError,\n  V as isResolved,\n  M as withResolved\n};\n//# sourceMappingURL=index.js.map\n","import { BetterPromise as d } from \"better-promises\";\nimport { function as f, taskEither as i, either as u } from \"fp-ts\";\nfunction L(t) {\n  return t.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction $(t) {\n  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction x(t) {\n  return Object.entries(t).reduce((e, [o, r]) => (e[$(o)] = r, e), {});\n}\nfunction k(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction S(t) {\n  return Object.entries(t).reduce((e, [o, r]) => (e[k(o)] = r, e), {});\n}\nfunction m(t) {\n  const e = S(t);\n  for (const o in e) {\n    const r = e[o];\n    r && typeof r == \"object\" && !(r instanceof Date) && (e[o] = Array.isArray(r) ? r.map(m) : m(r));\n  }\n  return e;\n}\nfunction A(t) {\n  return t.replace(/_([a-z])/g, (e, o) => `-${o.toLowerCase()}`);\n}\nfunction h(t) {\n  return `tapps/${t}`;\n}\nfunction K(t, e) {\n  sessionStorage.setItem(h(t), JSON.stringify(e));\n}\nfunction _(t) {\n  const e = sessionStorage.getItem(h(t));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction v(...t) {\n  const e = t.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((o) => {\n        o();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction D(t, e) {\n  e || (e = {});\n  const {\n    textColor: o,\n    bgColor: r,\n    shouldLog: c\n  } = e, n = c === void 0 ? !0 : c, b = typeof n == \"boolean\" ? () => n : n, g = (a, s, ...l) => {\n    if (s || b()) {\n      const p = \"font-weight:bold;padding:0 5px;border-radius:100px\", [y, C, w] = {\n        log: [\"#0089c3\", \"white\", \"INFO\"],\n        error: [\"#ff0000F0\", \"white\", \"ERR\"],\n        warn: [\"#D38E15\", \"white\", \"WARN\"]\n      }[a];\n      console[a](\n        `%c${w} ${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c %c${t}`,\n        `${p};background-color:${y};color:${C}`,\n        \"\",\n        `${p};${o ? `color:${o};` : \"\"}${r ? `background-color:${r}` : \"\"}`,\n        ...l\n      );\n    }\n  };\n  return [\n    [\"log\", \"forceLog\"],\n    [\"warn\", \"forceWarn\"],\n    [\"error\", \"forceError\"]\n  ].reduce((a, [s, l]) => (a[s] = g.bind(void 0, s, !1), a[l] = g.bind(void 0, s, !0), a), {});\n}\nfunction T(t) {\n  const e = (o) => {\n    throw o;\n  };\n  return typeof t == \"function\" ? d.resolve(f.pipe(t, i.match(e, (o) => o))()) : f.pipe(t, u.match(e, (o) => o));\n}\n// @__NO_SIDE_EFFECTS__\nfunction F(t) {\n  return Object.assign(\n    (...e) => T(t(...e)),\n    t\n  );\n}\nconst O = /* @__PURE__ */ Object.assign(\n  (t, e) => f.pipe(\n    i.tryCatch(\n      () => new d((o, r, c) => t(\n        (n) => o(u.right(n)),\n        (n) => o(u.left(n)),\n        c\n      ), e),\n      (o) => o\n    ),\n    i.chainW(u.match(i.left, i.right))\n  ),\n  {\n    fn: (t, e) => O((o, r, c) => {\n      const n = t(c);\n      f.pipe(\n        typeof n == \"function\" ? n : i.fromEither(n),\n        i.matchW(r, o)\n      )();\n    }, e)\n  }\n);\nexport {\n  O as BetterTaskEither,\n  L as camelToKebab,\n  $ as camelToSnake,\n  x as camelToSnakeObjKeys,\n  v as createCbCollector,\n  D as createLogger,\n  m as deepSnakeToCamelObjKeys,\n  _ as getStorageValue,\n  K as setStorageValue,\n  k as snakeToCamel,\n  S as snakeToCamelObjKeys,\n  A as snakeToKebab,\n  T as throwifyAnyEither,\n  F as throwifyFpFn\n};\n//# sourceMappingURL=index.js.map\n","var l = Object.defineProperty;\nvar o = (e, t, n) => t in e ? l(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar c = (e, t, n) => o(e, typeof t != \"symbol\" ? t + \"\" : t, n);\nfunction f(e) {\n  return (t) => t instanceof e;\n}\nfunction u(e, t) {\n  const s = class s extends Error {\n    constructor(...d) {\n      const i = typeof t == \"function\" ? t(...d) : typeof t == \"string\" ? [t] : t || [];\n      super(...i), this.name = e;\n    }\n  };\n  c(s, \"is\", f(s));\n  let n = s;\n  return Object.defineProperty(n, \"name\", { value: e }), n;\n}\nfunction y(e, t, n) {\n  const a = class a extends u(e, n) {\n    constructor(...r) {\n      super(...r);\n      c(this, \"data\");\n      this.data = t(...r);\n    }\n  };\n  c(a, \"is\", f(a));\n  let s = a;\n  return Object.defineProperty(s, \"name\", { value: e }), s;\n}\nexport {\n  u as errorClass,\n  y as errorClassWithData\n};\n//# sourceMappingURL=index.js.map\n","import { throwifyFpFn as g } from \"@tma.js/toolkit\";\nimport { either as s, function as G } from \"fp-ts\";\nimport { pipe as u, string as e, check as y, transform as c, union as S, instance as P, parse as b, looseObject as m, optional as n, number as _, boolean as d, integer as W, date as C, record as F, is as T, unknown as J } from \"valibot\";\nfunction N(t) {\n  const r = (a) => {\n    const o = {};\n    return new URLSearchParams(a).forEach((i, f) => {\n      const h = o[f];\n      Array.isArray(h) ? h.push(i) : h === void 0 ? o[f] = i : o[f] = [h, i];\n    }), b(t, o);\n  };\n  return u(\n    S([e(), P(URLSearchParams)]),\n    y((a) => {\n      try {\n        return r(a), !0;\n      } catch {\n        return !1;\n      }\n    }, \"The value doesn't match required schema\"),\n    c(r)\n  );\n}\nfunction O(t) {\n  return u(\n    e(),\n    y((r) => {\n      try {\n        return JSON.parse(r), !0;\n      } catch {\n        return !1;\n      }\n    }, \"Input is not a valid JSON value\"),\n    c(JSON.parse),\n    t\n  );\n}\nfunction p(t) {\n  return u(e(), O(t));\n}\nfunction B(t) {\n  return u(\n    S([e(), P(URLSearchParams)]),\n    N(t)\n  );\n}\nfunction l(t) {\n  return (r) => t.test(r);\n}\nconst I = l(/^#[\\da-f]{3}$/i), U = l(/^#[\\da-f]{4}$/i), z = l(/^#[\\da-f]{6}$/i), E = l(/^#[\\da-f]{8}$/i);\nfunction V(t) {\n  return [z, E, I, U].some((r) => r(t));\n}\nfunction A(t) {\n  let r = \"#\";\n  for (let a = 0; a < t.length - 1; a += 1)\n    r += t[1 + a].repeat(2);\n  return r;\n}\nfunction D(t) {\n  const r = t.replace(/\\s/g, \"\").toLowerCase();\n  if (/^#[\\da-f]{3}$/i.test(r))\n    return s.right(A(r.toLowerCase() + \"f\"));\n  if (/^#[\\da-f]{4}$/i.test(r))\n    return s.right(A(r.toLowerCase()));\n  if (/^#[\\da-f]{6}$/i.test(r))\n    return s.right(r.toLowerCase() + \"ff\");\n  if (/^#[\\da-f]{8}$/i.test(r))\n    return s.right(r.toLowerCase());\n  const a = r.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || r.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/);\n  return a ? s.right(\n    a.slice(1).reduce(\n      (o, i) => o + parseInt(i, 10).toString(16).padStart(2, \"0\"),\n      \"#\"\n    ).padEnd(9, \"f\")\n  ) : s.left(new Error(`Value \"${t}\" does not satisfy any of known RGB formats.`));\n}\nfunction q(t) {\n  return G.pipe(\n    D(t),\n    s.map((r) => r.slice(0, 7))\n  );\n}\nconst v = g(q), tt = g(D);\nfunction x() {\n  return m({\n    id: _(),\n    photo_url: n(e()),\n    type: e(),\n    title: e(),\n    username: n(e())\n  });\n}\nfunction w() {\n  return m({\n    added_to_attachment_menu: n(d()),\n    allows_write_to_pm: n(d()),\n    first_name: e(),\n    id: _(),\n    is_bot: n(d()),\n    is_premium: n(d()),\n    last_name: n(e()),\n    language_code: n(e()),\n    photo_url: n(e()),\n    username: n(e())\n  });\n}\nfunction j() {\n  return m({\n    auth_date: u(\n      e(),\n      c((t) => new Date(Number(t) * 1e3)),\n      C()\n    ),\n    can_send_after: n(u(e(), c(Number), W())),\n    chat: n(p(x())),\n    chat_type: n(e()),\n    chat_instance: n(e()),\n    hash: e(),\n    query_id: n(e()),\n    receiver: n(p(w())),\n    start_param: n(e()),\n    signature: e(),\n    user: n(p(w()))\n  });\n}\nfunction L() {\n  return B(j());\n}\nfunction R() {\n  return F(\n    e(),\n    u(\n      S([e(), _()]),\n      c((t) => typeof t == \"number\" ? `#${(t & 16777215).toString(16).padStart(6, \"0\")}` : t),\n      y(V)\n    )\n  );\n}\nfunction M() {\n  const t = n(u(e(), c((r) => r === \"1\")));\n  return m({\n    tgWebAppBotInline: t,\n    tgWebAppData: n(L()),\n    tgWebAppDefaultColors: n(p(R())),\n    tgWebAppFullscreen: t,\n    tgWebAppPlatform: e(),\n    tgWebAppShowSettings: t,\n    tgWebAppStartParam: n(e()),\n    tgWebAppThemeParams: p(R()),\n    tgWebAppVersion: e()\n  });\n}\nfunction Q() {\n  return B(M());\n}\nfunction rt(t) {\n  try {\n    return T(Q(), t);\n  } catch {\n    return !1;\n  }\n}\nfunction et() {\n  return m({\n    eventType: e(),\n    eventData: n(J())\n  });\n}\nfunction H(t) {\n  return s.tryCatch(\n    () => b(L(), t),\n    (r) => r\n  );\n}\nfunction K(t) {\n  return s.tryCatch(\n    () => b(Q(), t),\n    (r) => r\n  );\n}\nconst nt = g(H), at = g(K);\nfunction $(t, r) {\n  return r || (r = (a, o) => JSON.stringify(o)), new URLSearchParams(\n    Object.entries(t).reduce((a, [o, i]) => (Array.isArray(i) ? a.push(...i.map((f) => [o, String(f)])) : i != null && a.push([\n      o,\n      i instanceof Date ? (i.getTime() / 1e3 | 0).toString() : typeof i == \"string\" || typeof i == \"number\" ? String(i) : typeof i == \"boolean\" ? i ? \"1\" : \"0\" : r(o, i)\n    ]), a), [])\n  ).toString();\n}\nfunction X(t) {\n  return $(t);\n}\nfunction it(t) {\n  return $(t, (r, a) => r === \"tgWebAppData\" ? X(a) : JSON.stringify(a));\n}\nexport {\n  j as initData,\n  x as initDataChat,\n  L as initDataQuery,\n  w as initDataUser,\n  V as isAnyRGB,\n  rt as isLaunchParamsQuery,\n  z as isRGB,\n  E as isRGBA,\n  U as isRGBAShort,\n  I as isRGBShort,\n  M as launchParams,\n  Q as launchParamsQuery,\n  et as miniAppsMessage,\n  nt as parseInitDataQuery,\n  H as parseInitDataQueryFp,\n  at as parseLaunchParamsQuery,\n  K as parseLaunchParamsQueryFp,\n  p as pipeJsonToSchema,\n  B as pipeQueryToSchema,\n  X as serializeInitDataQuery,\n  it as serializeLaunchParamsQuery,\n  R as themeParams,\n  v as toRGB,\n  q as toRGBFp,\n  tt as toRGBFull,\n  D as toRGBFullFp\n};\n//# sourceMappingURL=index.js.map\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","import { is as O, looseObject as m, function as Y, nullish as v, boolean as I, number as $, string as E, optional as z, unknown as me, parse as F, any as we } from \"valibot\";\nimport { throwifyFpFn as T, getStorageValue as de, setStorageValue as X, createLogger as ge, throwifyAnyEither as A, createCbCollector as Z, BetterTaskEither as ee } from \"@tma.js/toolkit\";\nimport { createLogger as yt, deepSnakeToCamelObjKeys as vt } from \"@tma.js/toolkit\";\nimport { BetterPromise as te, TimeoutError as be } from \"better-promises\";\nimport { CancelledError as Pt, TimeoutError as kt } from \"better-promises\";\nimport { function as f, either as c, option as L, taskEither as w, json as he } from \"fp-ts\";\nimport { errorClassWithData as ye, errorClass as k } from \"error-kid\";\nimport { parseLaunchParamsQueryFp as re, themeParams as ve, pipeJsonToSchema as ne, miniAppsMessage as oe, serializeLaunchParamsQuery as Ee, parseLaunchParamsQuery as Pe } from \"@tma.js/transformers\";\nimport { signal as b, computed as ae } from \"@tma.js/signals\";\nimport ke from \"mitt\";\nfunction se(e) {\n  return O(\n    m({ TelegramWebviewProxy: m({ postEvent: Y() }) }),\n    e\n  );\n}\nfunction ie() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nclass xe extends (/* @__PURE__ */ k(\"MethodUnsupportedError\", (t, r) => [\n  `Method \"${t}\" is unsupported in Mini Apps version ${r}`\n])) {\n}\nclass Se extends (/* @__PURE__ */ k(\"MethodParameterUnsupportedError\", (t, r, n) => [\n  `Parameter \"${r}\" of \"${t}\" method is unsupported in Mini Apps version ${n}`\n])) {\n}\nclass Te extends (/* @__PURE__ */ ye(\n  \"LaunchParamsRetrieveError\",\n  (t) => ({ errors: t }),\n  (t) => [\n    [\n      \"Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?\",\n      \" Refer to docs for more information:\",\n      \"https://docs.telegram-mini-apps.com/packages/tma-js-bridge/environment\",\n      \"\",\n      \"Collected errors:\",\n      ...t.map(({ source: r, error: n }) => `Source: ${r} / ${n instanceof Error ? n.message : String(n)}`)\n    ].join(`\n`)\n  ]\n)) {\n}\nclass Ae extends (/* @__PURE__ */ k(\"InvalidLaunchParamsError\", (t, r) => [\n  `Invalid value for launch params: ${t}`,\n  { cause: r }\n])) {\n}\nclass pe extends (/* @__PURE__ */ k(\"UnknownEnvError\")) {\n}\nclass Ce extends (/* @__PURE__ */ k(\n  \"InvokeCustomMethodError\",\n  (t) => [`Server returned error: ${t}`]\n)) {\n}\nconst V = \"launchParams\";\nfunction B(e) {\n  return e.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\");\n}\nfunction Me() {\n  return f.pipe(\n    C(),\n    c.chainW(re)\n  );\n}\nconst tt = T(Me);\nfunction qe() {\n  return f.pipe(\n    C(),\n    c.map((e) => {\n      const t = new URLSearchParams(e).get(\"tgWebAppData\");\n      return t ? L.some(t) : L.none;\n    })\n  );\n}\nfunction rt() {\n  return f.pipe(\n    qe(),\n    c.fold((e) => {\n      throw e;\n    }, (e) => e),\n    L.match(() => {\n    }, (e) => e)\n  );\n}\nfunction C() {\n  const e = [];\n  for (const [t, r] of [\n    // Try to retrieve launch parameters from the current location. This method\n    // can return nothing in case, location was changed, and then the page was\n    // reloaded.\n    [() => B(window.location.href), \"window.location.href\"],\n    // Then, try using the lower level API - window.performance.\n    [() => {\n      const n = performance.getEntriesByType(\"navigation\")[0];\n      return n && B(n.name);\n    }, \"performance navigation entries\"],\n    // Finally, try using the session storage.\n    [() => de(V), \"local storage\"]\n  ]) {\n    const n = t();\n    if (!n) {\n      e.push({ source: r, error: new Error(\"Source is empty\") });\n      continue;\n    }\n    const a = f.pipe(\n      re(n),\n      c.foldW((o) => o, () => !0)\n    );\n    if (typeof a != \"boolean\") {\n      e.push({ source: r, error: a });\n      continue;\n    }\n    return X(V, n), c.right(n);\n  }\n  return c.left(new Te(e));\n}\nconst nt = T(C);\nfunction We(e, t) {\n  const r = /* @__PURE__ */ new Map(), n = ke(), a = (o, s, p = !1) => {\n    const _ = r.get(o) || /* @__PURE__ */ new Map();\n    r.set(o, _);\n    const i = _.get(s) || [];\n    _.set(s, i);\n    const u = i.findIndex((l) => l[1] === p);\n    if (u >= 0 && (n.off(o, i[u][0]), i.splice(u, 1), !i.length && (_.delete(s), !_.size))) {\n      const l = r.size;\n      r.delete(o), l && !r.size && t();\n    }\n  };\n  return {\n    on(o, s, p) {\n      !r.size && e();\n      const _ = () => {\n        a(o, s, p);\n      }, i = (...d) => {\n        p && _(), o === \"*\" ? s({ name: d[0], payload: d[1] }) : s(...d);\n      };\n      n.on(o, i);\n      const u = r.get(o) || /* @__PURE__ */ new Map();\n      r.set(o, u);\n      const l = u.get(s) || [];\n      return u.set(s, l), l.push([i, p || !1]), _;\n    },\n    off: a,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    emit: n.emit,\n    clear() {\n      const o = r.size;\n      n.all.clear(), r.clear(), o && t();\n    }\n  };\n}\nfunction q(e, t) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: e, eventData: t }),\n    // We specify this kind of source here in order to allow the package's \"on\" function to\n    // capture it. The reason is this function always checks the event source and relies on\n    // it to be the parent window.\n    source: window.parent\n  }));\n}\nconst S = b(!1), R = b(\"https://web.telegram.org\"), Fe = (e) => {\n  g().log(\"Event received:\", e);\n}, ce = ae(S);\nfunction ot(e) {\n  e !== S() && (S.set(e), (e ? j : Oe)(\"*\", Fe));\n}\nconst _e = ae(R);\nfunction at(e) {\n  R.set(e), g().log(\"New target origin set\", e);\n}\nconst P = b((...e) => {\n  window.parent.postMessage(...e);\n}), g = b(ge(\"Bridge\", {\n  bgColor: \"#9147ff\",\n  textColor: \"white\",\n  shouldLog: ce\n}));\nfunction st() {\n  je(), [P, R, _e, S, ce, g].forEach((e) => {\n    e.unsubAll(), \"reset\" in e && e.reset();\n  });\n}\nfunction W(e, t, r) {\n  const n = [r], a = e[t];\n  typeof a == \"function\" && n.push(a);\n  const o = (...p) => {\n    n.forEach((_) => _(...p));\n  }, s = Object.assign((...p) => {\n    o(...p);\n  }, {\n    // Unwraps the composer.\n    unwrap() {\n      const { length: p } = n;\n      if (p === 1) {\n        delete e[t];\n        return;\n      }\n      if (p === 2) {\n        D(e, t, n[1]);\n        return;\n      }\n      n.unshift(1), D(e, t, o);\n    }\n  });\n  ue(\n    e,\n    t,\n    () => s,\n    (p) => n.push(p)\n  );\n}\nfunction G(e, t) {\n  const r = e[t];\n  ue(e, t, () => r, (n) => {\n    Object.entries(n).forEach(([a, o]) => {\n      r[a] = o;\n    });\n  });\n}\nfunction ue(e, t, r, n) {\n  Object.defineProperty(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    get: r,\n    set: n\n  });\n}\nfunction D(e, t, r) {\n  Object.defineProperty(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: r\n  });\n}\nconst Le = {\n  clipboard_text_received: m({\n    req_id: E(),\n    data: v(E())\n  }),\n  custom_method_invoked: m({\n    req_id: E(),\n    result: z(me()),\n    error: z(E())\n  }),\n  popup_closed: v(\n    m({ button_id: v(E(), () => {\n    }) }),\n    {}\n  ),\n  viewport_changed: v(\n    m({\n      height: $(),\n      width: v($(), () => window.innerWidth),\n      is_state_stable: I(),\n      is_expanded: I()\n    }),\n    // TODO: At the moment, macOS has a bug with the invalid event payload - it is always equal to\n    //  null. Leaving this default value until the bug is fixed.\n    () => ({\n      height: window.innerHeight,\n      is_state_stable: !0,\n      is_expanded: !0\n    })\n  ),\n  theme_changed: m({\n    theme_params: ve()\n  })\n};\nfunction J(e) {\n  if (e.source !== window.parent)\n    return;\n  let t;\n  try {\n    t = F(ne(oe()), e.data);\n  } catch {\n    return;\n  }\n  const { eventType: r, eventData: n } = t, a = Le[r];\n  let o;\n  try {\n    o = a ? F(a, n) : n;\n  } catch (s) {\n    return g().forceError(\n      [\n        `An error occurred processing the \"${r}\" event from the Telegram application.`,\n        \"Please, file an issue here:\",\n        \"https://github.com/Telegram-Mini-Apps/tma.js/issues/new/choose\"\n      ].join(`\n`),\n      t,\n      s\n    );\n  }\n  Re(r, o);\n}\nconst {\n  on: j,\n  off: Oe,\n  emit: Re,\n  clear: je\n} = We(\n  () => {\n    const e = window;\n    !e.TelegramGameProxy && (e.TelegramGameProxy = {}), W(e.TelegramGameProxy, \"receiveEvent\", q), G(e, \"TelegramGameProxy\"), !e.Telegram && (e.Telegram = {}), !e.Telegram.WebView && (e.Telegram.WebView = {}), W(e.Telegram.WebView, \"receiveEvent\", q), G(e.Telegram, \"WebView\"), W(e, \"TelegramGameProxy_receiveEvent\", q), window.addEventListener(\"message\", J);\n  },\n  () => {\n    [\n      [\"TelegramGameProxy_receiveEvent\"],\n      [\"TelegramGameProxy\", \"receiveEvent\"],\n      [\"Telegram\", \"WebView\", \"receiveEvent\"]\n    ].forEach((e) => {\n      const t = window;\n      let r = [void 0, t];\n      for (const o of e)\n        if (r = [r[1], r[1][o]], !r[1])\n          return;\n      const [n, a] = r;\n      \"unwrap\" in a && (a.unwrap(), n && n !== t && !Object.keys(n).length && delete t[e[0]]);\n    }), window.removeEventListener(\"message\", J);\n  }\n), Ue = (...e) => P()(...e);\nfunction Ie(e, t) {\n  f.pipe(\n    x(\n      // @ts-expect-error It's ok, TS can't determine a specific override.\n      e,\n      t\n    ),\n    c.mapLeft((r) => {\n      throw r;\n    })\n  );\n}\nfunction x(e, t) {\n  g().log(\"Posting event:\", t ? { eventType: e, eventData: t } : { eventType: e });\n  const r = window, n = JSON.stringify({ eventType: e, eventData: t });\n  return ie() ? (Ue(n, _e()), c.right(void 0)) : se(r) ? (r.TelegramWebviewProxy.postEvent(e, JSON.stringify(t)), c.right(void 0)) : O(m({ external: m({ notify: Y() }) }), r) ? (r.external.notify(n), c.right(void 0)) : c.left(new pe());\n}\nfunction U(e, t, r = {}) {\n  const {\n    // If no capture function was passed, we capture the first compatible event.\n    capture: n = () => !0,\n    postEvent: a = x\n  } = r, o = b(), [s, p] = Z();\n  (Array.isArray(t) ? t : [t]).forEach((i) => {\n    s(\n      j(i, (u) => {\n        const l = Array.isArray(t);\n        n(l ? { event: i, payload: u } : u) && o.set([\n          l ? { event: i, payload: u } : u\n        ]);\n      })\n    );\n  });\n  const _ = (i) => (p(), i);\n  return f.pipe(\n    async () => a(e, r.params),\n    w.chainW(() => ee((i, u, l) => {\n      const d = o();\n      if (d)\n        return i(d[0]);\n      const h = (y) => {\n        y && i(y[0]);\n      }, M = () => {\n        o.unsub(h);\n      };\n      o.sub(h), l.on(\"finalized\", M);\n    }, r)),\n    w.mapBoth(_, _)\n  );\n}\nfunction it(e, t, r) {\n  const { postEvent: n } = r || {};\n  return A(\n    // @ts-expect-error TypeScript will not be able to handle our overrides here.\n    U(e, t, {\n      ...r,\n      postEvent: n ? (...a) => {\n        try {\n          return n(...a), c.right(void 0);\n        } catch (o) {\n          return c.left(o);\n        }\n      } : x\n    })\n  );\n}\nfunction pt(e, t) {\n  const r = $e(\n    // @ts-expect-error TS doesn't get what override we are going to use.\n    e,\n    t\n  );\n  return typeof r == \"function\" ? te.fn(() => A(r)) : r;\n}\nfunction $e(e, t) {\n  const r = se(window);\n  if (!e)\n    return r || f.pipe(C(), c.match(() => !1, () => !0));\n  if (r)\n    return w.right(!0);\n  const { timeout: n = 100 } = t || {};\n  return f.pipe(\n    U(\"web_app_request_theme\", \"theme_changed\", { ...t, timeout: n }),\n    w.match(\n      (a) => be.is(a) || pe.is(a) ? c.right(!1) : c.left(a),\n      () => c.right(!0)\n    )\n  );\n}\nfunction ct({ launchParams: e, onEvent: t, resetPostMessage: r } = {}) {\n  if (e) {\n    const o = typeof e == \"string\" || e instanceof URLSearchParams ? e.toString() : (\n      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n      // value. We are doing it because we are working with tgWebAppData presented as a\n      // string, not an object as serializeLaunchParamsQuery requires.\n      Ee({ ...e, tgWebAppData: void 0 }) + (e.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(e.tgWebAppData.toString())}` : \"\")\n    );\n    try {\n      Pe(o);\n    } catch (s) {\n      throw new Ae(o, s);\n    }\n    X(\"launchParams\", o);\n  }\n  if (ie()) {\n    if (!t)\n      return;\n    r && P.reset();\n    const o = P();\n    P.set((...s) => {\n      const [p] = s, _ = () => {\n        o(...s);\n      };\n      try {\n        const i = F(ne(oe()), p);\n        t({ name: i.eventType, params: i.eventData }, _);\n      } catch {\n        _();\n      }\n    });\n    return;\n  }\n  const n = window.TelegramWebviewProxy || {}, a = n.postEvent || (() => {\n  });\n  window.TelegramWebviewProxy = {\n    ...n,\n    postEvent(o, s) {\n      const p = () => {\n        a(o, s);\n      };\n      t ? t({\n        name: o,\n        params: s ? JSON.parse(s) : void 0\n      }, p) : p();\n    }\n  }, g().log(\"Environment was mocked by the mockTelegramEnv function\");\n}\nfunction ze(e) {\n  return ({ req_id: t }) => t === e;\n}\nconst N = {\n  \"6.0\": [\n    \"iframe_ready\",\n    \"iframe_will_reload\",\n    \"web_app_close\",\n    \"web_app_data_send\",\n    \"web_app_expand\",\n    \"web_app_open_link\",\n    \"web_app_ready\",\n    \"web_app_request_theme\",\n    \"web_app_request_viewport\",\n    \"web_app_setup_main_button\",\n    \"web_app_setup_closing_behavior\"\n  ],\n  6.1: [\n    \"web_app_open_tg_link\",\n    \"web_app_open_invoice\",\n    \"web_app_setup_back_button\",\n    \"web_app_set_background_color\",\n    \"web_app_set_header_color\",\n    \"web_app_trigger_haptic_feedback\"\n  ],\n  6.2: [\"web_app_open_popup\"],\n  6.4: [\n    \"web_app_close_scan_qr_popup\",\n    \"web_app_open_scan_qr_popup\",\n    \"web_app_read_text_from_clipboard\",\n    { method: \"web_app_open_link\", param: \"try_instant_view\" }\n  ],\n  6.7: [\"web_app_switch_inline_query\"],\n  6.9: [\n    \"web_app_invoke_custom_method\",\n    \"web_app_request_write_access\",\n    \"web_app_request_phone\",\n    { method: \"web_app_set_header_color\", param: \"color\" }\n  ],\n  \"6.10\": [\"web_app_setup_settings_button\"],\n  7.2: [\n    \"web_app_biometry_get_info\",\n    \"web_app_biometry_open_settings\",\n    \"web_app_biometry_request_access\",\n    \"web_app_biometry_request_auth\",\n    \"web_app_biometry_update_token\"\n  ],\n  7.6: [\n    { method: \"web_app_open_link\", param: \"try_browser\" },\n    { method: \"web_app_close\", param: \"return_back\" }\n  ],\n  7.7: [\"web_app_setup_swipe_behavior\"],\n  7.8: [\"web_app_share_to_story\"],\n  \"7.10\": [\n    \"web_app_setup_secondary_button\",\n    \"web_app_set_bottom_bar_color\",\n    { method: \"web_app_setup_main_button\", param: \"has_shine_effect\" }\n  ],\n  \"8.0\": [\n    \"web_app_request_safe_area\",\n    \"web_app_request_content_safe_area\",\n    \"web_app_request_fullscreen\",\n    \"web_app_exit_fullscreen\",\n    \"web_app_set_emoji_status\",\n    \"web_app_add_to_home_screen\",\n    \"web_app_check_home_screen\",\n    \"web_app_request_emoji_status_access\",\n    \"web_app_check_location\",\n    \"web_app_open_location_settings\",\n    \"web_app_request_file_download\",\n    \"web_app_request_location\",\n    \"web_app_send_prepared_message\",\n    \"web_app_start_accelerometer\",\n    \"web_app_start_device_orientation\",\n    \"web_app_start_gyroscope\",\n    \"web_app_stop_accelerometer\",\n    \"web_app_stop_device_orientation\",\n    \"web_app_stop_gyroscope\",\n    \"web_app_toggle_orientation_lock\"\n  ],\n  \"9.0\": [\n    \"web_app_device_storage_clear\",\n    \"web_app_device_storage_get_key\",\n    \"web_app_device_storage_save_key\",\n    \"web_app_secure_storage_clear\",\n    \"web_app_secure_storage_get_key\",\n    \"web_app_secure_storage_restore_key\",\n    \"web_app_secure_storage_save_key\"\n  ],\n  9.1: [\"web_app_hide_keyboard\"]\n};\nfunction Q(e, t) {\n  return Object.keys(N).find((n) => N[n].some((a) => t ? typeof a == \"object\" && a.method === e && a.param === t : a === e)) || null;\n}\nfunction H(e) {\n  return e.split(\".\").map(Number);\n}\nfunction Ve(e, t) {\n  const r = H(e), n = H(t), a = Math.max(r.length, n.length);\n  for (let o = 0; o < a; o += 1) {\n    const s = r[o] || 0, p = n[o] || 0;\n    if (s !== p)\n      return s > p ? 1 : -1;\n  }\n  return 0;\n}\nfunction K(e, t, r) {\n  const n = r ? Q(\n    e,\n    t\n  ) : Q(e);\n  return n ? Ve(n, r || t) <= 0 : !1;\n}\nfunction _t(e, t = \"strict\") {\n  const r = typeof t == \"function\" ? t : (n) => {\n    const { method: a, version: o } = n, s = \"param\" in n ? new Se(a, n.param, o) : new xe(a, o);\n    if (t === \"strict\")\n      throw s;\n    return g().forceWarn(s.message);\n  };\n  return (n, a) => K(n, e) ? n === \"web_app_set_header_color\" && O(m({ color: we() }), a) && !K(n, \"color\", e) ? r({ version: e, method: n, param: \"color\" }) : Ie(n, a) : r({ version: e, method: n });\n}\nfunction Be(e, t, r, n) {\n  return f.pipe(\n    U(\"web_app_invoke_custom_method\", \"custom_method_invoked\", {\n      ...n || {},\n      params: { method: e, params: t, req_id: r },\n      capture: ze(r)\n    }),\n    w.chain(({ result: a, error: o }) => o ? w.left(new Ce(o)) : w.right(a))\n  );\n}\nfunction ut(e, t, r, n) {\n  return te.fn(() => f.pipe(\n    // @ts-expect-error TypeScript is unable to determine required override.\n    Be(e, t, r, n),\n    w.match(\n      (a) => {\n        throw a;\n      },\n      (a) => a\n    )\n  )());\n}\nfunction Ge(e, t, r = {}) {\n  const {\n    // If no capture function was passed, we capture the first compatible event.\n    capture: n = () => !0,\n    postEvent: a = x\n  } = r, o = b(), [s, p] = Z();\n  (Array.isArray(t) ? t : [t]).forEach((i) => {\n    s(\n      j(i, (u) => {\n        (Array.isArray(t) ? n({ event: i, payload: u }) : n(u)) && o.set([u]);\n      })\n    );\n  });\n  const _ = (i) => (p(), i);\n  return f.pipe(\n    async () => a(e, r.params),\n    w.chainW(() => ee((i, u, l) => {\n      const d = o();\n      if (d)\n        return i(d[0]);\n      const h = (y) => {\n        y && i(y[0]);\n      }, M = () => {\n        o.unsub(h);\n      };\n      o.sub(h), l.on(\"finalized\", M);\n    }, r)),\n    w.mapBoth(_, _)\n  );\n}\nfunction lt(e, t, r) {\n  const { postEvent: n } = r || {};\n  return A(\n    // @ts-expect-error TypeScript will not be able to handle our overrides here.\n    Ge(e, t, {\n      ...r,\n      postEvent: n ? (...a) => {\n        try {\n          return n(...a), c.right(void 0);\n        } catch (o) {\n          return c.left(o);\n        }\n      } : x\n    })\n  );\n}\nfunction ft() {\n  Object.hasOwn || (Object.hasOwn = function(e, t) {\n    return Object.prototype.hasOwnProperty.call(e, t);\n  });\n}\nfunction le(e) {\n  return c.tryCatch(() => decodeURIComponent(\n    atob(\n      e.replace(/-/g, \"+\").replace(/_/g, \"/\")\n    ).split(\"\").map((t) => \"%\" + (\"00\" + t.charCodeAt(0).toString(16)).slice(-2)).join(\"\")\n  ), (t) => t);\n}\nconst mt = T(le);\nfunction fe(e) {\n  return btoa(\n    encodeURIComponent(e).replace(/%([0-9A-F]{2})/g, (t, r) => String.fromCharCode(parseInt(`0x${r}`)))\n  ).replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction De(e) {\n  const t = fe(typeof e == \"string\" ? e : JSON.stringify(e));\n  return t.length > 512 ? c.left(new Error(\"Value is too long for start parameter\")) : c.right(t);\n}\nconst wt = T(De);\nfunction dt(e, t) {\n  return A(\n    Je(\n      e,\n      // @ts-expect-error TypeScript is unable to detect a correct override.\n      typeof t == \"function\" ? (r) => c.tryCatch(() => t(r), (n) => n) : t\n    )\n  );\n}\nfunction Je(e, t) {\n  return f.pipe(\n    le(e),\n    c.chain((r) => t ? typeof t == \"function\" ? t(r) : he.parse(r) : c.right(r))\n  );\n}\nfunction gt(e) {\n  return fe(e).length <= 512;\n}\nexport {\n  Pt as CancelledError,\n  Ae as InvalidLaunchParamsError,\n  Ce as InvokeCustomMethodFailedError,\n  Te as LaunchParamsRetrieveError,\n  Se as MethodParameterUnsupportedError,\n  xe as MethodUnsupportedError,\n  kt as TimeoutError,\n  pe as UnknownEnvError,\n  ft as applyPolyfills,\n  ze as captureSameReq,\n  Ve as compareVersions,\n  yt as createLogger,\n  _t as createPostEvent,\n  wt as createStartParam,\n  De as createStartParamFp,\n  ce as debug,\n  mt as decodeBase64Url,\n  le as decodeBase64UrlFp,\n  dt as decodeStartParam,\n  Je as decodeStartParamFp,\n  vt as deepSnakeToCamelObjKeys,\n  q as emitEvent,\n  fe as encodeBase64Url,\n  Q as getReleaseVersion,\n  se as hasWebviewProxy,\n  ut as invokeCustomMethod,\n  Be as invokeCustomMethodFp,\n  ie as isIframe,\n  gt as isSafeToCreateStartParam,\n  pt as isTMA,\n  $e as isTMAFp,\n  g as logger,\n  ct as mockTelegramEnv,\n  Oe as off,\n  je as offAll,\n  j as on,\n  Ie as postEvent,\n  x as postEventFp,\n  Ue as postMessage,\n  P as postMessageImpl,\n  lt as request,\n  it as request2,\n  U as request2Fp,\n  Ge as requestFp,\n  st as resetGlobals,\n  tt as retrieveLaunchParams,\n  Me as retrieveLaunchParamsFp,\n  rt as retrieveRawInitData,\n  qe as retrieveRawInitDataFp,\n  nt as retrieveRawLaunchParams,\n  C as retrieveRawLaunchParamsFp,\n  ot as setDebug,\n  at as setTargetOrigin,\n  K as supports,\n  _e as targetOrigin\n};\n//# sourceMappingURL=index.js.map\n","import { type MethodName, supports } from '@tma.js/bridge';\nimport { type Computed, computed } from '@tma.js/signals';\nimport type { Version } from '@tma.js/types';\n\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport function createIsSupportedSignal(\n  method: MethodName,\n  version: MaybeAccessor<Version>,\n): Computed<boolean> {\n  return computed(() => supports(method, access(version)));\n}\n","import { throwifyFpFn, throwifyAnyEither, type AnyFn } from '@tma.js/toolkit';\nimport { function as fn, option as O } from 'fp-ts';\n\nimport type { WithChecksFp, WithChecks } from '@/with-checks/withChecksFp.js';\n\n// #__NO_SIDE_EFFECTS__\nexport function throwifyWithChecksFp<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsMapKeySchema extends string,\n>(\n  fn_: WithChecksFp<Fn, HasSupportCheck, SupportsMapKeySchema>,\n): WithChecks<Fn, HasSupportCheck, SupportsMapKeySchema> {\n  return Object.assign(throwifyFpFn(fn_), {\n    ifAvailable(...args: Parameters<Fn>) {\n      return fn.pipe(\n        fn_.ifAvailable(...args),\n        O.match(\n          () => ({ ok: false }),\n          data => ({\n            ok: true,\n            data: throwifyAnyEither(data),\n          }),\n        ),\n      );\n    },\n  }) as unknown as WithChecks<Fn, HasSupportCheck, SupportsMapKeySchema>;\n}\n","import { errorClass, errorClassWithData } from 'error-kid';\nimport type { BaseIssue } from 'valibot';\n\nfunction msgToTuple(message?: string): [string?] {\n  return [message];\n}\n\nexport class ValidationError extends /* #__PURE__ */ errorClassWithData<\n  { input: unknown; issues: BaseIssue<any>[] },\n  [input: unknown, issues: BaseIssue<any>[]]\n>(\n  'ValidationError',\n  (input, issues) => ({ input, issues }),\n  'Validation error',\n) {\n}\n\nexport class CSSVarsBoundError extends /* #__PURE__ */ errorClass(\n  'CSSVarsBoundError',\n  'CSS variables are already bound',\n) {\n}\n\nexport class DeviceStorageMethodError extends /* #__PURE__ */ errorClassWithData<\n  { error: string },\n  [error: string]\n>('DeviceStorageMethodError', error => ({ error }), error => [error]) {\n}\n\nexport class SecureStorageMethodError extends /* #__PURE__ */ errorClassWithData<\n  { error: string },\n  [error: string]\n>('SecureStorageMethodError', error => ({ error }), error => [error]) {\n}\n\nexport class NotAvailableError extends /* #__PURE__ */ errorClass<[message: string]>(\n  'NotAvailableError',\n  msgToTuple,\n) {\n}\n\nexport class InvalidEnvError extends /* #__PURE__ */ errorClass<[message?: string]>(\n  'InvalidEnvError',\n  msgToTuple,\n) {\n}\n\nexport class FunctionUnavailableError extends /* #__PURE__ */ errorClass<[message?: string]>(\n  'FunctionNotAvailableError',\n  msgToTuple,\n) {\n}\n\nexport class InvalidArgumentsError extends /* #__PURE__ */ errorClass<[message: string, cause?: unknown]>(\n  'InvalidArgumentsError',\n  (message, cause) => [message, { cause }],\n) {\n}\n\nexport class ConcurrentCallError extends /* #__PURE__ */ errorClass<[message: string]>(\n  'ConcurrentCallError',\n  msgToTuple,\n) {\n}\n\nexport class SetEmojiStatusError extends /* #__PURE__ */ errorClass<[error: string]>(\n  'SetEmojiStatusError',\n  error => [`Failed to set emoji status: ${error}`],\n) {\n}\n\nexport class AccessDeniedError extends /* #__PURE__ */ errorClass<[message: string]>(\n  'AccessDeniedError',\n  msgToTuple,\n) {\n}\n\nexport class FullscreenFailedError extends /* #__PURE__ */ errorClass<[message: string]>(\n  'FullscreenFailedError',\n  msgToTuple,\n) {\n}\n\nexport class ShareMessageError extends /* #__PURE__ */ errorClass<[error: string]>(\n  'ShareMessageError',\n  msgToTuple,\n) {\n}\n\nexport class UnknownThemeParamsKeyError extends /* #__PURE__ */ errorClass<[key: string]>(\n  'UnknownThemeParamsKeyError',\n  key => [`Unknown theme params key passed: ${key}`],\n) {\n}\n","import {\n  type MethodName,\n  supports,\n  type MethodNameWithVersionedParams,\n  type MethodVersionedParams,\n} from '@tma.js/bridge';\nimport { type Computed, computed } from '@tma.js/signals';\nimport type {\n  If,\n  IsNever,\n  AnyFnAnyEither,\n  RightOfReturn,\n  LeftOfReturn,\n  MaybeMonadReturnTypeToCommon,\n  MaybeCommonReturnTypeToMonad,\n  AnyFn,\n} from '@tma.js/toolkit';\nimport type { Version } from '@tma.js/types';\nimport { either as E, option as O, taskEither as TE } from 'fp-ts';\n\nimport { FunctionUnavailableError } from '@/errors.js';\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\n\ntype IfReturnsTask<Fn extends AnyFnAnyEither, A, B> =\n  ReturnType<Fn> extends TE.TaskEither<any, any> ? A : B;\n\ntype OptionsBasedRequires<O extends WithChecksOptions<any>> = O extends { requires: any }\n  ? true : false;\n\ntype OptionsBasedSupports<O extends WithChecksOptions<any>> = O extends { supports: any }\n  ? Extract<keyof O['supports'], string> : never;\n\ntype OptionsBasedFn<Opts extends WithChecksOptions<any>> = (...args: any[]) => (\n  Opts['returns'] extends 'plain'\n    ? any\n    : Opts['returns'] extends 'promise'\n      ? PromiseLike<any>\n      : Opts['returns'] extends 'task'\n        ? TE.TaskEither<any, any>\n        : E.Either<any, any>\n);\n\n/**\n * @returns Error text if something is wrong.\n */\nexport type CustomSupportFn = () => string | undefined;\n\nexport type Require =\n  | MethodName\n  | CustomSupportFn\n  | { every: (MethodName | CustomSupportFn)[] }\n  | { some: (MethodName | CustomSupportFn)[] };\n\n/**\n * A map where the key is a method name with versioned parameters, and the value is a tuple\n * containing the method and parameter names. The third tuple value is a function accepting\n * the wrapped function arguments and returning true if support check must be applied.\n */\nexport type SupportsMap<Args extends any[]> = {\n  [OptionName: string]: {\n    [M in MethodNameWithVersionedParams]: {\n      /**\n       * Method name.\n       * @example 'web_app_set_header_color'\n       */\n      method: M;\n      /**\n       * Method version-dependent parameter.\n       * @example `color`\n       */\n      param: MethodVersionedParams<M>;\n      /**\n       * @returns True if the support function should be called.\n       * @param args - function arguments.\n       */\n      shouldCheck: (...args: Args) => boolean;\n    };\n  }[MethodNameWithVersionedParams];\n};\n\ntype WrappedFnReturnType<Fn extends AnyFn> = ReturnType<Fn> extends E.Either<any, any>\n  ? E.Either<FunctionUnavailableError | LeftOfReturn<Fn>, RightOfReturn<Fn>>\n  : ReturnType<Fn> extends TE.TaskEither<any, any>\n    ? TE.TaskEither<FunctionUnavailableError | LeftOfReturn<Fn>, RightOfReturn<Fn>>\n    : ReturnType<Fn> extends PromiseLike<infer U>\n      ? TE.TaskEither<FunctionUnavailableError, U>\n      : E.Either<FunctionUnavailableError, ReturnType<Fn>>;\n\nexport type WrappedFn<Fn extends AnyFn> = (...args: Parameters<Fn>) => WrappedFnReturnType<Fn>;\n\nexport type WithChecksFp<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsMapKeySchema extends string = never,\n> =\n  & WrappedFn<Fn>\n  & {\n  /**\n   * A signal returning `true` if the function is available in the current environment and\n   * conditions.\n   *\n   * To be more accurate, the method checks the following:\n   * 1. The current environment is Telegram Mini Apps.\n   * 2. The SDK package is initialized (if this requirement is specified).\n   * 3. If passed, the `isSupported` signal returned true.\n   * 4. If passed, the `isMounted` signal returned true.\n   *\n   * *You should use this function when possible because it provides must-have code security\n   * mechanisms and makes a developer sure that he is using the package properly.*\n   *\n   * @returns True if the function is available in the current environment.\n   * @example\n   * if (backButton.show.isAvailable()) {\n   *   backButton.show();\n   * }\n   */\n    isAvailable: Computed<boolean>;\n    /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is available for call.\n   * @example\n   * backButton.show.ifAvailable();\n   */\n    ifAvailable(...args: Parameters<Fn>): O.Option<MaybeCommonReturnTypeToMonad<Fn>>;\n  }\n  & If<HasSupportCheck, {\n  /**\n   * The signal returning `true` if the function is supported by the Telegram client,\n   * including some possible additional conditions.\n   *\n   * It is highly recommended to use this signal only in certain narrow cases when only the\n   * function support check is required, but not its availability.\n   *\n   * This signal is not applying additional operations like checking if the current environment\n   * is Mini Apps and the SDK is initialized.\n   *\n   * To check if the function is available for use, use the `isAvailable` signal.\n   *\n   * @returns True if this function is supported.\n   * @see isAvailable\n   * @example\n   * if (backButton.show.isSupported()) {\n   *   console.log('The method is supported');\n   * }\n   */\n    isSupported: Computed<boolean>;\n  }, {}>\n  & If<IsNever<SupportsMapKeySchema>, {}, {\n  /**\n   * A map where the key is the function-specific option name and value is a signal indicating\n   * if it is supported by the current environment.\n   * @example\n   * if (miniApp.setHeaderColor.isAvailable()) {\n   *   if (miniApp.setHeaderColor.supports('rgb')) {\n   *     miniApp.setHeaderColor('#ffaabb');\n   *   } else {\n   *     miniApp.setHeaderColor('bg_color');\n   *   }\n   * }\n   */\n    supports: (key: SupportsMapKeySchema) => boolean;\n  }>;\n\nexport type WithChecks<\n  Fn extends AnyFn,\n  HasSupportCheck extends boolean,\n  SupportsMapKeySchema extends string = never,\n> =\n  & ((...args: Parameters<Fn>) => MaybeMonadReturnTypeToCommon<Fn>)\n  & Omit<WithChecksFp<Fn, HasSupportCheck, SupportsMapKeySchema>, 'ifAvailable'>\n  & {\n  /**\n   * Calls the function only in case it is available.\n   *\n   * It uses the `isAvailable` internally to check if the function is available for call.\n   * @example\n   * backButton.show.ifAvailable();\n   */\n    ifAvailable(...args: Parameters<Fn>):\n      | { ok: true; data: MaybeMonadReturnTypeToCommon<Fn> }\n      | { ok: false };\n  };\n\nexport interface WithChecksOptions<Fn extends AnyFn> {\n  /**\n   * Signal returning true if the owning component is mounted.\n   */\n  isMounted?: () => boolean;\n  /**\n   * Signal returning true if the owning component is mounting.\n   */\n  isMounting?: () => boolean;\n  /**\n   * A value determining the function requirements. This will enable additional checks for\n   * the function before being called.\n   */\n  requires?: Require;\n  /**\n   * A signal to retrieve the current Telegram Mini Apps version or the value itself.\n   */\n  isTma: MaybeAccessor<boolean>;\n  /**\n   * A map where the key is a method name with versioned parameters, and the value is a tuple\n   * containing the method and parameter names. The third tuple value is a function accepting\n   * the wrapped function arguments and returning true if support check must be applied.\n   */\n  supports?: SupportsMap<Parameters<Fn>>;\n  /**\n   * A signal to retrieve the current Telegram Mini Apps version or the value itself.\n   */\n  version?: MaybeAccessor<Version>;\n  /**\n   * Allows to determine what exactly should be returned from the function - TaskEither or Either.\n   * There is no other way to know it until the function itself is called, but we need to perform\n   * some checks before calling it and return a valid value based on the function return type.\n   */\n  returns: Fn extends AnyFnAnyEither\n    ? IfReturnsTask<Fn, 'task', 'either'>\n    : ReturnType<Fn> extends PromiseLike<any> ? 'promise' : 'plain';\n}\n\nexport function withChecksFp<Fn extends AnyFn, O extends WithChecksOptions<Fn>>(\n  fn: Fn,\n  options: O,\n): WithChecksFp<Fn, OptionsBasedRequires<O>, OptionsBasedSupports<O>> {\n  const version = computed(() => access(options.version) || '100');\n  const isTma = computed(() => access(options.isTma));\n\n  // Simplify the isSupported value to work with an array of validators or a single object.\n  const { requires: optionsIsSupported, returns } = options;\n  const isSupportedSimplified = optionsIsSupported\n    ? typeof optionsIsSupported === 'object'\n      ? optionsIsSupported\n      : { every: [optionsIsSupported] }\n    : undefined;\n\n  /**\n   * @param optionName - target option.\n   * @returns True if specified option is supported.\n   */\n  const isOptionSupported = (optionName: string): boolean => {\n    if (!options.supports) {\n      return true;\n    }\n    const optionSettings = options.supports[optionName];\n    return supports(optionSettings.method, optionSettings.param, version());\n  };\n\n  /**\n   * @returns All found errors according to the isSupported variable value.\n   */\n  const calculateSupportError = (): string | undefined => {\n    // isSupported was not specified. In this case, we assume that the function has no\n    // dependencies and is always supported.\n    if (!isSupportedSimplified) {\n      return;\n    }\n    const [mode, requirements] = 'every' in isSupportedSimplified\n      ? ['every', isSupportedSimplified.every] as const\n      : ['some', isSupportedSimplified.some] as const;\n\n    for (let i = 0; i < requirements.length; i++) {\n      const requirement = requirements[i];\n      const error = typeof requirement === 'function'\n        ? requirement()\n        : supports(requirement, version())\n          ? undefined\n          : `it is unsupported in Mini Apps version ${version()}`;\n      // Return only if there was an error and all requirements must be satisfied, or\n      // this was the last one requirement (when some of the requirements must be met).\n      if (error && (mode === 'every' || i === requirements.length - 1)) {\n        return error;\n      }\n    }\n  };\n\n  /**\n   * @returns An error related to supports.<name> check.\n   */\n  const calculateOptionSupportError = (\n    ...args: Parameters<Fn>\n  ): string | undefined => {\n    for (const k in options.supports) {\n      if (options.supports[k].shouldCheck(...args) && !isOptionSupported(k)) {\n        return `option ${k} is not supported in Mini Apps version ${version()}`;\n      }\n    }\n  };\n\n  const isSupported = computed(() => !calculateSupportError());\n  const isInitialized = computed(() => version() !== '0.0');\n  const isMounted = computed(() => (options.isMounted ? options.isMounted() : true));\n  const isAvailable = computed(\n    () => isTma()\n      && isInitialized()\n      && isSupported()\n      && isMounted(),\n  );\n\n  const wrapError = (message: string): WrappedFnReturnType<Fn> => {\n    const err = new FunctionUnavailableError(message);\n    return (['task', 'promise'].includes(options.returns)\n      ? TE.left(err)\n      : E.left(err)) as WrappedFnReturnType<Fn>;\n  };\n\n  const call = (...args: Parameters<Fn>): MaybeCommonReturnTypeToMonad<Fn> => {\n    if (returns === 'plain') {\n      return E.tryCatch(() => fn(...args), e => e) as MaybeCommonReturnTypeToMonad<Fn>;\n    }\n    if (returns === 'promise') {\n      return TE.tryCatch(() => fn(...args), e => e) as MaybeCommonReturnTypeToMonad<Fn>;\n    }\n    return fn(...args);\n  };\n\n  return Object.assign(\n    (...args: Parameters<Fn>): WrappedFnReturnType<Fn> => {\n      const errMessagePrefix = 'Unable to call function:';\n      if (!isTma()) {\n        return wrapError(`${errMessagePrefix} it can't be called outside Mini Apps`);\n      }\n      if (!isInitialized()) {\n        return wrapError(`${errMessagePrefix} the SDK was not initialized. Use the SDK init() function`);\n      }\n      const supportErr = calculateSupportError();\n      if (supportErr) {\n        return wrapError(`${errMessagePrefix} ${supportErr}`);\n      }\n      const supportsOptionErr = calculateOptionSupportError(...args);\n      if (supportsOptionErr) {\n        return wrapError(`${errMessagePrefix} ${supportsOptionErr}`);\n      }\n      if (!isMounted()) {\n        const message = options.isMounting?.()\n          ? 'mounting. Wait for the mount completion'\n          : 'unmounted. Use the mount() method';\n        return wrapError(`${errMessagePrefix} the component is ${message}`);\n      }\n      return call(...args) as WrappedFnReturnType<Fn>;\n    },\n    fn,\n    {\n      isAvailable,\n      ifAvailable(...args: Parameters<Fn>): O.Option<MaybeCommonReturnTypeToMonad<Fn>> {\n        return isAvailable() ? O.some(call(...args)) : O.none;\n      },\n    },\n    isSupportedSimplified ? { isSupported } : {},\n    options.supports ? { supports: isOptionSupported } : {},\n  );\n}\n\nexport function createWithChecksFp<O extends WithChecksOptions<any>>(options: O) {\n  return <Fn extends OptionsBasedFn<O>>(fn: Fn): WithChecksFp<\n    Fn,\n    OptionsBasedRequires<O>,\n    OptionsBasedSupports<O>\n  > => withChecksFp(fn, options);\n}\n","import type { PostEventError, MethodName, MethodParams } from '@tma.js/bridge';\nimport { computed, type Computed } from '@tma.js/signals';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { removeUndefined } from '@/helpers/removeUndefined.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  type WithChecksFp,\n  type WithChecks,\n  createWithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\ntype ButtonEither = E.Either<PostEventError, void>;\n\ntype BoolFields<S> = {\n  [K in keyof S]-?: S[K] extends boolean ? K : never;\n}[keyof S];\n\nexport interface ButtonOptions<S, M extends MethodName>\n  extends SharedFeatureOptions,\n  WithStateRestore<S>,\n  WithPostEvent,\n  WithVersion {\n  /**\n   * The initial button state.\n   */\n  initialState: S;\n  /**\n   * Removes a component click listener.\n   * @param listener - a listener to remove.\n   * @param once - should the listener be called only once.\n   */\n  offClick: (listener: VoidFunction, once?: boolean) => void;\n  /**\n   * Adds a component click listener.\n   * @returns A function to remove listener.\n   * @param listener - a listener to add.\n   * @param once - should the listener be called only once.\n   */\n  onClick: (listener: VoidFunction, once?: boolean) => VoidFunction;\n  /**\n   * A Mini Apps method to commit changes.\n   */\n  method: M;\n  /**\n   * A function to create method payload.\n   * @param state\n   */\n  payload: (state: S) => MethodParams<M>;\n}\n\nexport class Button<S extends object, M extends MethodName> {\n  constructor({\n    isTma,\n    storage,\n    onClick,\n    offClick,\n    initialState,\n    isPageReload,\n    postEvent,\n    payload,\n    method,\n    version,\n  }: ButtonOptions<S, M>) {\n    const stateful = new Stateful({\n      initialState,\n      onChange(state) {\n        storage.set(state);\n      },\n    });\n    const mountable = new Mountable<S>({\n      initialState,\n      isPageReload,\n      onMounted: stateful.setState,\n      restoreState: storage.get,\n    });\n\n    const wrapOptions = { version, requires: method, isTma };\n    const wrapSupportedPlain = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'plain',\n    });\n    const wrapMountedEither = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'either',\n      isMounted: mountable.isMounted,\n    });\n\n    this.isMounted = mountable.isMounted;\n    this.isSupported = createIsSupportedSignal(method, version);\n    this.state = stateful.state;\n\n    this.setStateFp = wrapMountedEither(state => {\n      const nextState = { ...this.state(), ...removeUndefined(state) };\n      if (!stateful.hasDiff(nextState)) {\n        return E.right(undefined);\n      }\n      return fn.pipe(\n        postEvent(method as any, payload(nextState)),\n        E.map(() => {\n          stateful.setState(nextState);\n        }),\n      );\n    });\n    this.setState = throwifyWithChecksFp(this.setStateFp);\n    this.onClickFp = wrapSupportedPlain(onClick);\n    this.onClick = throwifyWithChecksFp(this.onClickFp);\n    this.offClickFp = wrapSupportedPlain(offClick);\n    this.offClick = throwifyWithChecksFp(this.offClickFp);\n    this.mountFp = wrapSupportedPlain(() => {\n      const nothing = () => undefined;\n      return fn.pipe(mountable.mount(), E.match(nothing, nothing));\n    });\n    this.mount = throwifyWithChecksFp(this.mountFp);\n    this.unmount = mountable.unmount;\n    this.stateSetters = key => {\n      const wrapped = wrapMountedEither(value => {\n        return this.setStateFp({ [key]: value } as unknown as Partial<S>);\n      });\n      return [throwifyWithChecksFp(wrapped), wrapped];\n    };\n    this.stateBoolSetters = <K extends keyof S>(key: K) => {\n      const [, setFp] = this.stateSetters(key);\n      const setFalse = wrapMountedEither(() => setFp(false as S[K]));\n      const setTrue = wrapMountedEither(() => setFp(true as S[K]));\n      return [\n        [throwifyWithChecksFp(setFalse), setFalse],\n        [throwifyWithChecksFp(setTrue), setTrue],\n      ];\n    };\n  }\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Complete button state.\n   */\n  readonly state: Computed<S>;\n\n  /**\n   * @returns A computed based on the specified state and its related key.\n   * @param key - a key to use.\n   */\n  stateGetter<K extends keyof S>(key: K): Computed<S[K]> {\n    return computed(() => this.state()[key]);\n  }\n\n  /**\n   * @returns A setter with checks for the specified key.\n   * @param key\n   */\n  readonly stateSetters: <K extends keyof S>(key: K) => [\n    throwing: WithChecks<(value: S[K]) => void, true>,\n    fp: WithChecksFp<(value: S[K]) => ButtonEither, true>,\n  ];\n\n  /**\n   * @returns Setters with checks to set a specified boolean key.\n   * @param key\n   */\n  readonly stateBoolSetters: <K extends BoolFields<S>>(key: K) => [\n    setFalse: [\n      throwing: WithChecks<() => void, true>,\n      fp: WithChecksFp<() => ButtonEither, true>,\n    ],\n    setTrue: [\n      throwing: WithChecks<() => void, true>,\n      fp: WithChecksFp<() => ButtonEither, true>,\n    ],\n  ];\n\n  /**\n   * Updates the button state.\n   */\n  readonly setStateFp: WithChecksFp<(state: Partial<S>) => ButtonEither, true>;\n\n  /**\n   * @see setStateFp\n   */\n  readonly setState: WithChecks<(state: Partial<S>) => void, true>;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * @see onClickFp\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => void,\n    true\n  >;\n\n  /**\n   * @see offClickFp\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, true>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v6.1\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   *\n   * Note that this function does not remove listeners added via the `onClick`\n   * function, so you have to remove them on your own.\n   * @see onClick\n   */\n  readonly unmount: () => void;\n}\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { either as E } from 'fp-ts';\n\nimport { Button, type ButtonOptions } from '@/composables/Button.js';\nimport type { WithChecksFp, WithChecks } from '@/with-checks/withChecksFp.js';\n\nexport interface BackButtonState {\n  isVisible: boolean;\n}\n\nexport type BackButtonOptions = Omit<\n  ButtonOptions<BackButtonState, 'web_app_setup_back_button'>,\n  'method' | 'payload' | 'initialState'\n>;\n\n/**\n * @since Mini Apps v6.1\n */\nexport class BackButton {\n  constructor(options: BackButtonOptions) {\n    const button = new Button({\n      ...options,\n      method: 'web_app_setup_back_button',\n      payload: state => ({ is_visible: state.isVisible }),\n      initialState: { isVisible: false },\n    });\n\n    this.isVisible = button.stateGetter('isVisible');\n    this.isMounted = button.isMounted;\n    this.isSupported = button.isSupported;\n    [[this.hide, this.hideFp], [this.show, this.showFp]] = button.stateBoolSetters('isVisible');\n    this.onClick = button.onClick;\n    this.onClickFp = button.onClickFp;\n    this.offClick = button.offClick;\n    this.offClickFp = button.offClickFp;\n    this.mount = button.mount;\n    this.mountFp = button.mountFp;\n    this.unmount = button.unmount;\n  }\n\n  /**\n   * Signal indicating if the component is currently visible.\n   */\n  readonly isVisible: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Hides the button.\n   * @since Mini Apps v6.1\n   */\n  readonly hideFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see hideFp\n   */\n  readonly hide: WithChecks<() => void, true>;\n\n  /**\n   * Shows the button.\n   * @since Mini Apps v6.1\n   */\n  readonly showFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<() => void, true>;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @since Mini Apps v6.1\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => VoidFunction,\n    true\n  >;\n\n  /**\n   * @see onClickFp\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @since Mini Apps v6.1\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => void,\n    true\n  >;\n\n  /**\n   * @see offClickFp\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, true>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v6.1\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   *\n   * Note that this function does not remove listeners added via the `onClick`\n   * function, so you have to remove them on your own.\n   * @see onClick\n   */\n  readonly unmount: () => void;\n}\n","import { isTMAFp } from '@tma.js/bridge';\nimport { computed } from '@tma.js/signals';\n\nimport type { MaybeAccessor } from '@/types.js';\n\nexport interface SharedFeatureOptions {\n  /**\n   * True if the current environment is Telegram Mini Apps.\n   */\n  isTma: MaybeAccessor<boolean>;\n}\n\nexport function sharedFeatureOptions(): SharedFeatureOptions {\n  return { isTma: computed(() => isTMAFp()) };\n}\n","import { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport function createFnOption<T>(mix: MaybeAccessor<T>) {\n  return <O extends object>(obj: O) => {\n    return { ...obj, ...access(mix) };\n  };\n}\n","import {\n  computed,\n  type Computed,\n  type Signal,\n  signal,\n  type SignalOptions,\n} from '@tma.js/signals';\n\nexport type SignalsTuple<T> = [Signal<T>, Computed<T>];\n\nconst signals: (Signal<any> | Computed<any>)[] = [];\n\n/**\n * Creates a new signal with the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): Signal<T>;\n\n/**\n * Creates a new signal without the initial value.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignal<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): Signal<T | undefined> {\n  const s = signal(initialValue, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Creates a signal, which wil be automatically updated if some of its dependant signals were\n * modified.\n * @param fn - computation function.\n * @param options - additional functions.\n */\n// #__NO_SIDE_EFFECTS__\nexport function createComputed<T>(fn: (prev?: T) => T, options?: SignalOptions<T>): Computed<T> {\n  const s = computed(fn, options);\n  signals.push(s);\n  return s;\n}\n\n/**\n * Resets all signals states.\n */\nexport function resetSignals() {\n  signals.forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - the initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue: T,\n  options?: SignalOptions<T>,\n): SignalsTuple<T>;\n\n/**\n * @returns A tuple, containing a manual and computed signals. The computed signal is based on\n * the manual one.\n * @param initialValue - an initial value.\n * @param options - additional options.\n */\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined>;\n\n// #__NO_SIDE_EFFECTS__\nexport function createSignalsTuple<T>(\n  initialValue?: T,\n  options?: SignalOptions<T | undefined>,\n): SignalsTuple<T | undefined> {\n  const s = createSignal(initialValue, options);\n  return [s, createComputed(s)];\n}\n","import { postEventFp as _postEventFp, type PostEventFpFn, type PostEventFn } from '@tma.js/bridge';\nimport { throwifyAnyEither } from '@tma.js/toolkit';\n\nimport { createSignal } from '@/globals/signals-registry.js';\n\nexport const postEventFpSignal = createSignal(_postEventFp);\n\nexport const postEventFp: PostEventFpFn = (...args: any[]) => {\n  return (postEventFpSignal as any)()(...args);\n};\n\nexport const postEvent: PostEventFn = (...args: any[]) => {\n  return throwifyAnyEither((postEventFp as any)(...args));\n};\n","import { type PostEventFpFn } from '@tma.js/bridge';\n\nimport { createFnOption } from '@/fn-options/createFnOption.js';\nimport { postEventFp } from '@/globals/postEvent.js';\n\nexport interface WithPostEvent {\n  /**\n   * A postEvent function to use to call Mini Apps methods.\n   */\n  postEvent: PostEventFpFn;\n}\n\nexport const withPostEvent = createFnOption<WithPostEvent>({\n  postEvent: postEventFp,\n});\n","import { getStorageValue, setStorageValue } from '@tma.js/toolkit';\n\nexport interface ComponentStorage<T> {\n  get: () => T | undefined;\n  set: (value: T) => void;\n}\n\n/**\n * Creates a new sessionStorage-based component storage.\n * @param key - session storage key to use.\n */\nexport function createComponentSessionStorage<T>(key: string): ComponentStorage<T> {\n  return {\n    get: () => getStorageValue<T>(key),\n    set(value) {\n      setStorageValue<T>(key, value);\n    },\n  };\n}\n","/**\n * Returns the first navigation entry from window.performance.\n * @returns First navigation entry or null, in case performance functionality is not supported\n * or navigation entry was not found.\n */\nfunction getFirstNavigationEntry(): PerformanceNavigationTiming | undefined {\n  return performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined;\n}\n\n/**\n * @returns True, if the current page was reloaded.\n * @see https://stackoverflow.com/a/36444134/11894710\n */\nexport function isPageReload(): boolean {\n  const entry = getFirstNavigationEntry();\n  return !!entry && entry.type === 'reload';\n}\n","import { createFnOption } from '@/fn-options/createFnOption.js';\nimport { type ComponentStorage, createComponentSessionStorage } from '@/helpers/component-storage.js';\nimport { isPageReload } from '@/helpers/navigation.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport interface WithStateRestore<T> {\n  /**\n   * A storage the component could use to store its data.\n   */\n  storage: ComponentStorage<T>;\n  /**\n   * True if the current page is reloaded.\n   */\n  isPageReload: MaybeAccessor<boolean>;\n}\n\nexport function withStateRestore<S>(storageName: string) {\n  return createFnOption<WithStateRestore<S>>({\n    storage: createComponentSessionStorage<S>(storageName),\n    isPageReload,\n  });\n}\n","import type { Version } from '@tma.js/types';\n\nimport { createSignal } from '@/globals/signals-registry.js';\n\n/**\n * The current Mini Apps version.\n */\nexport const version = createSignal<Version>('0.0');\n","import type { Version } from '@tma.js/types';\n\nimport { createFnOption } from '@/fn-options/createFnOption.js';\nimport { version } from '@/globals/version.js';\nimport type { MaybeAccessor } from '@/types.js';\n\nexport interface WithVersion {\n  /**\n   * The currently supported Telegram Mini Apps version by the Telegram client.\n   */\n  version: MaybeAccessor<Version>;\n}\n\nexport const withVersion = createFnOption<WithVersion>({ version });\n","import { on, off, type EventName } from '@tma.js/bridge';\nimport { function as fn } from 'fp-ts';\n\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\n// @__NO_SIDE_EFFECTS__\nexport function buttonOptions<S>(storageName: string, trackedClickEvent: EventName) {\n  return {\n    ...fn.pipe(\n      sharedFeatureOptions(),\n      withPostEvent,\n      withVersion,\n      withStateRestore<S>(storageName),\n    ),\n    onClick(listener: VoidFunction, once?: boolean): VoidFunction {\n      return on(trackedClickEvent, listener, once);\n    },\n    offClick(listener: VoidFunction, once?: boolean): void {\n      off(trackedClickEvent, listener, once);\n    },\n  };\n}\n","import { BackButton } from '@/features/BackButton/BackButton.js';\nimport { buttonOptions } from '@/fn-options/buttonOptions.js';\n\nexport const backButton = /* @__PURE__*/ new BackButton(\n  buttonOptions('backButton', 'back_button_pressed'),\n);\n","import { batch, computed, signal } from '@tma.js/signals';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport { access } from '@/helpers/access.js';\nimport type { AsyncOptions, MaybeAccessor } from '@/types.js';\n\nexport interface AsyncMountableOptions<S, E> {\n  /**\n   * A function to retrieve the initial state.\n   * @param options - additional options.\n   */\n  initialState: (options?: AsyncOptions) => TE.TaskEither<E, S>;\n  /**\n   * @returns True if the current page was reloaded.\n   */\n  isPageReload: MaybeAccessor<boolean>;\n  /**\n   * A function to call whenever the component was mounted.\n   * @param state - restored state.\n   */\n  onMounted?: (state: S) => void;\n  /**\n   * A function to call whenever the component was unmounted.\n   */\n  onUnmounted?: VoidFunction;\n  /**\n   * Attempts to restore previously saved component state. This function\n   * will only be called if the current page was reloaded.\n   */\n  restoreState: () => (S | undefined);\n}\n\nexport class AsyncMountable<S extends object, E> {\n  constructor({\n    initialState,\n    onMounted,\n    restoreState,\n    onUnmounted,\n    isPageReload,\n  }: AsyncMountableOptions<S, E>) {\n    this.mount = options => {\n      if (this._isMounted()) {\n        return TE.right(undefined);\n      }\n      const restored = access(isPageReload) ? restoreState() : undefined;\n      return fn.pipe(\n        restored ? TE.right(restored) : initialState(options),\n        TE.map(state => {\n          // The user could call mount several times in a row while the\n          // component was still mounting. We should prevent calling the\n          // same hooks several times in this case.\n          if (!this._isMounted()) {\n            batch(() => {\n              this._isMounted.set(true);\n              onMounted?.(state);\n            });\n          }\n        }),\n      );\n    };\n\n    this.unmount = () => {\n      if (this._isMounted()) {\n        batch(() => {\n          this._isMounted.set(false);\n          onUnmounted?.();\n        });\n      }\n    };\n  }\n\n  private readonly _isMounted = signal(false);\n\n  /**\n   * Signal indicating if the component is mounted.\n   */\n  readonly isMounted = computed(this._isMounted);\n\n  /**\n   * Mounts the component restoring its state and calling required side effects.\n   * @param options - additional execution options.\n   */\n  readonly mount: (options?: AsyncOptions) => TE.TaskEither<E, void>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n}\n","import type {\n  RequestError,\n  PostEventError,\n  EventPayload,\n  BiometryAuthRequestStatus,\n  EventListener,\n  BiometryTokenUpdateStatus,\n} from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { BetterPromise } from 'better-promises';\nimport { either as E, taskEither as TE, function as fn } from 'fp-ts';\n\nimport { AsyncMountable } from '@/composables/AsyncMountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport { NotAvailableError } from '@/errors.js';\nimport type {\n  BiometryAuthenticateOptions, BiometryOptions,\n  BiometryRequestAccessOptions,\n  BiometryState,\n  BiometryUpdateTokenOptions,\n} from '@/features/Biometry/types.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, WithChecks, WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype BiometryTask<T> = TE.TaskEither<RequestError, T>;\n\ninterface AuthenticateResult {\n  /**\n   * Authentication status.\n   */\n  status: BiometryAuthRequestStatus;\n  /**\n   * Token from the local secure storage saved previously.\n   */\n  token?: string;\n}\n\nfunction createNotAvailableError() {\n  return new NotAvailableError('Biometry is not available');\n}\n\nfunction eventToState(event: EventPayload<'biometry_info_received'>): BiometryState {\n  let available = false;\n  let tokenSaved = false;\n  let deviceId = '';\n  let accessRequested = false;\n  let type = '';\n  let accessGranted = false;\n  if (event.available) {\n    available = true;\n    tokenSaved = event.token_saved;\n    deviceId = event.device_id;\n    accessRequested = event.access_requested;\n    type = event.type;\n    accessGranted = event.access_granted;\n  }\n  return { available, tokenSaved, deviceId, type, accessGranted, accessRequested };\n}\n\n/**\n * @since Mini Apps v7.2\n */\nexport class Biometry {\n  constructor({\n    version,\n    request,\n    postEvent,\n    storage,\n    onInfoReceived,\n    offInfoReceived,\n    isTma,\n    isPageReload,\n  }: BiometryOptions) {\n    const listener: EventListener<'biometry_info_received'> = event => {\n      stateful.setState(eventToState(event));\n    };\n\n    const stateful = new Stateful<BiometryState>({\n      initialState: {\n        available: false,\n        type: 'unknown',\n        accessGranted: false,\n        accessRequested: false,\n        deviceId: '',\n        tokenSaved: false,\n      },\n      onChange: storage.set,\n    });\n    const mountable = new AsyncMountable({\n      initialState(options) {\n        return fn.pipe(\n          request('web_app_biometry_get_info', 'biometry_info_received', options),\n          TE.map(eventToState),\n        );\n      },\n      isPageReload,\n      onMounted(state) {\n        stateful.setState(state);\n        onInfoReceived(listener);\n      },\n      onUnmounted() {\n        offInfoReceived(listener);\n      },\n      restoreState: storage.get,\n    });\n\n    const wrapOptions = { version, requires: 'web_app_biometry_request_auth', isTma } as const;\n    const wrapSupportedEither = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'either',\n    });\n    const wrapSupportedTask = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'task',\n    });\n    const wrapMountedTask = createWithChecksFp({\n      ...wrapOptions,\n      isMounted: mountable.isMounted,\n      returns: 'task',\n    });\n\n    this.isAvailable = stateful.getter('available');\n    this.isMounted = mountable.isMounted;\n    this.isSupported = createIsSupportedSignal('web_app_biometry_request_auth', version);\n    this.state = stateful.state;\n    this.unmount = mountable.unmount;\n    this.mountFp = wrapSupportedTask(mountable.mount);\n\n    this.authenticateFp = wrapMountedTask(options => {\n      return !this.isAvailable()\n        ? TE.left(createNotAvailableError())\n        : fn.pipe(\n          request('web_app_biometry_request_auth', 'biometry_auth_requested', {\n            ...options,\n            params: { reason: ((options || {}).reason || '').trim() },\n          }),\n          TE.map(response => {\n            stateful.setState({ token: response.token });\n            return response;\n          }),\n        );\n    });\n\n    this.openSettingsFp = wrapSupportedEither(() => postEvent('web_app_biometry_open_settings'));\n\n    this.requestAccessFp = wrapMountedTask(options => {\n      return fn.pipe(\n        request('web_app_biometry_request_access', 'biometry_info_received', {\n          ...options,\n          params: { reason: ((options || {}).reason || '').trim() },\n        }),\n        TE.chain(response => {\n          const state = eventToState(response);\n          if (!state.available) {\n            return TE.left(createNotAvailableError());\n          }\n          stateful.setState(state);\n          return TE.right(state.accessRequested);\n        }),\n      );\n    });\n\n    this.updateTokenFp = wrapMountedTask((options = {}) => {\n      return fn.pipe(\n        request('web_app_biometry_update_token', 'biometry_token_updated', {\n          ...options,\n          params: { token: options.token || '', reason: options.reason?.trim() },\n        }),\n        TE.map(response => response.status),\n      );\n    });\n\n    this.authenticate = throwifyWithChecksFp(this.authenticateFp);\n    this.openSettings = throwifyWithChecksFp(this.openSettingsFp);\n    this.requestAccess = throwifyWithChecksFp(this.requestAccessFp);\n    this.updateToken = throwifyWithChecksFp(this.updateTokenFp);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n  }\n\n  /**\n   * Signal indicating if biometry is available.\n   */\n  readonly isAvailable: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Complete component state.\n   */\n  readonly state: Computed<BiometryState>;\n\n  /**\n   * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.\n   * @param options - method options.\n   * @since Mini Apps v7.2\n   * @returns Token from the local secure storage saved previously or undefined.\n   * @example\n   * const { status, token } = await biometry.authenticate({\n   *   reason: 'Authenticate to open wallet',\n   * });\n   */\n  readonly authenticateFp: WithChecksFp<(options?: BiometryAuthenticateOptions) => BiometryTask<{\n    /**\n     * Authentication status.\n     */\n    status: BiometryAuthRequestStatus;\n    /**\n     * Token from the local secure storage saved previously.\n     */\n    token?: string;\n  }>, true>;\n\n  /**\n   * @see authenticateFp\n   */\n  readonly authenticate: WithChecks<\n    (options?: BiometryAuthenticateOptions) => BetterPromise<AuthenticateResult>,\n    true\n  >;\n\n  /**\n   * Opens the biometric access settings for bots. Useful when you need to request biometrics\n   * access to users who haven't granted it yet.\n   *\n   * _Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g. a click inside the Mini App or on the main button)_.\n   * @since Mini Apps v7.2\n   */\n  readonly openSettingsFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see openSettingsFp\n   */\n  readonly openSettings: WithChecks<() => void, true>;\n\n  /**\n   * Requests permission to use biometrics.\n   * @since Mini Apps v7.2\n   * @returns Promise with true, if access was granted.\n   * @example\n   * const accessGranted = await biometry.requestAccess({\n   *   reason: 'Authenticate to open wallet',\n   * });\n   */\n  readonly requestAccessFp: WithChecksFp<\n    (options?: BiometryRequestAccessOptions) => BiometryTask<boolean>,\n    true\n  >;\n\n  /**\n   * @see requestAccessFp\n   */\n  readonly requestAccess: WithChecks<\n    (options?: BiometryRequestAccessOptions) => BetterPromise<boolean>,\n    true\n  >;\n\n  /**\n   * Updates the biometric token in a secure storage on the device.\n   * @since Mini Apps v7.2\n   * @returns Promise with `true`, if token was updated.\n   * @example Setting a new token\n   * biometry.updateToken({\n   *   token: 'abcdef',\n   * })\n   * @example Deleting the token\n   * biometry.updateToken();\n   */\n  readonly updateTokenFp: WithChecksFp<\n    (options?: BiometryUpdateTokenOptions) => BiometryTask<BiometryTokenUpdateStatus>,\n    true\n  >;\n\n  /**\n   * @see updateTokenFp\n   */\n  readonly updateToken: WithChecks<\n    (options?: BiometryUpdateTokenOptions) => BetterPromise<BiometryTokenUpdateStatus>,\n    true\n  >;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v7.2\n   */\n  readonly mountFp: WithChecksFp<(options?: AsyncOptions) => BiometryTask<void>, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, true>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n}\n","import {\n  requestFp as _requestFp,\n  request2Fp as _request2Fp,\n  type RequestFpFn,\n  type RequestFn,\n  type Request2FpFn,\n  type Request2Fn,\n} from '@tma.js/bridge';\nimport { BetterPromise } from 'better-promises';\n\nimport { postEventFp } from '@/globals/postEvent.js';\n\n/**\n * @deprecated To be removed in the next major update. Use `request2fp` instead, it provides\n * a proper way of handling multiple events.\n */\nexport const requestFp: RequestFpFn = (method: any, events: any, options: any) => {\n  return _requestFp(method, events, {\n    postEvent: postEventFp,\n    ...options,\n  });\n};\n\nexport const request2Fp: Request2FpFn = (method: any, events: any, options: any) => {\n  return _request2Fp(method, events, {\n    postEvent: postEventFp,\n    ...options,\n  });\n};\n\n/**\n * @deprecated To be removed in the next major update. Use `request` instead, it provides\n * a proper way of handling multiple events.\n */\nexport const request: RequestFn = (...args: any[]) => {\n  return BetterPromise.fn(() => (requestFp as any)(...args)());\n};\n\nexport const request2: Request2Fn = (...args: any[]) => {\n  return BetterPromise.fn(() => (request2Fp as any)(...args)());\n};\n","import type { Request2FpFn } from '@tma.js/bridge';\n\nimport { createFnOption } from '@/fn-options/createFnOption.js';\nimport { request2Fp } from '@/globals/request.js';\n\nexport interface WithRequest {\n  /**\n   * A request function to use to call Mini Apps methods.\n   */\n  request: Request2FpFn;\n}\n\nexport const withRequest = createFnOption<WithRequest>({ request: request2Fp });\n","import { on, off } from '@tma.js/bridge';\nimport { function as fn } from 'fp-ts';\n\nimport { Biometry } from '@/features/Biometry/Biometry.js';\nimport type { BiometryState } from '@/features/Biometry/types.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new Biometry({\n    ...fn.pipe(\n      sharedFeatureOptions(),\n      withPostEvent,\n      withVersion,\n      withRequest,\n      withStateRestore<BiometryState>('biometry'),\n    ),\n    offInfoReceived(listener) {\n      off('biometry_info_received', listener);\n    },\n    onInfoReceived(listener) {\n      return on('biometry_info_received', listener);\n    },\n  });\n}\n\nexport const biometry = /* @__PURE__*/ instantiate();\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport interface ClosingBehaviorState {\n  isConfirmationEnabled: boolean;\n}\n\nexport interface ClosingBehaviorOptions\n  extends WithStateRestore<ClosingBehaviorState>,\n  WithPostEvent,\n  SharedFeatureOptions {\n}\n\nexport class ClosingBehavior {\n  constructor({ postEvent, storage, isTma, isPageReload }: ClosingBehaviorOptions) {\n    const stateful = new Stateful({\n      initialState: { isConfirmationEnabled: false },\n      onChange(state) {\n        storage.set(state);\n      },\n    });\n    const mountable = new Mountable({\n      onMounted: stateful.setState,\n      restoreState: storage.get,\n      initialState: { isConfirmationEnabled: false },\n      isPageReload,\n    });\n\n    const wrapOptions = { requires: 'web_app_setup_closing_behavior', isTma } as const;\n    const wrapSupportedPlain = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'plain',\n    });\n    const wrapMountedEither = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'either',\n      isMounted: mountable.isMounted,\n    });\n\n    const setClosingConfirmation = (isConfirmationEnabled: boolean) => {\n      if (isConfirmationEnabled === this.isConfirmationEnabled()) {\n        return E.right(undefined);\n      }\n      stateful.setState({ isConfirmationEnabled });\n      return postEvent('web_app_setup_closing_behavior', {\n        need_confirmation: isConfirmationEnabled,\n      });\n    };\n\n    this.isConfirmationEnabled = stateful.getter('isConfirmationEnabled');\n    this.isMounted = mountable.isMounted;\n\n    this.disableConfirmationFp = wrapMountedEither(() => {\n      return setClosingConfirmation(false);\n    });\n    this.enableConfirmationFp = wrapMountedEither(() => {\n      return setClosingConfirmation(true);\n    });\n    this.mountFp = wrapSupportedPlain(() => {\n      const nothing = () => undefined;\n      return fn.pipe(mountable.mount(), E.match(nothing, nothing));\n    });\n    this.unmount = mountable.unmount;\n\n    this.disableConfirmation = throwifyWithChecksFp(this.disableConfirmationFp);\n    this.enableConfirmation = throwifyWithChecksFp(this.enableConfirmationFp);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n  }\n\n  /**\n   * Signal indicating if closing confirmation dialog is currently enabled.\n   */\n  readonly isConfirmationEnabled: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component restoring its state.\n   */\n  readonly mountFp: WithChecksFp<() => void, false>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, false>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n\n  /**\n   * Disables the closing confirmation dialog.\n   */\n  readonly disableConfirmationFp: WithChecksFp<() => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see disableConfirmationFp\n   */\n  readonly disableConfirmation: WithChecks<() => void, false>;\n\n  /**\n   * Enables the closing confirmation dialog.\n   */\n  readonly enableConfirmationFp: WithChecksFp<() => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see enableConfirmationFp\n   */\n  readonly enableConfirmation: WithChecks<() => void, false>;\n}\n","import { function as fn } from 'fp-ts';\n\nimport {\n  ClosingBehavior,\n  type ClosingBehaviorState,\n} from '@/features/ClosingBehavior/ClosingBehavior.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\n\nfunction instantiate() {\n  return new ClosingBehavior(fn.pipe(\n    sharedFeatureOptions(),\n    withStateRestore<ClosingBehaviorState>('closingBehavior'),\n    withPostEvent,\n  ));\n}\n\nexport const closingBehavior = /* @__PURE__*/ instantiate();\n","import type { InvokeCustomMethodFpOptions, RequestError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { BetterPromise } from 'better-promises';\nimport { taskEither as TE, function as fn } from 'fp-ts';\nimport { array, parse, record, string } from 'valibot';\n\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithInvokeCustomMethod } from '@/fn-options/withInvokeCustomMethod.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecks, type WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype CloudStorageTask<T> = TE.TaskEither<RequestError, T>;\n\nexport interface CloudStorageOptions extends WithVersion,\n  WithInvokeCustomMethod,\n  SharedFeatureOptions {\n}\n\n/**\n * @since Mini Apps v6.9\n */\nexport class CloudStorage {\n  constructor({ version, isTma, invokeCustomMethod }: CloudStorageOptions) {\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      requires: 'web_app_invoke_custom_method',\n      isTma,\n      returns: 'task',\n    });\n\n    this.isSupported = createIsSupportedSignal('web_app_invoke_custom_method', version);\n    this.deleteItemFp = wrapSupportedTask((keyOrKeys, options) => {\n      const keys = Array.isArray(keyOrKeys) ? keyOrKeys : [keyOrKeys];\n      return fn.pipe(\n        keys.length\n          ? invokeCustomMethod('deleteStorageValues', { keys }, options)\n          : TE.right(undefined),\n        TE.map(() => undefined),\n      );\n    });\n    this.getItemFp = wrapSupportedTask((key, options) => {\n      return fn.pipe(\n        this.getItemsFp([key], options),\n        TE.map(values => values[key] || ''),\n      );\n    });\n    this.getItemsFp = wrapSupportedTask((keys, options) => {\n      return fn.pipe(\n        keys.length ? invokeCustomMethod('getStorageValues', { keys }, options) : TE.right({}),\n        TE.map(data => {\n          return {\n            // Fulfill the response with probably missing keys.\n            ...keys.reduce<Record<string, string>>((acc, key) => {\n              acc[key] = '';\n              return acc;\n            }, {}),\n            ...parse(record(string(), string()), data),\n          };\n        }),\n      );\n    });\n    this.getKeysFp = wrapSupportedTask(options => {\n      return fn.pipe(\n        invokeCustomMethod('getStorageKeys', {}, options),\n        TE.map(data => parse(array(string()), data)),\n      );\n    });\n    this.setItemFp = wrapSupportedTask((key, value, options) => {\n      return fn.pipe(\n        invokeCustomMethod('saveStorageValue', { key, value }, options),\n        TE.map(() => undefined),\n      );\n    });\n    this.clearFp = wrapSupportedTask(options => {\n      return fn.pipe(this.getKeysFp(options), TE.chain(this.deleteItemFp));\n    });\n\n    this.deleteItem = throwifyWithChecksFp(this.deleteItemFp);\n    this.getItem = throwifyWithChecksFp(this.getItemFp);\n    this.getItems = throwifyWithChecksFp(this.getItemsFp);\n    this.getKeys = throwifyWithChecksFp(this.getKeysFp);\n    this.setItem = throwifyWithChecksFp(this.setItemFp);\n    this.clear = throwifyWithChecksFp(this.clearFp);\n  }\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Deletes specified key or keys from the cloud storage.\n   * @param keyOrKeys - key or keys to delete.\n   * @param options - request execution options.\n   * @since Mini Apps v6.9\n   */\n  readonly deleteItemFp: WithChecksFp<\n    (keyOrKeys: string | string[], options?: InvokeCustomMethodFpOptions) => CloudStorageTask<void>,\n    true\n  >;\n\n  readonly deleteItem: WithChecks<\n    (keyOrKeys: string | string[], options?: InvokeCustomMethodFpOptions) => BetterPromise<void>,\n    true\n  >;\n\n  /**\n   * Gets a single key value from the cloud storage.\n   * @param key - a key to get.\n   * @param options - request execution options.\n   * @returns A key value as a string.\n   * @since Mini Apps v6.9\n   */\n  readonly getItemFp: WithChecksFp<\n    (key: string, options?: InvokeCustomMethodFpOptions) => CloudStorageTask<string>,\n    true\n  >;\n\n  /**\n   * @see getItemFp\n   */\n  readonly getItem: WithChecks<{\n    <K extends string>(\n      keys: K[],\n      options?: InvokeCustomMethodFpOptions,\n    ): BetterPromise<Record<K, string>>;\n    (key: string, options?: InvokeCustomMethodFpOptions): BetterPromise<string>;\n  }, true>;\n\n  /**\n   * Gets multiple keys' values from the cloud storage.\n   * @param keys - keys list.\n   * @param options - request execution options.\n   * @returns A map, where a key is one of the specified in the `keys` argument,\n   * and a value is a corresponding storage value if an array of keys was passed.\n   * @since Mini Apps v6.9\n   */\n  readonly getItemsFp: WithChecksFp<\n    <K extends string>(\n      keys: K[],\n      options?: InvokeCustomMethodFpOptions,\n    ) => CloudStorageTask<Record<K, string>>,\n    true\n  >;\n\n  /**\n   * @see getItemsFp\n   */\n  readonly getItems: WithChecks<\n    <K extends string>(\n      keys: K[],\n      options?: InvokeCustomMethodFpOptions,\n    ) => BetterPromise<Record<K, string>>,\n    true\n  >;\n\n  /**\n   * Returns a list of all keys presented in the cloud storage.\n   * @param options - request execution options.\n   * @since Mini Apps v6.9\n   */\n  readonly getKeysFp: WithChecksFp<\n    (options?: InvokeCustomMethodFpOptions) => CloudStorageTask<string[]>,\n    true\n  >;\n\n  /**\n   * @see getKeysFp\n   */\n  readonly getKeys: WithChecks<\n    (options?: InvokeCustomMethodFpOptions) => BetterPromise<string[]>,\n    true\n  >;\n\n  /**\n   * Saves the specified value by a key.\n   * @param key - storage key.\n   * @param value - storage value.\n   * @param options - request execution options.\n   * @since Mini Apps v6.9\n   */\n  readonly setItemFp: WithChecksFp<\n    (key: string, value: string, options?: InvokeCustomMethodFpOptions) => CloudStorageTask<void>,\n    true\n  >;\n\n  /**\n   * @see setItemFp\n   */\n  readonly setItem: WithChecks<\n    (key: string, value: string, options?: InvokeCustomMethodFpOptions) => BetterPromise<void>,\n    true\n  >;\n\n  /**\n   * Clears the cloud storage.\n   * @param options - additional options.\n   * @since Mini Apps v6.9\n   */\n  readonly clearFp: WithChecksFp<\n    (options?: InvokeCustomMethodFpOptions) => CloudStorageTask<void>,\n    true\n  >;\n\n  /**\n   * @see clearFp\n   */\n  readonly clear: WithChecks<(options?: InvokeCustomMethodFpOptions) => BetterPromise<void>, true>;\n}\n","import { createSignal } from '@/globals/signals-registry.js';\n\nconst lastRequestId = createSignal(0);\n\n/**\n * @returns A new request identifier.\n */\nexport function createRequestId(): string {\n  lastRequestId.set(lastRequestId() + 1);\n  return lastRequestId().toString();\n}\n","import {\n  type RequestError,\n  type CustomMethodName,\n  type CustomMethodParams,\n  type InvokeCustomMethodOptions,\n  invokeCustomMethodFp,\n} from '@tma.js/bridge';\nimport { taskEither as TE } from 'fp-ts';\n\nimport { createRequestId } from '@/globals/createRequestId.js';\nimport { postEventFp } from '@/globals/postEvent.js';\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  options?: InvokeCustomMethodOptions,\n): TE.TaskEither<RequestError, unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param options - additional options.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): TE.TaskEither<RequestError, unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  options?: InvokeCustomMethodOptions,\n): TE.TaskEither<RequestError, unknown> {\n  return invokeCustomMethodFp(method, params, createRequestId(), {\n    ...options || {},\n    postEvent: postEventFp,\n  });\n}\n","import type {\n  CustomMethodParams,\n  CustomMethodName,\n  InvokeCustomMethodError,\n  InvokeCustomMethodFpOptions,\n  RequestError,\n} from '@tma.js/bridge';\nimport type * as TE from 'fp-ts/TaskEither';\n\nimport { createFnOption } from '@/fn-options/createFnOption.js';\nimport { invokeCustomMethod } from '@/globals/invokeCustomMethod.js';\n\nexport type { InvokeCustomMethodError };\n\nexport interface InvokeCustomMethodNoRequestIdFn {\n  <M extends CustomMethodName>(\n    this: void,\n    method: M,\n    params: CustomMethodParams<M>,\n    options?: InvokeCustomMethodFpOptions,\n  ): TE.TaskEither<InvokeCustomMethodError, unknown>;\n\n  (\n    this: void,\n    method: string,\n    params: object,\n    options?: InvokeCustomMethodFpOptions,\n  ): TE.TaskEither<RequestError, unknown>;\n}\n\nexport interface WithInvokeCustomMethod {\n  invokeCustomMethod: InvokeCustomMethodNoRequestIdFn;\n}\n\nexport const withInvokeCustomMethod = createFnOption<WithInvokeCustomMethod>({\n  invokeCustomMethod,\n});\n","import { function as fn } from 'fp-ts';\n\nimport { CloudStorage } from '@/features/CloudStorage/CloudStorage.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withInvokeCustomMethod } from '@/fn-options/withInvokeCustomMethod.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new CloudStorage(fn.pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withInvokeCustomMethod,\n  ));\n}\n\nexport const cloudStorage = /* @__PURE__*/ instantiate();\n","import { EventPayload, type MethodParams, type Request2CaptureFn, RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport { DeviceStorageMethodError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithCreateRequestId } from '@/fn-options/withCreateRequestId.js';\nimport type { WithRequest } from '@/fn-options/withRequest.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport type DeviceStorageError = RequestError | DeviceStorageMethodError;\n\nexport interface DeviceStorageOptions extends SharedFeatureOptions,\n  WithVersion,\n  WithRequest,\n  WithCreateRequestId {\n}\n\n/**\n * @since Mini Apps v9.0\n */\nexport class DeviceStorage {\n  constructor({ isTma, request, version, createRequestId }: DeviceStorageOptions) {\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      requires: 'web_app_device_storage_get_key',\n      isTma,\n      returns: 'task',\n    });\n\n    const invokeMethod = <\n      M extends (\n        | 'web_app_device_storage_save_key'\n        | 'web_app_device_storage_get_key'\n        | 'web_app_device_storage_save_key'\n        | 'web_app_device_storage_clear'\n      ),\n      E extends (\n        | 'device_storage_key_saved'\n        | 'device_storage_key_received'\n        | 'device_storage_cleared'\n      ),\n    >(\n      method: M,\n      event: E,\n      params: Omit<MethodParams<M>, 'req_id'>,\n    ): TE.TaskEither<DeviceStorageError, EventPayload<E>> => {\n      const requestId = createRequestId();\n      return fn.pipe(\n        request<M, ('device_storage_failed' | E)[]>(method, ['device_storage_failed', event], {\n          params: { ...params, req_id: requestId },\n          capture: (event => {\n            return 'payload' in event ? event.payload.req_id === requestId : true;\n          }) as Request2CaptureFn<('device_storage_failed' | E)[]>,\n        }),\n        TE.chain(response => (\n          response.event === 'device_storage_failed'\n            ? TE.left(new DeviceStorageMethodError(response.payload.error || 'UNKNOWN_ERROR'))\n            : TE.right(response.payload as EventPayload<E>)\n        )),\n      );\n    };\n\n    this.getItemFp = wrapSupportedTask(key => {\n      return fn.pipe(\n        invokeMethod('web_app_device_storage_get_key', 'device_storage_key_received', { key }),\n        TE.map(payload => payload.value),\n      );\n    });\n    this.setItemFp = wrapSupportedTask((key, value) => {\n      return fn.pipe(\n        invokeMethod('web_app_device_storage_save_key', 'device_storage_key_saved', { key, value }),\n        TE.map(() => undefined),\n      );\n    });\n    this.deleteItemFp = wrapSupportedTask(key => {\n      return this.setItemFp(key, null);\n    });\n    this.clearFp = wrapSupportedTask(() => {\n      return fn.pipe(\n        invokeMethod('web_app_device_storage_clear', 'device_storage_cleared', {}),\n        TE.map(() => undefined),\n      );\n    });\n\n    this.getItem = throwifyWithChecksFp(this.getItemFp);\n    this.setItem = throwifyWithChecksFp(this.setItemFp);\n    this.deleteItem = throwifyWithChecksFp(this.deleteItemFp);\n    this.clear = throwifyWithChecksFp(this.clearFp);\n  }\n\n  /**\n    * Retrieves an item using its key.\n    * @since Mini Apps v9.0\n    */\n  readonly getItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<DeviceStorageError, string | null>,\n    true\n  >;\n\n  /**\n   * @see getItemFp\n   */\n  readonly getItem: WithChecks<(key: string) => Promise<string | null>, true>;\n\n  /**\n    * Sets a new item in the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly setItemFp: WithChecksFp<\n    (key: string, value: string | null) => TE.TaskEither<DeviceStorageError, void>,\n    true\n  >;\n\n  /**\n   * @see setItemFp\n   */\n  readonly setItem: WithChecks<(key: string, value: string | null) => Promise<void>, true>;\n\n  /**\n    * Removes a key from the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly deleteItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<DeviceStorageError, void>,\n    true\n  >;\n\n  /**\n   * @see deleteItemFp\n   */\n  readonly deleteItem: WithChecks<(key: string) => Promise<void>, true>;\n\n  /**\n    * Removes all keys from the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly clearFp: WithChecksFp<() => TE.TaskEither<DeviceStorageError, void>, true>;\n\n  /**\n   * @see clearFp\n   */\n  readonly clear: WithChecks<() => Promise<void>, true>;\n}\n","import { createFnOption } from '@/fn-options/createFnOption.js';\nimport { createRequestId } from '@/globals/createRequestId.js';\n\nexport interface WithCreateRequestId {\n  /**\n   * A function generating a request identifier.\n   */\n  createRequestId: () => string;\n}\n\nexport const withCreateRequestId = createFnOption<WithCreateRequestId>({ createRequestId });\n","import { function as fn } from 'fp-ts';\n\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withCreateRequestId } from '@/fn-options/withCreateRequestId.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nimport { DeviceStorage } from './DeviceStorage.js';\n\nfunction instantiate() {\n  return new DeviceStorage(fn.pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withRequest,\n    withCreateRequestId,\n  ));\n}\n\nexport const deviceStorage = /* @__PURE__*/ instantiate();\n","import type { EmojiStatusAccessRequestedStatus, RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithVersion, WithRequest {\n}\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    options: AsyncOptions,\n  ): TE.TaskEither<RequestError, EmojiStatusAccessRequestedStatus> => {\n    return fn.pipe(\n      request('web_app_request_emoji_status_access', 'emoji_status_access_requested', options),\n      TE.map(response => response.status),\n    );\n  }, { ...rest, requires: 'web_app_request_emoji_status_access', returns: 'task' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withRequest,\n  ));\n}\n\n/**\n * Shows a native popup requesting permission for the bot to manage user's emoji status.\n * @param options - additional options.\n * @returns Emoji status access status.\n * @since Mini Apps v8.0\n * @example\n * const status = await requestEmojiStatusAccess();\n */\nexport const requestEmojiStatusAccessFp = instantiate();\n\n/**\n * @see requestEmojiStatusAccessFp\n */\nexport const requestEmojiStatusAccess = throwifyWithChecksFp(requestEmojiStatusAccessFp);\n","import { RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport { SetEmojiStatusError } from '@/errors.js';\nimport {\n  type SharedFeatureOptions,\n  sharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\nexport interface SetEmojiStatusOptions extends AsyncOptions {\n  duration?: number;\n}\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    customEmojiId: string,\n    options?: SetEmojiStatusOptions,\n  ): TE.TaskEither<RequestError | SetEmojiStatusError, void> => {\n    return fn.pipe(\n      request('web_app_set_emoji_status', ['emoji_status_set', 'emoji_status_failed'], {\n        params: {\n          custom_emoji_id: customEmojiId,\n          duration: (options || {}).duration,\n        },\n        ...options,\n      }),\n      TE.chainW(response => (\n        response.event === 'emoji_status_failed'\n          ? TE.left(new SetEmojiStatusError(response.payload.error))\n          : TE.right(undefined)\n      )),\n    );\n  }, {\n    ...rest,\n    requires: 'web_app_set_emoji_status',\n    returns: 'task',\n  });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withRequest,\n    withVersion,\n  ));\n}\n\n/**\n * Opens a dialog allowing the user to set the specified custom emoji as their status.\n * @returns Nothing if status set was successful.\n * @param options - additional options.\n * @since Mini Apps v8.0\n * @example\n * fn.pipe(\n *   setEmojiStatusFp('5361800828313167608'),\n *   TE.match(error => {\n *     console.error('Error occurred', error);\n *   }, () => {\n *     console.log('Status set');\n *   }),\n * );\n * const statusSet = await setEmojiStatus('5361800828313167608');\n */\nexport const setEmojiStatusFp = instantiate();\n\n/**\n * @see setEmojiStatusFp\n */\nexport const setEmojiStatus = throwifyWithChecksFp(setEmojiStatusFp);\n","import type {\n  ImpactHapticFeedbackStyle,\n  NotificationHapticFeedbackType,\n  PostEventError,\n} from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { either as E } from 'fp-ts';\n\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecksFp, type WithChecks } from '@/with-checks/withChecksFp.js';\n\ntype HapticFeedbackEither = E.Either<PostEventError, void>;\n\nexport interface HapticFeedbackOptions extends WithVersion, WithPostEvent, SharedFeatureOptions {\n}\n\n/**\n * @since Mini Apps v6.1\n */\nexport class HapticFeedback {\n  constructor({ postEvent, isTma, version }: HapticFeedbackOptions) {\n    const HAPTIC_METHOD_NAME = 'web_app_trigger_haptic_feedback';\n    const wrapSupported = createWithChecksFp({\n      requires: HAPTIC_METHOD_NAME,\n      isTma,\n      version,\n      returns: 'plain',\n    });\n\n    this.isSupported = createIsSupportedSignal(HAPTIC_METHOD_NAME, version);\n    this.impactOccurredFp = wrapSupported(style => {\n      return postEvent(HAPTIC_METHOD_NAME, { type: 'impact', impact_style: style });\n    });\n    this.notificationOccurredFp = wrapSupported(type => {\n      return postEvent(HAPTIC_METHOD_NAME, { type: 'notification', notification_type: type });\n    });\n    this.selectionChangedFp = wrapSupported(() => {\n      return postEvent(HAPTIC_METHOD_NAME, { type: 'selection_change' });\n    });\n\n    this.impactOccurred = throwifyWithChecksFp(this.impactOccurredFp);\n    this.notificationOccurred = throwifyWithChecksFp(this.notificationOccurredFp);\n    this.selectionChanged = throwifyWithChecksFp(this.selectionChangedFp);\n  }\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * A method that tells if an impact occurred. The Telegram app may play the\n   * appropriate haptics based on style value passed.\n   * @param style - impact style.\n   * @since Mini Apps v6.1\n   */\n  impactOccurredFp: WithChecksFp<(style: ImpactHapticFeedbackStyle) => HapticFeedbackEither, true>;\n\n  /**\n   * @see impactOccurredFp\n   */\n  impactOccurred: WithChecks<(style: ImpactHapticFeedbackStyle) => void, true>;\n\n  /**\n   * A method tells that a task or action has succeeded, failed, or produced\n   * a warning. The Telegram app may play the appropriate haptics based on type\n   * value passed.\n   * @param type - notification type.\n   * @since Mini Apps v6.1\n   */\n  notificationOccurredFp: WithChecksFp<\n    (type: NotificationHapticFeedbackType) => HapticFeedbackEither,\n    true\n  >;\n\n  /**\n   * @see notificationOccurredFp\n   */\n  notificationOccurred: WithChecks<(type: NotificationHapticFeedbackType) => void, true>;\n\n  /**\n   * A method tells that the user has changed a selection. The Telegram app may\n   * play the appropriate haptics.\n   *\n   * Do not use this feedback when the user makes or confirms a selection; use\n   * it only when the selection changes.\n   * @since Mini Apps v6.1\n   */\n  selectionChangedFp: WithChecksFp<() => HapticFeedbackEither, true>;\n\n  /**\n   * @see selectionChangedFp\n   */\n  selectionChanged: WithChecks<() => void, true>;\n}\n","import { function as fn } from 'fp-ts';\n\nimport { HapticFeedback } from '@/features/HapticFeedback/HapticFeedback.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new HapticFeedback(fn.pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n  ));\n}\n\nexport const hapticFeedback = /* @__PURE__*/ instantiate();\n","import type { PostEventError } from '@tma.js/bridge';\nimport { function as fn } from 'fp-ts';\nimport type * as E from 'fp-ts/Either';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n}\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((): E.Either<PostEventError, void> => {\n    return postEvent('web_app_add_to_home_screen');\n  }, { ...rest, requires: 'web_app_add_to_home_screen', returns: 'either' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withPostEvent,\n  ));\n}\n\n/**\n * Prompts the user to add the Mini App to the home screen.\n * @since Mini Apps v8.0\n */\nexport const addToHomeScreenFp = instantiate();\n\n/**\n * @see addToHomeScreenFp\n */\nexport const addToHomeScreen = throwifyWithChecksFp(addToHomeScreenFp);\n","import type { HomeScreenStatus, RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((options?: AsyncOptions): TE.TaskEither<RequestError, HomeScreenStatus> => {\n    return fn.pipe(\n      request('web_app_check_home_screen', 'home_screen_checked', options),\n      TE.map(response => response.status || 'unknown'),\n    );\n  }, { ...rest, requires: 'web_app_check_home_screen', returns: 'task' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withRequest,\n  ));\n}\n\n/**\n * Sends a request to the native Telegram application to check if the current mini\n * application is added to the device's home screen.\n * @param options - additional options.\n * @since Mini Apps v8.0\n */\nexport const checkHomeScreenStatusFp = instantiate();\n\n/**\n * @see checkHomeScreenStatusFp\n */\nexport const checkHomeScreenStatus = throwifyWithChecksFp(checkHomeScreenStatusFp);\n","import { computed, type Computed, signal } from '@tma.js/signals';\nimport { throwifyFpFn } from '@tma.js/toolkit';\nimport type { InitData as InitDataType } from '@tma.js/types';\nimport { either as E, option as O, function as fn } from 'fp-ts';\n\nexport interface InitDataOptions<Err> {\n  /**\n   * Retrieves init data from the current environment.\n   */\n  retrieveInitData: () => E.Either<Err, O.Option<{\n    raw: string;\n    obj: InitDataType;\n  }>>;\n}\n\nexport class InitData<Err extends Error> {\n  constructor({ retrieveInitData }: InitDataOptions<Err>) {\n    this.restoreFp = () => {\n      return fn.pipe(\n        retrieveInitData(),\n        E.map(O.match(() => undefined, ({ raw, obj }) => {\n          this._state.set(obj);\n          this._raw.set(raw);\n        })),\n      );\n    };\n    this.restore = throwifyFpFn(this.restoreFp);\n  }\n\n  private fromState<K extends keyof InitDataType>(key: K): Computed<InitDataType[K] | undefined> {\n    return computed(() => {\n      const s = this._state();\n      return s ? s[key] : undefined;\n    });\n  }\n\n  private readonly _state = signal<InitDataType>();\n\n  private readonly _raw = signal<string>();\n\n  /**\n   * Complete component state.\n   */\n  readonly state = computed(this._state);\n\n  /**\n   * @see InitDataType.auth_date\n   */\n  readonly authDate = this.fromState('auth_date');\n\n  /**\n   * @see InitDataType.can_send_after\n   */\n  readonly canSendAfter = this.fromState('can_send_after');\n\n  /**\n   * Date after which it is allowed to call\n   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n   */\n  readonly canSendAfterDate = computed(() => {\n    const authDateValue = this.authDate();\n    const canSendAfterValue = this.canSendAfter();\n\n    return canSendAfterValue && authDateValue\n      ? new Date(authDateValue.getTime() + (canSendAfterValue * 1000))\n      : undefined;\n  });\n\n  /**\n   * @see InitDataType.chat\n   */\n  readonly chat = this.fromState('chat');\n\n  /**\n   * @see InitDataType.chat_type\n   */\n  readonly chatType = this.fromState('chat_type');\n\n  /**\n   * @see InitDataType.chat_instance\n   */\n  readonly chatInstance = this.fromState('chat_instance');\n\n  /**\n   * @see InitDataType.hash\n   */\n  readonly hash = this.fromState('hash');\n\n  /**\n   * @see InitDataType.query_id\n   */\n  readonly queryId = this.fromState('query_id');\n\n  /**\n   * Raw representation of init data.\n   */\n  readonly raw = computed(this._raw);\n\n  /**\n   * @see InitDataType.receiver\n   */\n  readonly receiver = this.fromState('receiver');\n\n  /**\n   * @see InitDataType.signature\n   */\n  readonly signature = this.fromState('signature');\n\n  /**\n   * @see InitDataType.start_param\n   */\n  readonly startParam = this.fromState('start_param');\n\n  /**\n   * @see InitDataType.user\n   */\n  readonly user = this.fromState('user');\n\n  /**\n   * Restores the component state.\n   */\n  readonly restoreFp: () => E.Either<Err, void>;\n\n  /**\n   * @see restoreFp\n   */\n  readonly restore: () => void;\n}\n","import { retrieveRawInitDataFp, retrieveLaunchParamsFp } from '@tma.js/bridge';\nimport { either as E, function as fn, option as O } from 'fp-ts';\n\nimport { InitData } from '@/features/InitData/InitData.js';\n\nfunction instantiate() {\n  return new InitData({\n    retrieveInitData() {\n      return fn.pipe(\n        E.Do,\n        E.bindW('obj', () => fn.pipe(\n          retrieveLaunchParamsFp(),\n          E.map(({ tgWebAppData }) => {\n            return tgWebAppData ? O.some(tgWebAppData) : O.none;\n          }),\n        )),\n        E.bindW('raw', retrieveRawInitDataFp),\n        E.map(({ obj, raw }) => {\n          return fn.pipe(\n            O.Do,\n            O.bind('obj', () => obj),\n            O.bind('raw', () => raw),\n          );\n        }),\n      );\n    },\n  });\n}\n\nexport const initData = /* @__PURE__*/ instantiate();\n","import type { InvoiceStatus, RequestError } from '@tma.js/bridge';\nimport { computed, type Computed, signal } from '@tma.js/signals';\nimport { BetterPromise } from 'better-promises';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport { ConcurrentCallError, InvalidArgumentsError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithRequest } from '@/fn-options/withRequest.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecks, type WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype InvoiceTask<E, T> = TE.TaskEither<RequestError | ConcurrentCallError | E, T>;\n\nexport interface InvoiceOptions extends WithVersion, WithRequest, SharedFeatureOptions {\n}\n\n/**\n * @since Mini Apps v6.1\n */\nexport class Invoice {\n  constructor({ version, request, isTma }: InvoiceOptions) {\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      isTma,\n      requires: 'web_app_open_invoice',\n      returns: 'task',\n    });\n\n    const isOpened = signal(false);\n    const toggleClosed = () => {\n      isOpened.set(false);\n    };\n\n    this.isSupported = createIsSupportedSignal('web_app_open_invoice', version);\n    this.isOpened = computed(isOpened);\n    this.openSlugFp = wrapSupportedTask((slug, options) => {\n      return fn.pipe(\n        this.isOpened()\n          ? TE.left(new ConcurrentCallError('Invoice is already opened'))\n          : TE.right(undefined as never),\n        TE.chain(() => {\n          isOpened.set(true);\n          return request('web_app_open_invoice', 'invoice_closed', {\n            ...options,\n            params: { slug },\n            capture: data => slug === data.slug,\n          });\n        }),\n        TE.mapBoth(err => {\n          toggleClosed();\n          return err;\n        }, data => {\n          toggleClosed();\n          return data.status;\n        }),\n      );\n    });\n    this.openUrlFp = wrapSupportedTask((url, options) => {\n      const { hostname, pathname } = new URL(url, window.location.href);\n      if (hostname !== 't.me') {\n        return TE.left(new InvalidArgumentsError(`Link has unexpected hostname: ${hostname}`));\n      }\n\n      // Valid examples:\n      // \"/invoice/my-slug\"\n      // \"/$my-slug\"\n      const match = pathname.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n      if (!match) {\n        return TE.left(new InvalidArgumentsError(\n          'Expected to receive a link with a pathname in format \"/invoice/{slug}\" or \"/${slug}\"',\n        ));\n      }\n      return this.openSlugFp(match[2], options);\n    });\n\n    this.openUrl = throwifyWithChecksFp(this.openUrlFp);\n    this.openSlug = throwifyWithChecksFp(this.openSlugFp);\n  }\n\n  /**\n   * Signal indicating if any invoice is currently opened.\n   */\n  readonly isOpened: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Opens an invoice using its slug or URL.\n   * @param slug - invoice slug.\n   * @param options - additional options.\n   * @since Mini Apps v6.1\n   * @example\n   * const status = await invoice.openSlug('kJNFS331');\n   */\n  readonly openSlugFp: WithChecksFp<\n    (slug: string, options?: AsyncOptions) => InvoiceTask<never, InvoiceStatus>,\n    true\n  >;\n\n  /**\n   * @see openSlugFp\n   */\n  readonly openSlug: WithChecks<\n    (slug: string, options?: AsyncOptions) => BetterPromise<InvoiceStatus>,\n    true\n  >;\n\n  /**\n   * Opens an invoice using its URL.\n   * @param url - invoice URL.\n   * @param options - additional options.\n   * @since Mini Apps v6.1\n   * @example\n   * const status = await invoice.openUrl('https://t.me/$kJNFS331');\n   */\n  readonly openUrlFp: WithChecksFp<\n    (url: string, options?: AsyncOptions) => (\n      InvoiceTask<InvalidArgumentsError, InvoiceStatus>\n    ),\n    true\n  >;\n\n  /**\n   * @see openUrlFp\n   */\n  readonly openUrl: WithChecks<\n    (url: string, options?: AsyncOptions) => BetterPromise<InvoiceStatus>,\n    true\n  >;\n}\n","import { function as fn } from 'fp-ts';\n\nimport { Invoice } from '@/features/Invoice/Invoice.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new Invoice(fn.pipe(sharedFeatureOptions(), withRequest, withVersion));\n}\n\nexport const invoice = /* @__PURE__*/ instantiate();\n","import type { OpenLinkBrowser, PostEventError } from '@tma.js/bridge';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { InvalidArgumentsError } from '@/errors.js';\nimport {\n  type SharedFeatureOptions,\n  sharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { type WithPostEvent, withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent {\n}\n\nexport interface OpenLinkOptions {\n  /**\n   * Attempts to use the instant view mode.\n   */\n  tryInstantView?: boolean;\n  /**\n   * A preferred browser to open the link in.\n   */\n  tryBrowser?: OpenLinkBrowser;\n}\n\nexport type OpenLinkError = PostEventError | InvalidArgumentsError;\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((\n    url: string | URL,\n    options: OpenLinkOptions = {},\n  ): E.Either<OpenLinkError, void> => {\n    if (typeof url === 'string') {\n      try {\n        url = new URL(url);\n      } catch (e) {\n        return E.left(new InvalidArgumentsError(`\"${url.toString()}\" is invalid URL`, e));\n      }\n    }\n    return postEvent('web_app_open_link', {\n      url: url.toString(),\n      try_browser: options.tryBrowser,\n      try_instant_view: options.tryInstantView,\n    });\n  }, { ...rest, returns: 'either' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(sharedFeatureOptions(), withPostEvent));\n}\n\n/**\n * Opens a link.\n *\n * The Mini App will not be closed.\n *\n * Note that this method can be called only in response to the user\n * interaction with the Mini App interface (e.g. click inside the Mini App or on the main button).\n * @param url - URL to be opened.\n * @param options - additional options.\n * @example\n * openLink('https://google.com', {\n *   tryInstantView: true,\n *   tryBrowser: 'chrome',\n * });\n */\nexport const openLinkFp = instantiate();\n\nexport const openLink = throwifyWithChecksFp(openLinkFp);\n","import { supports, type PostEventError } from '@tma.js/bridge';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { InvalidArgumentsError } from '@/errors.js';\nimport {\n  type SharedFeatureOptions,\n  sharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { access } from '@/helpers/access.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n}\n\nexport type OpenTelegramLinkError = PostEventError | InvalidArgumentsError;\n\nfunction create({ postEvent, version, ...rest }: CreateOptions) {\n  return withChecksFp((\n    url: string | URL,\n  ): E.Either<OpenTelegramLinkError, void> => {\n    const urlString = url.toString();\n    if (!urlString.match(/^https:\\/\\/t.me\\/.+/)) {\n      return E.left(new InvalidArgumentsError(`\"${urlString}\" is invalid URL`));\n    }\n\n    if (supports('web_app_open_tg_link', access(version))) {\n      url = new URL(url);\n      return postEvent('web_app_open_tg_link', { path_full: url.pathname + url.search });\n    }\n\n    window.location.href = urlString;\n    return E.right(undefined);\n  }, { ...rest, returns: 'either' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n  ));\n}\n\n/**\n * Opens a Telegram link inside the Telegram app. The function expects passing a link in a full\n * format using the hostname \"t.me\".\n *\n * The Mini App will be closed.\n * @param url - URL to be opened.\n * @example\n * openTelegramLink('https://t.me/heyqbnk');\n */\nexport const openTelegramLinkFp = instantiate();\n\n/**\n * @see openTelegramLinkFp\n */\nexport const openTelegramLink = throwifyWithChecksFp(openTelegramLinkFp);\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { either as E } from 'fp-ts';\n\nimport { openTelegramLinkFp } from '@/features/links/openTelegramLink.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions {\n  openTelegramLink: (url: string) => E.Either<PostEventError, void>;\n}\n\nexport type ShareURLError = PostEventError;\n\nfunction create({ openTelegramLink, ...rest }: CreateOptions) {\n  return withChecksFp((url: string, text?: string): E.Either<ShareURLError, void> => {\n    return openTelegramLink(\n      'https://t.me/share/url?' + new URLSearchParams({ url, text: text || '' })\n        .toString()\n        // By default, URL search params encode spaces with \"+\".\n        // We are replacing them with \"%20\", because plus symbols are working incorrectly\n        // in Telegram.\n        .replace(/\\+/g, '%20'),\n    );\n  }, { ...rest, returns: 'either' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create({\n    ...sharedFeatureOptions(),\n    openTelegramLink: openTelegramLinkFp,\n  });\n}\n\n/**\n * Shares the specified URL with the passed to the chats, selected by user.\n * After being called, it closes the mini application.\n *\n * This method uses Telegram's Share Links.\n * @param url - URL to share.\n * @param text - text to append after the URL.\n * @see https://core.telegram.org/api/links#share-links\n * @see https://core.telegram.org/widgets/share#custom-buttons\n */\nexport const shareURLFp = instantiate();\n\n/**\n * @see shareURLFp\n */\nexport const shareURL = throwifyWithChecksFp(shareURLFp);\n","import type { EventPayload, RequestError, PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport type { Maybe } from '@tma.js/toolkit';\nimport { BetterPromise } from 'better-promises';\nimport { either as E, taskEither as TE, function as fn } from 'fp-ts';\n\nimport { AsyncMountable } from '@/composables/AsyncMountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport type {\n  LocationManagerOptions,\n  LocationManagerRequestLocationResponse,\n  LocationManagerState,\n} from '@/features/LocationManager/types.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecks, type WithChecksFp } from '@/with-checks/withChecksFp.js';\n\nfunction eventToState(event: EventPayload<'location_checked'>): LocationManagerState {\n  let available = false;\n  let accessRequested: Maybe<boolean>;\n  let accessGranted: Maybe<boolean>;\n  if (event.available) {\n    available = true;\n    accessRequested = event.access_requested;\n    accessGranted = event.access_granted;\n  }\n  return {\n    available,\n    accessGranted: accessGranted || false,\n    accessRequested: accessRequested || false,\n  };\n}\n\n/**\n * @since Mini Apps v8.0\n */\nexport class LocationManager {\n  constructor({\n    version,\n    request,\n    postEvent,\n    storage,\n    isTma,\n    isPageReload,\n  }: LocationManagerOptions) {\n    const stateful = new Stateful({\n      initialState: {\n        available: false,\n        accessGranted: false,\n        accessRequested: false,\n      },\n      onChange: storage.set,\n    });\n    const mountable = new AsyncMountable<LocationManagerState, RequestError>({\n      isPageReload,\n      restoreState: storage.get,\n      onMounted: stateful.setState,\n      initialState(options) {\n        return fn.pipe(\n          request('web_app_check_location', 'location_checked', options),\n          TE.map(eventToState),\n        );\n      },\n    });\n\n    const wrapOptions = { version, requires: 'web_app_check_location', isTma } as const;\n    const wrapSupportedEither = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'either',\n    });\n    const wrapSupportedTask = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'task',\n    });\n    const wrapMountedTask = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'task',\n      isMounted: mountable.isMounted,\n    });\n\n    this.isAvailable = stateful.getter('available');\n    this.isAccessRequested = stateful.getter('accessRequested');\n    this.isAccessGranted = stateful.getter('accessGranted');\n    this.isSupported = createIsSupportedSignal('web_app_check_location', version);\n    this.isMounted = mountable.isMounted;\n    this.state = stateful.state;\n\n    this.unmount = mountable.unmount;\n    this.mountFp = wrapSupportedTask(mountable.mount);\n    this.openSettingsFp = wrapSupportedEither(() => {\n      return postEvent('web_app_open_location_settings');\n    });\n    this.requestLocationFp = wrapMountedTask(options => {\n      return fn.pipe(\n        request('web_app_request_location', 'location_requested', options),\n        TE.map(response => {\n          if (!response.available) {\n            stateful.setState({ available: false });\n            return null;\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { available, ...rest } = response;\n          return rest;\n        }),\n      );\n    });\n\n    this.mount = throwifyWithChecksFp(this.mountFp);\n    this.openSettings = throwifyWithChecksFp(this.openSettingsFp);\n    this.requestLocation = throwifyWithChecksFp(this.requestLocationFp);\n  }\n\n  /**\n   * Complete location manager state.\n   */\n  readonly state: Computed<LocationManagerState>;\n\n  /**\n   * Signal indicating whether the location data tracking is currently available.\n   */\n  readonly isAvailable: Computed<boolean>;\n\n  /**\n   * Signal indicating whether the user has granted the app permission to track location data.\n   */\n  readonly isAccessGranted: Computed<boolean>;\n\n  /**\n   * Signal indicating whether the app has previously requested permission to track location data.\n   */\n  readonly isAccessRequested: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Opens the location access settings for bots. Useful when you need to request location access\n   * from users who haven't granted it yet.\n   *\n   * Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g., a click inside the Mini App or on the main button).\n   * @since Mini Apps v8.0\n   */\n  readonly openSettingsFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see openSettingsFp\n   */\n  readonly openSettings: WithChecks<() => void, true>;\n\n  /**\n   * Requests location data.\n   * @since Mini Apps v8.0\n   * @returns Promise with location data or null it access was not granted.\n   */\n  readonly requestLocationFp: WithChecksFp<\n    (options?: AsyncOptions) => (\n      TE.TaskEither<RequestError, LocationManagerRequestLocationResponse | null>\n    ),\n    true\n  >;\n\n  /**\n   * @see requestLocationFp\n   */\n  readonly requestLocation: WithChecks<\n    (options?: AsyncOptions) => BetterPromise<LocationManagerRequestLocationResponse | null>,\n    true\n  >;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v8.0\n   */\n  readonly mountFp: WithChecksFp<\n    (options?: AsyncOptions) => TE.TaskEither<RequestError, void>,\n    true\n  >;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, true>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n}\n","import { function as fn } from 'fp-ts';\n\nimport { LocationManager } from '@/features/LocationManager/LocationManager.js';\nimport type { LocationManagerState } from '@/features/LocationManager/types.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new LocationManager(fn.pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n    withRequest,\n    withStateRestore<LocationManagerState>('locationManager'),\n  ));\n}\n\nexport const locationManager = /* @__PURE__*/ instantiate();\n","import type { PostEventError } from '@tma.js/bridge';\nimport { computed, type Computed } from '@tma.js/signals';\nimport type { RGB } from '@tma.js/types';\nimport { either as E } from 'fp-ts';\n\nimport { Button, type ButtonOptions } from '@/composables/Button.js';\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\nimport type { WithChecks, WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype MainButtonEither = E.Either<PostEventError, void>;\n\nexport interface MainButtonState {\n  isVisible: boolean;\n  bgColor?: RGB;\n  hasShineEffect: boolean;\n  isEnabled: boolean;\n  isLoaderVisible: boolean;\n  text: string;\n  textColor?: RGB;\n}\n\nexport interface MainButtonOptions extends Omit<\n  ButtonOptions<MainButtonState, 'web_app_setup_main_button'>,\n  'initialState' | 'method' | 'payload' | 'version'\n> {\n  /**\n   * Default values for different kinds of the button properties.\n   */\n  defaults: {\n    bgColor: MaybeAccessor<RGB>;\n    textColor: MaybeAccessor<RGB>;\n  };\n}\n\nexport class MainButton {\n  constructor({ defaults, ...options }: MainButtonOptions) {\n    const button = new Button({\n      ...options,\n      version: '100',\n      initialState: {\n        hasShineEffect: false,\n        isEnabled: true,\n        isLoaderVisible: false,\n        isVisible: false,\n        text: 'Continue',\n      },\n      method: 'web_app_setup_main_button',\n      payload: state => ({\n        has_shine_effect: state.hasShineEffect,\n        is_visible: state.isVisible,\n        is_active: state.isEnabled,\n        is_progress_visible: state.isLoaderVisible,\n        text: state.text,\n        color: state.bgColor,\n        text_color: state.textColor,\n      }),\n    });\n\n    const withDefault = (\n      field: 'bgColor' | 'textColor',\n      getDefault: MaybeAccessor<RGB>,\n    ) => {\n      const fromState = button.stateGetter(field);\n      return computed(() => fromState() || access(getDefault));\n    };\n\n    this.bgColor = withDefault('bgColor', defaults.bgColor);\n    this.textColor = withDefault('textColor', defaults.textColor);\n    this.hasShineEffect = button.stateGetter('hasShineEffect');\n    this.isEnabled = button.stateGetter('isEnabled');\n    this.isLoaderVisible = button.stateGetter('isLoaderVisible');\n    this.text = button.stateGetter('text');\n    this.isVisible = button.stateGetter('isVisible');\n    this.isMounted = button.isMounted;\n    this.state = button.state;\n\n    [this.setBgColor, this.setBgColorFp] = button.stateSetters('bgColor');\n    [this.setTextColor, this.setTextColorFp] = button.stateSetters('textColor');\n    [\n      [this.disableShineEffect, this.disableShineEffectFp],\n      [this.enableShineEffect, this.enableShineEffectFp],\n    ] = button.stateBoolSetters('hasShineEffect');\n    [\n      [this.disable, this.disableFp],\n      [this.enable, this.enableFp],\n    ] = button.stateBoolSetters('isEnabled');\n    [\n      [this.hideLoader, this.hideLoaderFp],\n      [this.showLoader, this.showLoaderFp],\n    ] = button.stateBoolSetters('isLoaderVisible');\n\n    [this.setText, this.setTextFp] = button.stateSetters('text');\n    [[this.hide, this.hideFp], [this.show, this.showFp]] = button.stateBoolSetters('isVisible');\n    this.setParams = button.setState;\n    this.setParamsFp = button.setStateFp;\n    this.onClick = button.onClick;\n    this.onClickFp = button.onClickFp;\n    this.offClick = button.offClick;\n    this.offClickFp = button.offClickFp;\n    this.mount = button.mount;\n    this.mountFp = button.mountFp;\n    this.unmount = button.unmount;\n  }\n\n  //#region Properties.\n  /**\n   * The button background color.\n   */\n  readonly bgColor: Computed<RGB>;\n\n  /**\n   * True if the button has a shining effect.\n   */\n  readonly hasShineEffect: Computed<boolean>;\n\n  /**\n   * True if the button is clickable.\n   */\n  readonly isEnabled: Computed<boolean>;\n\n  /**\n   * True if the button loader is visible.\n   */\n  readonly isLoaderVisible: Computed<boolean>;\n\n  /**\n   * True if the button is visible.\n   */\n  readonly isVisible: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * The complete button state.\n   */\n  readonly state: Computed<MainButtonState>;\n\n  /**\n   * The button displayed text.\n   */\n  readonly text: Computed<string>;\n\n  /**\n   * The button text color.\n   *\n   * Note that this value is computed based on the external defaults. For\n   * example, if not explicitly set, this value may be equal to one of theme\n   * params colors.\n   */\n  readonly textColor: Computed<RGB>;\n  //#endregion\n\n  //#region Methods.\n  /**\n   * Shows the button.\n   */\n  readonly showFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<() => void, false>;\n\n  /**\n   * Hides the button.\n   */\n  readonly hideFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see hideFp\n   */\n  readonly hide: WithChecks<() => void, false>;\n\n  /**\n   * Enables the button.\n   */\n  readonly enableFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see enableFp\n   */\n  readonly enable: WithChecks<() => void, false>;\n\n  /**\n   * Enables the button.\n   */\n  readonly enableShineEffectFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see enableShineEffectFp\n   */\n  readonly enableShineEffect: WithChecks<() => void, false>;\n\n  /**\n   * Disables the button.\n   */\n  readonly disableFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see disableFp\n   */\n  readonly disable: WithChecks<() => void, false>;\n\n  /**\n   * Enables the button.\n   */\n  readonly disableShineEffectFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see disableShineEffectFp\n   */\n  readonly disableShineEffect: WithChecks<() => void, false>;\n\n  /**\n   * Updates the button background color.\n   */\n  readonly setBgColorFp: WithChecksFp<(value: RGB) => MainButtonEither, false>;\n\n  /**\n   * @see setBgColorFp\n   */\n  readonly setBgColor: WithChecks<(value: RGB) => void, false>;\n\n  /**\n   * Updates the button text color.\n   */\n  readonly setTextColorFp: WithChecksFp<(value: RGB) => MainButtonEither, false>;\n\n  /**\n   * @see setTextColorFp\n   */\n  readonly setTextColor: WithChecks<(value: RGB) => void, false>;\n\n  /**\n   * Updates the button text.\n   */\n  readonly setTextFp: WithChecksFp<(value: string) => MainButtonEither, false>;\n\n  /**\n   * @see setTextFp\n   */\n  readonly setText: WithChecks<(value: string) => void, false>;\n\n  /**\n   * Shows the button loader.\n   */\n  readonly showLoaderFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see showLoaderFp\n   */\n  readonly showLoader: WithChecks<() => void, false>;\n\n  /**\n   * Hides the button loader.\n   */\n  readonly hideLoaderFp: WithChecksFp<() => MainButtonEither, false>;\n\n  /**\n   * @see hideLoaderFp\n   */\n  readonly hideLoader: WithChecks<() => void, false>;\n\n  /**\n   * Updates the button state.\n   * @param state - updates to apply.\n   * @example\n   * button.setParams({\n   *   text: 'Submit',\n   *   isEnabled: true,\n   *   hasShineEffect: true,\n   * });\n   */\n  readonly setParamsFp: WithChecksFp<(state: Partial<MainButtonState>) => MainButtonEither, false>;\n\n  readonly setParams: WithChecks<(state: Partial<MainButtonState>) => void, false>;\n\n  /**\n   * Mounts the component restoring its state.\n   */\n  readonly mountFp: WithChecksFp<() => void, false>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, false>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => VoidFunction, false>;\n\n  /**\n   * @see onClickFp\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, false>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => void, false>;\n\n  /**\n   * @see offClickFp\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, false>;\n  //#endregion\n}\n","/**\n * Sets CSS variable globally.\n * @param name - variable name.\n * @param value - variable value.\n */\nexport function setCssVar(name: string, value: string | null): void {\n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Deletes specified CSS variable.\n * @param name - variable name.\n */\nexport function deleteCssVar(name: string): void {\n  document.documentElement.style.removeProperty(name);\n}\n","import { throwifyFpFn } from '@tma.js/toolkit';\nimport { toRGBFullFp } from '@tma.js/transformers';\nimport { either as E, function as fn } from 'fp-ts';\n\n/**\n * @param color - color in any format acceptable by the `toRGB` function.\n * @returns True if the color is recognized as dark.\n * @see toRGB\n */\nexport function isColorDarkFp(color: string): E.Either<Error, boolean> {\n  return fn.pipe(\n    toRGBFullFp(color),\n    E.map(rgb => {\n      // Actual formula: hsp = Math.sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)\n      // See: https://stackoverflow.com/a/596243\n      return Math.sqrt(\n        [0.299, 0.587, 0.114].reduce<number>((acc, modifier, idx) => {\n          // Extract part of #RRGGBB pattern and convert it to DEC.\n          const dec = parseInt(rgb.slice(1 + (idx * 2), 1 + ((idx + 1) * 2)), 16);\n          return acc + (dec * dec * modifier);\n        }, 0),\n      ) < 120;\n    }),\n  );\n}\n\n/**\n * @see isColorDarkFp\n */\nexport const isColorDark = throwifyFpFn(isColorDarkFp);\n","import type { EventListener } from '@tma.js/bridge';\nimport { computed, type Computed, signal } from '@tma.js/signals';\nimport { snakeToKebab } from '@tma.js/toolkit';\nimport type { ThemeParams as ThemeParamsType, RGB } from '@tma.js/types';\nimport { either as E } from 'fp-ts';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport { CSSVarsBoundError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport { access } from '@/helpers/access.js';\nimport { deleteCssVar, setCssVar } from '@/helpers/css-vars.js';\nimport { isColorDark } from '@/helpers/isColorDark.js';\nimport type { MaybeAccessor } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport type ThemeParamsState = ThemeParamsType;\n\nexport interface ThemeParamsOptions extends WithStateRestore<ThemeParamsState>,\n  SharedFeatureOptions {\n  /**\n   * Removes a theme change listener.\n   * @param listener - a listener to remove.\n   */\n  offChange: (listener: EventListener<'theme_changed'>) => void;\n  /**\n   * Adds a theme change listener.\n   * @returns A function to remove listener.\n   * @param listener - a listener to add.\n   */\n  onChange: (listener: EventListener<'theme_changed'>) => void;\n  /**\n   * Theme parameters initial state.\n   */\n  initialState: MaybeAccessor<ThemeParamsType>;\n}\n\nexport interface ThemeParamsGetCssVarNameFn {\n  /**\n   * @param property - palette key.\n   * @returns Computed complete CSS variable name.\n   */\n  (property: Extract<keyof ThemeParamsType, string>): string;\n}\n\nexport class ThemeParams {\n  constructor({\n    initialState,\n    onChange,\n    offChange,\n    isTma,\n    storage,\n    isPageReload,\n  }: ThemeParamsOptions) {\n    const stateful = new Stateful<ThemeParamsState>({\n      initialState: {},\n      onChange: storage.set,\n    });\n    const listener: EventListener<'theme_changed'> = event => {\n      stateful.setState(event.theme_params);\n    };\n    const mountable = new Mountable<ThemeParamsType>({\n      initialState: () => E.right(access(initialState)),\n      isPageReload,\n      onMounted(state) {\n        stateful.setState(state);\n        onChange(listener);\n      },\n      onUnmounted() {\n        offChange(listener);\n      },\n      restoreState: storage.get,\n    });\n\n    const wrapOptions = { isTma, returns: 'either' } as const;\n    const wrapSupportedEither = createWithChecksFp(wrapOptions);\n    const wrapMountedEither = createWithChecksFp({\n      ...wrapOptions,\n      isMounted: mountable.isMounted,\n    });\n\n    // Colors.\n    this.accentTextColor = stateful.getter('accent_text_color');\n    this.bgColor = stateful.getter('bg_color');\n    this.buttonColor = stateful.getter('button_color');\n    this.buttonTextColor = stateful.getter('button_text_color');\n    this.bottomBarBgColor = stateful.getter('bottom_bar_bg_color');\n    this.destructiveTextColor = stateful.getter('destructive_text_color');\n    this.headerBgColor = stateful.getter('header_bg_color');\n    this.hintColor = stateful.getter('hint_color');\n    this.linkColor = stateful.getter('link_color');\n    this.secondaryBgColor = stateful.getter('secondary_bg_color');\n    this.sectionBgColor = stateful.getter('section_bg_color');\n    this.sectionHeaderTextColor = stateful.getter('section_header_text_color');\n    this.sectionSeparatorColor = stateful.getter('section_separator_color');\n    this.subtitleTextColor = stateful.getter('subtitle_text_color');\n    this.textColor = stateful.getter('text_color');\n\n    // Other public signals.\n    this.state = stateful.state;\n    this.isMounted = mountable.isMounted;\n    this.bindCssVarsFp = wrapMountedEither(getCSSVarName => {\n      if (this._isCssVarsBound()) {\n        return E.left(new CSSVarsBoundError());\n      }\n      getCSSVarName ||= prop => `--tg-theme-${snakeToKebab(prop)}`;\n\n      const forEachEntry = (fn: (key: string, value: RGB) => void): void => {\n        Object.entries(stateful.state()).forEach(([k, v]) => {\n          v && fn(k, v);\n        });\n      };\n\n      const actualize = (): void => {\n        forEachEntry((k, v) => {\n          setCssVar(getCSSVarName(k), v);\n        });\n      };\n\n      actualize();\n      stateful.state.sub(actualize);\n      this._isCssVarsBound.set(true);\n\n      return E.right(() => {\n        forEachEntry(deleteCssVar);\n        stateful.state.unsub(actualize);\n        this._isCssVarsBound.set(false);\n      });\n    });\n    this.mountFp = wrapSupportedEither(mountable.mount);\n    this.unmount = mountable.unmount;\n\n    this.bindCssVars = throwifyWithChecksFp(this.bindCssVarsFp);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n  }\n\n  //#region Colors.\n  /**\n   * @since v6.10\n   */\n  readonly accentTextColor: Computed<RGB | undefined>;\n\n  readonly bgColor: Computed<RGB | undefined>;\n\n  readonly buttonColor: Computed<RGB | undefined>;\n\n  readonly buttonTextColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v7.10\n   */\n  readonly bottomBarBgColor: Computed<RGB | undefined>;\n\n  readonly destructiveTextColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v6.10\n   */\n  readonly headerBgColor: Computed<RGB | undefined>;\n\n  readonly hintColor: Computed<RGB | undefined>;\n\n  readonly linkColor: Computed<RGB | undefined>;\n\n  readonly secondaryBgColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v6.10\n   */\n  readonly sectionBgColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v6.10\n   */\n  readonly sectionHeaderTextColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v7.6\n   */\n  readonly sectionSeparatorColor: Computed<RGB | undefined>;\n\n  /**\n   * @since v6.10\n   */\n  readonly subtitleTextColor: Computed<RGB | undefined>;\n\n  readonly textColor: Computed<RGB | undefined>;\n  //#endregion\n\n  //#region CSS variables.\n  private readonly _isCssVarsBound = signal(false);\n\n  /**\n   * True if CSS variables are currently bound.\n   */\n  readonly isCssVarsBound = computed(this._isCssVarsBound);\n\n  /**\n   * Creates CSS variables connected with the current theme parameters.\n   *\n   * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n   * {name} is a theme parameters key name converted from snake case to kebab case.\n   *\n   * Default variables:\n   * - `--tg-theme-bg-color`\n   * - `--tg-theme-secondary-text-color`\n   *\n   * Variables are being automatically updated if theme parameters were changed.\n   *\n   * @param getCSSVarName - function, returning complete CSS variable name for the specified\n   * theme parameters key.\n   * @returns Function to stop updating variables.\n   * @throws {CSSVarsBoundError} CSS variables are already bound\n   * @example Using custom CSS vars generator\n   * themeParams.bindCssVars(key => `--my-prefix-${key}`);\n   */\n  readonly bindCssVarsFp: WithChecksFp<\n    (getCSSVarName?: ThemeParamsGetCssVarNameFn) => E.Either<CSSVarsBoundError, VoidFunction>,\n    false\n  >;\n\n  /**\n   * @see bindCssVarsFp\n   */\n  readonly bindCssVars: WithChecks<\n    (getCSSVarName?: ThemeParamsGetCssVarNameFn) => VoidFunction,\n    false\n  >;\n  //#endregion\n\n  //#region Other public signals.\n  /**\n   * Complete component state.\n   */\n  readonly state: Computed<ThemeParamsType>;\n\n  /**\n   * @returns True if the current color scheme is recognized as dark.\n   * This value is calculated based on the current theme's background color.\n   */\n  readonly isDark = computed(() => {\n    const color = this.bgColor();\n    return !color || isColorDark(color);\n  });\n  //#endregion\n\n  //#region Mounting.\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component restoring its state.\n   */\n  readonly mountFp: WithChecksFp<() => E.Either<never, void>, false>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, false>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n  //#endregion\n}\n","import type { ThemeParams } from '@tma.js/types';\n\nimport { createSignal } from '@/globals/signals-registry.js';\n\n/**\n * Mini application's theme parameters.\n */\nexport const themeParams = createSignal<ThemeParams>({});\n","import { on, off } from '@tma.js/bridge';\nimport { function as fn } from 'fp-ts';\n\nimport { ThemeParams, type ThemeParamsState } from '@/features/ThemeParams/ThemeParams.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { themeParams as globalThemeParams } from '@/globals/themeParams.js';\n\nfunction instantiate() {\n  return new ThemeParams({\n    ...fn.pipe(\n      sharedFeatureOptions(),\n      withStateRestore<ThemeParamsState>('themeParams'),\n    ),\n    offChange(listener) {\n      off('theme_changed', listener);\n    },\n    onChange(listener) {\n      on('theme_changed', listener);\n    },\n    initialState: globalThemeParams,\n  });\n}\n\nexport const themeParams = /* @__PURE__*/ instantiate();\n","import type { EventName } from '@tma.js/bridge';\nimport { function as fn } from 'fp-ts';\n\nimport { buttonOptions } from '@/fn-options/buttonOptions.js';\n\n// @__NO_SIDE_EFFECTS__\nexport function bottomButtonOptions<S, D>(\n  storageName: string,\n  trackedClickEvent: EventName,\n  defaults: D,\n) {\n  return fn.pipe(\n    buttonOptions<S>(storageName, trackedClickEvent),\n    obj => ({ ...obj, defaults }),\n  );\n}\n","import { computed } from '@tma.js/signals';\n\nimport { MainButton } from '@/features/MainButton/MainButton.js';\nimport { themeParams } from '@/features/ThemeParams/instance.js';\nimport { bottomButtonOptions } from '@/fn-options/bottomButtonOptions.js';\n\nexport const mainButton = /* @__PURE__*/ new MainButton(\n  bottomButtonOptions('mainButton', 'main_button_pressed', {\n    bgColor: computed(() => themeParams.buttonColor() || '#2481cc'),\n    textColor: computed(() => themeParams.buttonTextColor() || '#ffffff'),\n  }),\n);\n","import {\n  supports,\n  type PostEventError,\n  type EventPayload,\n  type EventListener,\n} from '@tma.js/bridge';\nimport { type Computed, computed } from '@tma.js/signals';\nimport { signal } from '@tma.js/signals';\nimport { createCbCollector, camelToKebab } from '@tma.js/toolkit';\nimport { isRGB } from '@tma.js/transformers';\nimport type { KnownThemeParamsKey, RGB, ThemeParams } from '@tma.js/types';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport { CSSVarsBoundError, UnknownThemeParamsKeyError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { access } from '@/helpers/access.js';\nimport { deleteCssVar, setCssVar } from '@/helpers/css-vars.js';\nimport { isColorDark } from '@/helpers/isColorDark.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  withChecksFp,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\ntype AnyColor = RGB | KnownThemeParamsKey | string;\n\nexport interface MiniAppState {\n  bgColor: AnyColor;\n  bottomBarColor: AnyColor;\n  headerColor: AnyColor;\n  isActive: boolean;\n}\n\nexport interface MiniAppGetCssVarNameFn {\n  /**\n   * @param property - mini app property.\n   * @returns Computed complete CSS variable name.\n   */\n  (property: 'bgColor' | 'bottomBarColor' | 'headerColor'): string;\n}\n\ntype WithListeners<Handlers extends string, Payload> = {\n  [K in Handlers]: (listener: (payload: Payload) => void) => void;\n};\n\nexport interface MiniAppOptions extends WithPostEvent,\n  WithVersion,\n  WithStateRestore<MiniAppState>,\n  WithListeners<'onVisibilityChanged' | 'offVisibilityChanged', EventPayload<'visibility_changed'>>,\n  SharedFeatureOptions {\n  /**\n   * The current theme parameters.\n   */\n  theme: Computed<ThemeParams>;\n}\n\n/**\n * @since Mini Apps v6.1\n */\nexport class MiniApp {\n  constructor({\n    storage,\n    isPageReload,\n    version,\n    postEvent,\n    isTma,\n    theme,\n    onVisibilityChanged,\n    offVisibilityChanged,\n  }: MiniAppOptions) {\n    //#region Mounting.\n    const visibilityChangedListener: EventListener<'visibility_changed'> = event => {\n      stateful.setState({ isActive: event.is_visible });\n    };\n    const themeChangedListener = (theme: ThemeParams) => {\n      // Sometimes we may have the following colors to be specified as some theme params keys.\n      // Due to the Mini Apps nature, we are not really allowed to do that, but we want to provide\n      // such an opportunity to developers.\n      //\n      // So if the developer specified some field as a reference to some theme params key, we\n      // should find an according RGB color for it and send it to the Telegram client. We have one\n      // exclusion here - the method 'web_app_set_header_color' may accept values 'bg_color'\n      // and 'secondary_bg_color'. Other methods accept only RGB values.\n      ([\n        [this.headerColor, 'web_app_set_header_color'],\n        [this.bgColor, 'web_app_set_background_color'],\n        [this.bottomBarColor, 'web_app_set_bottom_bar_color'],\n      ] as const).forEach(([signal, method]) => {\n        const color = signal();\n        // The value is already in RGB format, we have nothing to update here.\n        if (isRGB(color)) {\n          return;\n        }\n        // The real RGB value should only be extracted for the following methods:\n        // - 'web_app_set_background_color'\n        // - 'web_app_set_bottom_bar_color'\n        // We should also do it in case of the 'web_app_set_header_color' method, if the value\n        // specified is not 'bg_color' and 'secondary_bg_color' (unknown key to\n        // the Telegram client).\n        if (\n          method !== 'web_app_set_header_color'\n          || !['bg_color', 'secondary_bg_color'].includes(color)\n        ) {\n          const rgb = theme[color];\n          if (rgb) {\n            postEvent(method, { color: rgb });\n          }\n        }\n      });\n    };\n    const mountable = new Mountable({\n      initialState() {\n        return E.right({\n          bgColor: 'bg_color',\n          headerColor: 'header_bg_color',\n          bottomBarColor: 'bottom_bar_bg_color',\n          isActive: true,\n        });\n      },\n      isPageReload,\n      onMounted: state => {\n        onVisibilityChanged(visibilityChangedListener);\n        theme.sub(themeChangedListener);\n        stateful.setState(state);\n      },\n      onUnmounted() {\n        offVisibilityChanged(visibilityChangedListener);\n        theme.unsub(themeChangedListener);\n      },\n      restoreState: storage.get,\n    });\n    this.isMounted = mountable.isMounted;\n    this.mountFp = withChecksFp(() => {\n      const nothing = () => undefined;\n      return fn.pipe(mountable.mount(), E.match(nothing, nothing));\n    }, { isTma, returns: 'plain' });\n    this.mount = throwifyWithChecksFp(this.mountFp);\n    this.unmount = mountable.unmount;\n    //#endregion\n\n    //#region State.\n    const stateful = new Stateful({\n      initialState: {\n        bgColor: 'bg_color',\n        bottomBarColor: 'bottom_bar_bg_color',\n        headerColor: 'bg_color',\n        isActive: false,\n      },\n      onChange: storage.set,\n    });\n    this.state = stateful.state;\n\n    const rgbBasedOn = (color: AnyColor): RGB | undefined => {\n      return isRGB(color) ? color : access(theme)[color];\n    };\n    const computedRgbBasedOn = (signal: Computed<AnyColor>): Computed<RGB | undefined> => {\n      return computed(() => rgbBasedOn(signal()));\n    };\n    //#endregion\n\n    //#region Other properties.\n    this.isActive = stateful.getter('isActive');\n    this.isSupported = computed(() => {\n      return ([\n        'web_app_set_header_color',\n        'web_app_set_background_color',\n        'web_app_set_bottom_bar_color',\n      ] as const).some(method => supports(method, access(version)));\n    });\n    //#endregion\n\n    //#region Css vars.\n    const isCssVarsBound = signal(false);\n    this.isCssVarsBound = computed(isCssVarsBound);\n    this.bindCssVarsFp = withChecksFp(getCSSVarName => {\n      if (isCssVarsBound()) {\n        return E.left(new CSSVarsBoundError());\n      }\n      const [addCleanup, cleanup] = createCbCollector(() => {\n        isCssVarsBound.set(false);\n      });\n\n      const bind = (cssVar: string, signal: Computed<RGB | undefined>) => {\n        const update = () => {\n          setCssVar(cssVar, signal() || null);\n        };\n        update();\n        addCleanup(signal.sub(update), deleteCssVar.bind(null, cssVar));\n      };\n\n      getCSSVarName ||= prop => `--tg-${camelToKebab(prop)}`;\n      bind(getCSSVarName('bgColor'), this.bgColorRgb);\n      bind(getCSSVarName('bottomBarColor'), this.bottomBarColorRgb);\n      bind(getCSSVarName('headerColor'), this.headerColorRgb);\n\n      isCssVarsBound.set(true);\n\n      return E.right(cleanup);\n    }, { isTma, returns: 'either', isMounted: this.isMounted });\n    this.bindCssVars = throwifyWithChecksFp(this.bindCssVarsFp);\n    //#endregion\n\n    //#region Colors.\n    type GenColorToolsetResult<K extends Exclude<keyof MiniAppState, 'isActive'>> = [\n      rawColor: Computed<AnyColor>,\n      rgbColor: Computed<RGB | undefined>,\n      throwing: WithChecks<\n        (color: AnyColor) => void,\n        true,\n        K extends 'headerColor' ? 'rgb' : never\n      >,\n      fp: WithChecksFp<\n        (color: AnyColor) => E.Either<UnknownThemeParamsKeyError | PostEventError, void>,\n        true,\n        K extends 'headerColor' ? 'rgb' : never\n      >,\n    ];\n    const genColorToolset = <K extends Exclude<keyof MiniAppState, 'isActive'>>(\n      stateKey: K,\n    ): GenColorToolsetResult<K> => {\n      const rawColor = stateful.getter(stateKey);\n      const rgbColor = computedRgbBasedOn(rawColor);\n      const method = ({\n        headerColor: 'web_app_set_header_color',\n        bgColor: 'web_app_set_background_color',\n        bottomBarColor: 'web_app_set_bottom_bar_color',\n      } as const)[stateKey];\n\n      const fp = withChecksFp(\n        (color: AnyColor): E.Either<UnknownThemeParamsKeyError | PostEventError, void> => {\n          if (color === rawColor()) {\n            return E.right(undefined);\n          }\n          if (\n            method === 'web_app_set_header_color'\n            && (color === 'bg_color' || color === 'secondary_bg_color')\n          ) {\n            return fn.pipe(\n              postEvent('web_app_set_header_color', { color_key: color }),\n              E.map(() => {\n                stateful.setState({ [stateKey]: color });\n              }),\n            );\n          }\n          const rgb = rgbBasedOn(color);\n          return fn.pipe(\n            rgb\n              ? postEvent(method, { color: rgb })\n              : E.left(new UnknownThemeParamsKeyError(color)),\n            E.map(() => {\n              stateful.setState({ [stateKey]: color });\n            }),\n          );\n        },\n        {\n          isTma,\n          version,\n          requires: method,\n          isMounted: this.isMounted,\n          returns: 'either',\n          supports: stateKey === 'headerColor'\n            ? {\n              rgb: {\n                method: 'web_app_set_header_color',\n                param: 'color',\n                shouldCheck: isRGB,\n              },\n            }\n            : undefined,\n        },\n      );\n\n      return [rawColor, rgbColor, throwifyWithChecksFp(fp), fp] as GenColorToolsetResult<K>;\n    };\n    [\n      this.bgColor,\n      this.bgColorRgb,\n      this.setBgColor,\n      this.setBgColorFp,\n    ] = genColorToolset('bgColor');\n    [\n      this.headerColor,\n      this.headerColorRgb,\n      this.setHeaderColor,\n      this.setHeaderColorFp,\n    ] = genColorToolset('headerColor');\n    [\n      this.bottomBarColor,\n      this.bottomBarColorRgb,\n      this.setBottomBarColor,\n      this.setBottomBarColorFp,\n    ] = genColorToolset('bottomBarColor');\n    //#endregion\n\n    //#region Other methods.\n    const withBasicEither = createWithChecksFp({ isTma, returns: 'either' });\n    this.closeFp = withBasicEither(returnBack => {\n      return postEvent('web_app_close', { return_back: returnBack });\n    });\n    this.close = throwifyWithChecksFp(this.closeFp);\n\n    this.readyFp = withBasicEither(() => postEvent('web_app_ready'));\n    this.ready = throwifyWithChecksFp(this.readyFp);\n    //#endregion\n  }\n\n  //#region Other properties.\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * True if the current Mini App background color is recognized as dark.\n   */\n  readonly isDark = computed(() => {\n    const color = this.bgColorRgb();\n    return color ? isColorDark(color) : false;\n  });\n\n  /**\n   * Signal indicating if the mini app is currently active.\n   */\n  readonly isActive: Computed<boolean>;\n\n  /**\n   * Complete component state.\n   */\n  readonly state: Computed<MiniAppState>;\n  //#endregion\n\n  //#region CSS variables.\n  /**\n   * True if the CSS variables are currently bound.\n   */\n  readonly isCssVarsBound: Computed<boolean>;\n\n  /**\n   * Creates CSS variables connected with the mini app.\n   *\n   * Default variables:\n   * - `--tg-bg-color`\n   * - `--tg-header-color`\n   * - `--tg-bottom-bar-color`\n   *\n   * Variables are being automatically updated if theme parameters were changed.\n   *\n   * @param getCSSVarName - function, returning complete CSS variable name for the specified\n   * mini app key.\n   * @returns Function to stop updating variables.\n   * @example Using no arguments\n   * miniApp.bindCssVars();\n   * @example Using custom CSS vars generator\n   * miniApp.bindCssVars(key => `--my-prefix-${key}`);\n   */\n  readonly bindCssVarsFp: WithChecksFp<\n    (getCssVarName?: MiniAppGetCssVarNameFn) => E.Either<CSSVarsBoundError, VoidFunction>,\n    false\n  >;\n\n  readonly bindCssVars: WithChecks<(getCssVarName?: MiniAppGetCssVarNameFn) => VoidFunction, false>;\n  //#endregion\n\n  //#region Mounting.\n  /**\n   * Signal indicating if the component is mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component.\n   *\n   * This function restores the component state and is automatically saving it in the local storage\n   * if it changed.\n   * @since Mini Apps v6.1\n   */\n  readonly mountFp: WithChecksFp<() => void, false>;\n\n  /**\n   * @see mount\n   */\n  readonly mount: WithChecks<() => void, false>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n  //#endregion\n\n  //#region Background color.\n  /**\n   * The Mini App background color.\n   *\n   * Represents an RGB color, or theme parameters key, like \"bg_color\", \"secondary_bg_color\", etc.\n   *\n   * Note that using a theme parameters key, background color becomes bound to the current\n   * theme parameters, making it automatically being updated whenever theme parameters change.\n   * In order to remove this bind, use an explicit RGB color.\n   */\n  readonly bgColor: Computed<AnyColor>;\n\n  /**\n   * RGB representation of the background color.\n   *\n   * This value requires the Theme Params component to be mounted to extract a valid RGB value\n   * of the color key.\n   */\n  readonly bgColorRgb: Computed<RGB | undefined>;\n\n  /**\n   * Updates the mini app background color.\n   * @since Mini Apps v6.1\n   */\n  readonly setBgColorFp: WithChecksFp<\n    (color: AnyColor) => E.Either<PostEventError | UnknownThemeParamsKeyError, void>,\n    true\n  >;\n\n  /**\n   * @see setBgColorFp\n   */\n  readonly setBgColor: WithChecks<(color: AnyColor) => void, true>;\n  //#endregion\n\n  //#region Header color.\n  /**\n   * The Mini App header color.\n   */\n  readonly headerColor: Computed<AnyColor>;\n\n  /**\n   * RGB representation of the header color.\n   *\n   * This value requires the Theme Params component to be mounted to extract a valid RGB value\n   * of the color key.\n   */\n  readonly headerColorRgb: Computed<RGB | undefined>;\n\n  /**\n   * Updates the mini app header color.\n   * @since Mini Apps v6.1\n   */\n  readonly setHeaderColorFp: WithChecksFp<\n    (color: AnyColor) => E.Either<PostEventError | UnknownThemeParamsKeyError, void>,\n    true,\n    'rgb'\n  >;\n\n  /**\n   * @see setHeaderColorFp\n   */\n  readonly setHeaderColor: WithChecks<(color: AnyColor) => void, true, 'rgb'>;\n  //#endregion\n\n  //#region Bottom bar background color.\n  /**\n   * The Mini App bottom bar background color.\n   */\n  readonly bottomBarColor: Computed<AnyColor>;\n\n  /**\n   * RGB representation of the bottom bar background color.\n   *\n   * This value requires the Theme Params component to be mounted to extract a valid RGB value\n   * of the color key.\n   */\n  readonly bottomBarColorRgb: Computed<RGB | undefined>;\n\n  /**\n   * Updates the mini app bottom bar bg color.\n   * @since Mini Apps v7.10\n   */\n  readonly setBottomBarColorFp: WithChecksFp<\n    (color: AnyColor) => E.Either<PostEventError | UnknownThemeParamsKeyError, void>,\n    true\n  >;\n\n  /**\n   * @see setBottomBarColorFp\n   */\n  readonly setBottomBarColor: WithChecks<(color: AnyColor) => void, true>;\n  //#endregion\n\n  //#region Other methods.\n  /**\n   * Closes the Mini App.\n   * @param returnBack - should the client return to the previous activity.\n   */\n  readonly closeFp: WithChecksFp<(returnBack?: boolean) => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see closeFp\n   */\n  readonly close: WithChecks<(returnBack?: boolean) => void, false>;\n\n  /**\n   * Informs the Telegram app that the Mini App is ready to be displayed.\n   *\n   * It is recommended to call this method as early as possible, as soon as all\n   * essential interface elements loaded.\n   *\n   * Once this method is called, the loading placeholder is hidden and the Mini\n   * App shown.\n   *\n   * If the method is not called, the placeholder will be hidden only when the\n   * page was fully loaded.\n   */\n  readonly readyFp: WithChecksFp<() => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see readyFp\n   */\n  readonly ready: WithChecks<() => void, false>;\n  //#endregion\n}\n","import { on, off } from '@tma.js/bridge';\nimport { function as fn } from 'fp-ts';\n\nimport { MiniApp, type MiniAppState } from '@/features/MiniApp/MiniApp.js';\nimport { themeParams } from '@/features/ThemeParams/instance.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new MiniApp({\n    ...fn.pipe(\n      sharedFeatureOptions(),\n      withPostEvent,\n      withVersion,\n      withStateRestore<MiniAppState>('miniApp'),\n    ),\n    offVisibilityChanged(listener) {\n      off('visibility_changed', listener);\n    },\n    onVisibilityChanged(listener) {\n      on('visibility_changed', listener);\n    },\n    theme: themeParams.state,\n  });\n}\n\nexport const miniApp = /* @__PURE__*/ instantiate();\n","import type { PopupParams, PopupButton } from '@tma.js/bridge';\nimport { either as E } from 'fp-ts';\n\nimport { InvalidArgumentsError } from '@/errors.js';\nimport type { ShowOptions } from '@/features/Popup/types.js';\n\n/**\n * Prepares popup parameters before sending them to native app.\n * @param params - popup parameters.\n */\nexport function prepareParams(params: ShowOptions): E.Either<InvalidArgumentsError, PopupParams> {\n  const message = params.message.trim();\n  const title = (params.title || '').trim();\n  const paramsButtons = params.buttons || [];\n\n  if (title.length > 64) {\n    return E.left(new InvalidArgumentsError(`Invalid title: ${title}`));\n  }\n  if (!message || message.length > 256) {\n    return E.left(new InvalidArgumentsError(`Invalid message: ${message}`));\n  }\n  if (paramsButtons.length > 3) {\n    return E.left(new InvalidArgumentsError(`Invalid buttons count: ${paramsButtons.length}`));\n  }\n\n  const buttons: PopupButton[] = [];\n  if (!paramsButtons.length) {\n    buttons.push({ type: 'close', id: '' });\n  } else {\n    for (let i = 0; i < paramsButtons.length; i++) {\n      const button = paramsButtons[i];\n      const id = button.id || '';\n      if (id.length > 64) {\n        return E.left(new InvalidArgumentsError(`Button with index ${i} has invalid id: ${id}`));\n      }\n\n      if (!button.type || button.type === 'default' || button.type === 'destructive') {\n        const text = button.text.trim();\n        if (!text || text.length > 64) {\n          return E.left(new InvalidArgumentsError(`Button with index ${i} has invalid text: ${text}`));\n        }\n        buttons.push({ type: button.type, text, id });\n      } else {\n        buttons.push({ type: button.type, id });\n      }\n    }\n  }\n\n  return E.right({ title, message, buttons });\n}\n","import type { RequestError } from '@tma.js/bridge';\nimport { type Computed, signal, computed } from '@tma.js/signals';\nimport type { BetterPromise } from 'better-promises';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport { ConcurrentCallError, type InvalidArgumentsError } from '@/errors.js';\nimport { prepareParams } from '@/features/Popup/prepareParams.js';\nimport type { ShowOptions } from '@/features/Popup/types.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithRequest } from '@/fn-options/withRequest.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecksFp, type WithChecks } from '@/with-checks/withChecksFp.js';\n\nexport interface PopupOptions extends SharedFeatureOptions, WithVersion, WithRequest {\n}\n\n/**\n * @since Mini Apps v6.2\n */\nexport class Popup {\n  constructor({ version, isTma, request }: PopupOptions) {\n    const isOpened = signal(false);\n    const toggleClosed = () => {\n      isOpened.set(false);\n    };\n\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      isTma,\n      requires: 'web_app_open_popup',\n      returns: 'task',\n    });\n\n    this.isSupported = createIsSupportedSignal('web_app_open_popup', version);\n    this.isOpened = computed(isOpened);\n    this.showFp = wrapSupportedTask(options => {\n      return fn.pipe(\n        this.isOpened()\n          ? TE.left(new ConcurrentCallError('A popup is already opened'))\n          : TE.right(undefined as never),\n        TE.chainW(() => TE.fromEither(prepareParams(options))),\n        TE.chain(preparedOptions => {\n          isOpened.set(true);\n          return request('web_app_open_popup', 'popup_closed', {\n            ...options,\n            params: preparedOptions,\n          });\n        }),\n        TE.mapBoth(\n          err => {\n            toggleClosed();\n            return err;\n          },\n          response => {\n            toggleClosed();\n            return response.button_id;\n          },\n        ),\n      );\n    });\n    this.show = throwifyWithChecksFp(this.showFp);\n  }\n\n  /**\n   * Signal indicating if any popup is currently opened.\n   */\n  readonly isOpened: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * A method that shows a native popup described by the `params` argument.\n   * The promise will be resolved when the popup is closed. Resolved value will have\n   * an identifier of the pressed button.\n   *\n   * If a user clicked outside the popup or clicked the top right popup close\n   * button, null will be resolved.\n   *\n   * @param options - popup parameters.\n   * @since Mini Apps v6.2\n   * @example\n   * fn.pipe(\n   *   popup.showFp({\n   *     title: 'Confirm action',\n   *     message: 'Do you really want to buy this burger?',\n   *     buttons: [\n   *       { id: 'yes', text: 'Yes' },\n   *       { id: 'no', type: 'destructive', text: 'No' },\n   *     ],\n   *   }),\n   *   TE.map(buttonId => {\n   *     console.log('User clicked a button with ID', buttonId);\n   *   }),\n   * );\n   */\n  readonly showFp: WithChecksFp<\n    (options: ShowOptions) => TE.TaskEither<\n      RequestError | InvalidArgumentsError | ConcurrentCallError,\n      string | undefined\n    >,\n    true\n  >;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<(options: ShowOptions) => BetterPromise<string | undefined>, true>;\n}\n","import { function as fn } from 'fp-ts';\n\nimport { Popup } from '@/features/Popup/Popup.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new Popup(fn.pipe(sharedFeatureOptions(), withRequest, withVersion));\n}\n\nexport const popup = /* @__PURE__*/ instantiate();\n","import type { PhoneRequestedStatus, RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nexport type RequestPhoneAccessError = RequestError;\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    options?: AsyncOptions,\n  ): TE.TaskEither<RequestPhoneAccessError, PhoneRequestedStatus> => {\n    return fn.pipe(\n      request('web_app_request_phone', 'phone_requested', options),\n      TE.map(response => response.status),\n    );\n  }, { ...rest, requires: 'web_app_request_phone', returns: 'task' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withRequest,\n  ));\n}\n\n/**\n * Requests current user phone access. Method returns promise, which resolves\n * status of the request. In case, user accepted the request, Mini App bot will receive\n * the according notification.\n *\n * To obtain the retrieved information instead, utilize the `requestContact` method.\n * @param options - additional options.\n * @since Mini Apps v6.9\n * @see requestContact\n */\nexport const requestPhoneAccessFp = instantiate();\n\n/**\n * @see requestPhoneAccessFp\n */\nexport const requestPhoneAccess = throwifyWithChecksFp(requestPhoneAccessFp);\n","import { PhoneRequestedStatus } from '@tma.js/bridge';\nimport { BetterTaskEither, type BetterTaskEitherError } from '@tma.js/toolkit';\nimport { pipeJsonToSchema, pipeQueryToSchema } from '@tma.js/transformers';\nimport { either as E, taskEither as TE, function as fn } from 'fp-ts';\nimport {\n  safeParse,\n  pipe as valiPipe,\n  date,\n  looseObject,\n  number,\n  optional,\n  string,\n  transform,\n} from 'valibot';\n\nimport { AccessDeniedError, ValidationError } from '@/errors.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\n\nimport {\n  withInvokeCustomMethod,\n  type WithInvokeCustomMethod,\n  InvokeCustomMethodError,\n} from '@/fn-options/withInvokeCustomMethod.js';\n\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\n\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\nimport { type RequestPhoneAccessError, requestPhoneAccessFp } from './requestPhoneAccess.js';\n\n/**\n * Requested contact information.\n */\nexport interface RequestedContact {\n  contact: {\n    user_id: number;\n    phone_number: string;\n    first_name: string;\n    last_name?: string;\n    [key: string]: unknown;\n  };\n  auth_date: Date;\n  hash: string;\n  [key: string]: unknown;\n}\n\n/**\n * Requested contact complete data.\n */\nexport interface RequestedContactCompleteData {\n  /**\n   * Raw original representation of the contact data returned from the Telegram server.\n   */\n  raw: string;\n  /**\n   * Parsed representation of the contact data.\n   */\n  parsed: RequestedContact;\n}\n\ninterface CreateCompleteOptions extends SharedFeatureOptions, WithInvokeCustomMethod, WithVersion {\n  requestPhoneAccess: (options?: AsyncOptions) => (\n    TE.TaskEither<RequestPhoneAccessError, PhoneRequestedStatus>\n  );\n}\n\ninterface CreateParsedOptions extends SharedFeatureOptions, WithVersion {\n  requestContact: (options?: AsyncOptions) => TE.TaskEither<RequestContactError, RequestedContact>;\n}\n\nexport type RequestContactError =\n  | InvokeCustomMethodError\n  | AccessDeniedError\n  | ValidationError\n  | BetterTaskEitherError;\n\nfunction createComplete({\n  invokeCustomMethod,\n  requestPhoneAccess,\n  ...rest\n}: CreateCompleteOptions) {\n  type GetRequestedContactError = InvokeCustomMethodError | ValidationError;\n\n  // Attempts to get previously requested contact.\n  const getContact = (\n    options?: AsyncOptions,\n  ): TE.TaskEither<GetRequestedContactError, RequestedContactCompleteData | undefined> => {\n    return fn.pipe(\n      invokeCustomMethod('getRequestedContact', {}, {\n        ...options,\n        timeout: (options || {}).timeout || 5000,\n      }),\n      TE.chainW(response => {\n        const toStringResult = safeParse(string(), response);\n        if (!toStringResult.success) {\n          return TE.left(new ValidationError(response, toStringResult.issues));\n        }\n\n        if (!toStringResult.output) {\n          return TE.right(undefined);\n        }\n\n        const toParsedResult = safeParse(\n          pipeQueryToSchema(\n            looseObject({\n              contact: pipeJsonToSchema(looseObject({\n                user_id: number(),\n                phone_number: string(),\n                first_name: string(),\n                last_name: optional(string()),\n              })),\n              auth_date: valiPipe(\n                string(),\n                transform(input => new Date(Number(input) * 1000)),\n                date(),\n              ),\n              hash: string(),\n            }),\n          ),\n          toStringResult.output,\n        );\n        return toParsedResult.success\n          ? TE.right({ raw: toStringResult.output, parsed: toParsedResult.output })\n          : TE.left(new ValidationError(toStringResult.output, toParsedResult.issues));\n      }),\n    );\n  };\n\n  // Attempts to get previously requested contact, but ignores all errors except validation error.\n  const getContactWithErrorsIgnore = (\n    options?: AsyncOptions,\n  ): TE.TaskEither<ValidationError, RequestedContactCompleteData | undefined> => {\n    return fn.pipe(\n      getContact(options),\n      TE.match(\n        // All other errors except validation ones should be ignored. Receiving validation error\n        // means that we have some data, but we are unable to parse it properly. So, there is no\n        // need to make some more requests further, the problem is local.\n        error => (ValidationError.is(error) ? E.left(error) : E.right(undefined)),\n        contact => E.right(contact),\n      ),\n    );\n  };\n\n  // Polls previously requested contact with increasing timeout between requests.\n  const pollContact = (ctx: {\n    isRejected: boolean;\n    rejectReason: unknown;\n    abortSignal: AbortSignal;\n  }): TE.TaskEither<BetterTaskEitherError | ValidationError, RequestedContactCompleteData> => {\n    return BetterTaskEither<ValidationError, RequestedContactCompleteData>(\n      async (res, rej, context) => {\n        // Time to wait before executing the next request.\n        let sleepTime = 50;\n\n        // We are trying to retrieve the requested contact until the deadline was reached.\n        while (!context.isRejected) {\n          const result = await getContactWithErrorsIgnore(context)();\n          if (result._tag === 'Left') {\n            return rej(result.left);\n          }\n          if (result.right) {\n            return res(result.right);\n          }\n          await new Promise(resolve => setTimeout(resolve, sleepTime));\n          sleepTime += 50;\n        }\n      },\n      ctx,\n    );\n  };\n\n  return withChecksFp((\n    options?: AsyncOptions,\n  ): TE.TaskEither<RequestContactError, RequestedContactCompleteData> => {\n    return BetterTaskEither.fn(context => {\n      return fn.pipe(\n        // Try to get the requested contact. Probably, we already requested it before.\n        getContactWithErrorsIgnore(context),\n        TE.chain(contact => {\n          if (contact) {\n            return TE.right(contact);\n          }\n          return fn.pipe(\n            requestPhoneAccess(context),\n            TE.chainW(status => {\n              return status === 'sent'\n                ? pollContact(context)\n                : TE.left(new AccessDeniedError('User denied access'));\n            }),\n          );\n        }),\n      );\n    }, options);\n  }, { ...rest, returns: 'task', requires: 'web_app_request_phone' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiateComplete() {\n  return createComplete({\n    ...fn.pipe(sharedFeatureOptions(), withInvokeCustomMethod, withVersion),\n    requestPhoneAccess: requestPhoneAccessFp,\n  });\n}\n\nfunction createParsed({ requestContact, ...rest }: CreateParsedOptions) {\n  return withChecksFp(\n    requestContact,\n    { ...rest, returns: 'task', requires: 'web_app_request_phone' },\n  );\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiateParsed() {\n  return createParsed({\n    ...fn.pipe(sharedFeatureOptions(), withVersion),\n    requestContact(options) {\n      return fn.pipe(\n        requestContactCompleteFp(options),\n        TE.map(contact => contact.parsed),\n      );\n    },\n  });\n}\n\n/**\n * Requests current user contact information.\n *\n * This function returns an object, containing both raw and parsed representations of a response,\n * received from the Telegram client.\n * @param options - additional options.\n * @since Mini Apps v6.9\n */\nexport const requestContactCompleteFp = instantiateComplete();\n\n/**\n * @see requestContactCompleteFp\n */\nexport const requestContactComplete = throwifyWithChecksFp(requestContactCompleteFp);\n\n/**\n * Works the same way as the `requestContactCompleteFp` function, but returns only parsed\n * representation of the contact data.\n * @see requestContactCompleteFp\n * @param options - additional options.\n * @since Mini Apps v6.9\n */\nexport const requestContactFp = instantiateParsed();\n\n/**\n * @see requestContactFp\n */\nexport const requestContact = throwifyWithChecksFp(requestContactFp);\n","import type { WriteAccessRequestedStatus, RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nexport type RequestWriteAccessError = RequestError;\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    options?: AsyncOptions,\n  ): TE.TaskEither<RequestWriteAccessError, WriteAccessRequestedStatus> => {\n    return fn.pipe(\n      request('web_app_request_write_access', 'write_access_requested', options),\n      TE.map(response => response.status),\n    );\n  }, { ...rest, requires: 'web_app_request_write_access', returns: 'task' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withRequest,\n  ));\n}\n\n/**\n * Requests write message access to the current user.\n * @param options - additional options.\n * @since Mini Apps v6.9\n */\nexport const requestWriteAccessFp = instantiate();\n\n/**\n * @see requestWriteAccessFp\n */\nexport const requestWriteAccess = throwifyWithChecksFp(requestWriteAccessFp);\n","import type { PostEventError } from '@tma.js/bridge';\nimport { computed, type Computed, signal } from '@tma.js/signals';\nimport { createCbCollector, BetterTaskEither, type BetterTaskEitherError } from '@tma.js/toolkit';\nimport { BetterPromise } from 'better-promises';\nimport { either as E, taskEither as TE, function as fn } from 'fp-ts';\n\nimport { ConcurrentCallError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport interface QrScannerOptions extends WithVersion, WithPostEvent, SharedFeatureOptions {\n  /**\n   * A function to add a listener to the event determining if the QR scanner\n   * was closed.\n   * @param listener - a listener to add.\n   * @returns A function to remove the listener.\n   */\n  onClosed: (listener: VoidFunction) => VoidFunction;\n  /**\n   * A function to add a listener to the event containing a scanned QR content.\n   * @param listener - a listener to add.\n   * @returns A function to remove the listener.\n   */\n  onTextReceived: (listener: (data: string) => void) => VoidFunction;\n}\n\ninterface SharedOptions extends AsyncOptions {\n  /**\n   * Title to be displayed in the scanner.\n   */\n  text?: string;\n}\n\ninterface CaptureOptions extends SharedOptions {\n  /**\n   * @returns True if the passed QR code should be captured.\n   * @param qr - scanned QR content.\n   */\n  capture: (qr: string) => boolean;\n}\n\ninterface OpenOptions extends SharedOptions {\n  /**\n   * Function which will be called if a QR code was scanned.\n   * @param qr - scanned QR content.\n   */\n  onCaptured: (qr: string) => void;\n}\n\n/**\n * @since Mini Apps v6.4\n */\nexport class QrScanner {\n  constructor({\n    version,\n    onClosed,\n    onTextReceived,\n    isTma,\n    postEvent,\n  }: QrScannerOptions) {\n    const wrapOptions = { version, requires: 'web_app_open_scan_qr_popup', isTma } as const;\n    const wrapSupportedEither = createWithChecksFp({ ...wrapOptions, returns: 'either' });\n    const wrapSupportedTask = createWithChecksFp({ ...wrapOptions, returns: 'task' });\n\n    const isOpened = signal(false);\n    const setClosed = () => {\n      isOpened.set(false);\n    };\n\n    this.isSupported = createIsSupportedSignal('web_app_open_scan_qr_popup', version);\n    this.isOpened = computed(isOpened);\n\n    this.captureFp = wrapSupportedTask(options => {\n      let captured: string | undefined;\n      return fn.pipe(\n        this.openFp({\n          ...options,\n          onCaptured: qr => {\n            if (options.capture(qr)) {\n              captured = qr;\n              this.close();\n            }\n          },\n        }),\n        TE.map(() => captured),\n      );\n    });\n    this.closeFp = wrapSupportedEither(() => {\n      return fn.pipe(postEvent('web_app_close_scan_qr_popup'), E.map(setClosed));\n    });\n    this.openFp = wrapSupportedTask(options => {\n      return fn.pipe(\n        isOpened()\n          ? TE.left(new ConcurrentCallError('The QR Scanner is already opened'))\n          : async () => postEvent('web_app_open_scan_qr_popup', { text: options.text }),\n        TE.chainW(() => {\n          isOpened.set(true);\n          const [addToCleanup, cleanup] = createCbCollector();\n          const onSettled = <T>(value: T): T => {\n            cleanup();\n            isOpened.set(false);\n            return value;\n          };\n\n          return fn.pipe(\n            BetterTaskEither<never, void>(resolve => {\n              addToCleanup(\n                // The scanner was closed externally.\n                onClosed(resolve),\n                // The scanner was closed internally.\n                isOpened.sub(isOpenedValue => {\n                  if (!isOpenedValue) {\n                    resolve();\n                  }\n                }),\n                onTextReceived(options.onCaptured),\n              );\n            }, options),\n            TE.mapBoth(onSettled, onSettled),\n          );\n        }),\n      );\n    });\n\n    this.open = throwifyWithChecksFp(this.openFp);\n    this.capture = throwifyWithChecksFp(this.captureFp);\n    this.close = throwifyWithChecksFp(this.closeFp);\n  }\n\n  /**\n   * Signal indicating if the scanner is currently opened.\n   */\n  readonly isOpened: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Opens the scanner and returns a task which will be completed with the QR content if the\n   * passed `capture` function returned true.\n   *\n   * Task may also be completed with undefined if the scanner was closed.\n   * @param options - method options.\n   * @returns A promise with QR content presented as string or undefined if the scanner was closed.\n   * @since Mini Apps v6.4\n   * @example\n   * fn.pipe(\n   *   qrScanner.captureFp({\n   *     capture(scannedQr) {\n   *       return scannedQr === 'any expected by me qr';\n   *     }\n   *   }),\n   *   TE.match(\n   *     error => {\n   *       console.error(error);\n   *     },\n   *     qr => {\n   *       console.log('My QR:'), qr;\n   *     }\n   *   ),\n   * );\n   */\n  readonly captureFp: WithChecksFp<\n    (options: CaptureOptions) => (\n      TE.TaskEither<PostEventError | BetterTaskEitherError, string | undefined>\n    ),\n    true\n  >;\n\n  /**\n   * @see captureFp\n   */\n  readonly capture: WithChecks<\n    (options: CaptureOptions) => BetterPromise<string | undefined>,\n    true\n  >;\n\n  /**\n   * Closes the scanner.\n   * @since Mini Apps v6.4\n   */\n  readonly closeFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see close\n   */\n  readonly close: WithChecks<() => void, true>;\n\n  /**\n   * Opens the scanner and returns a task which will be completed when the scanner was closed.\n   * @param options - method options.\n   * @since Mini Apps v6.4\n   * @example Without `capture` option\n   * if (qrScanner.open.isAvailable()) {\n   *   const qr = await qrScanner.open({ text: 'Scan any QR' });\n   * }\n   * @example\n   * fn.pipe(\n   *   qrScanner.openFp({\n   *     onCaptured(scannedQr) {\n   *       if (scannedQr === 'any expected by me qr') {\n   *         qrScanner.close();\n   *       }\n   *     }\n   *   }),\n   *   TE.match(\n   *     error => {\n   *       console.error(error);\n   *     },\n   *     () => {\n   *       console.log('The scanner was closed');\n   *     }\n   *   ),\n   * );\n   */\n  readonly openFp: WithChecksFp<\n    (options: OpenOptions) => TE.TaskEither<PostEventError, void>,\n    true\n  >;\n\n  /**\n   * @see openFp\n   */\n  readonly open: WithChecks<(options: OpenOptions) => BetterPromise<void>, true>;\n}\n","import { on } from '@tma.js/bridge';\nimport { function as fn } from 'fp-ts';\n\nimport { QrScanner } from '@/features/QrScanner/QrScanner.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new QrScanner({\n    ...fn.pipe(sharedFeatureOptions(), withPostEvent, withVersion),\n    onClosed(listener) {\n      return on('scan_qr_popup_closed', listener);\n    },\n    onTextReceived(listener) {\n      return on('qr_text_received', event => {\n        listener(event.data);\n      });\n    },\n  });\n}\n\nexport const qrScanner = /* @__PURE__*/ instantiate();\n","import type { PostEventError, SecondaryButtonPosition } from '@tma.js/bridge';\nimport { computed, type Computed } from '@tma.js/signals';\nimport type { RGB } from '@tma.js/types';\nimport { either as E } from 'fp-ts';\n\nimport { Button, type ButtonOptions } from '@/composables/Button.js';\nimport { access } from '@/helpers/access.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport type { MaybeAccessor } from '@/types.js';\nimport type { WithChecks, WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype SecondaryButtonEither = E.Either<PostEventError, void>;\n\nexport interface SecondaryButtonState {\n  isVisible: boolean;\n  bgColor?: RGB;\n  hasShineEffect: boolean;\n  isEnabled: boolean;\n  isLoaderVisible: boolean;\n  text: string;\n  textColor?: RGB;\n  position: SecondaryButtonPosition;\n}\n\nexport interface SecondaryButtonOptions extends Omit<\n  ButtonOptions<SecondaryButtonState, 'web_app_setup_secondary_button'>,\n  'initialState' | 'method' | 'payload'\n> {\n  /**\n   * Default values for different kinds of the button properties.\n   */\n  defaults: {\n    bgColor: MaybeAccessor<RGB>;\n    textColor: MaybeAccessor<RGB>;\n  };\n}\n\n/**\n * @since Mini Apps v7.10\n */\nexport class SecondaryButton {\n  constructor({ defaults, ...options }: SecondaryButtonOptions) {\n    const button = new Button({\n      ...options,\n      initialState: {\n        hasShineEffect: false,\n        isEnabled: true,\n        isLoaderVisible: false,\n        isVisible: false,\n        text: 'Cancel',\n        position: 'left',\n      },\n      method: 'web_app_setup_secondary_button',\n      payload: state => ({\n        has_shine_effect: state.hasShineEffect,\n        is_visible: state.isVisible,\n        is_active: state.isEnabled,\n        is_progress_visible: state.isLoaderVisible,\n        text: state.text,\n        color: state.bgColor,\n        text_color: state.textColor,\n        position: state.position,\n      }),\n    });\n\n    const withDefault = (\n      field: 'bgColor' | 'textColor',\n      getDefault: MaybeAccessor<RGB>,\n    ) => {\n      const fromState = button.stateGetter(field);\n      return computed(() => fromState() || access(getDefault));\n    };\n\n    this.isSupported = createIsSupportedSignal('web_app_setup_secondary_button', options.version);\n    this.bgColor = withDefault('bgColor', defaults.bgColor);\n    this.textColor = withDefault('textColor', defaults.textColor);\n    this.position = button.stateGetter('position');\n    this.hasShineEffect = button.stateGetter('hasShineEffect');\n    this.isEnabled = button.stateGetter('isEnabled');\n    this.isLoaderVisible = button.stateGetter('isLoaderVisible');\n    this.text = button.stateGetter('text');\n    this.isVisible = button.stateGetter('isVisible');\n    this.isMounted = button.isMounted;\n    this.state = button.state;\n\n    [this.setPosition, this.setPositionFp] = button.stateSetters('position');\n    [this.setBgColor, this.setBgColorFp] = button.stateSetters('bgColor');\n    [this.setTextColor, this.setTextColorFp] = button.stateSetters('textColor');\n    [\n      [this.disableShineEffect, this.disableShineEffectFp],\n      [this.enableShineEffect, this.enableShineEffectFp],\n    ] = button.stateBoolSetters('hasShineEffect');\n    [\n      [this.disable, this.disableFp],\n      [this.enable, this.enableFp],\n    ] = button.stateBoolSetters('isEnabled');\n    [\n      [this.hideLoader, this.hideLoaderFp],\n      [this.showLoader, this.showLoaderFp],\n    ] = button.stateBoolSetters('isLoaderVisible');\n\n    [this.setText, this.setTextFp] = button.stateSetters('text');\n    [[this.hide, this.hideFp], [this.show, this.showFp]] = button.stateBoolSetters('isVisible');\n    this.setParams = button.setState;\n    this.setParamsFp = button.setStateFp;\n    this.onClick = button.onClick;\n    this.onClickFp = button.onClickFp;\n    this.offClick = button.offClick;\n    this.offClickFp = button.offClickFp;\n    this.mount = button.mount;\n    this.mountFp = button.mountFp;\n    this.unmount = button.unmount;\n  }\n\n  //#region Properties.\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * The button position relative to the main one.\n   */\n  readonly position: Computed<SecondaryButtonPosition>;\n\n  /**\n   * The button background color.\n   */\n  readonly bgColor: Computed<RGB>;\n\n  /**\n   * True if the button has a shining effect.\n   */\n  readonly hasShineEffect: Computed<boolean>;\n\n  /**\n   * True if the button is clickable.\n   */\n  readonly isEnabled: Computed<boolean>;\n\n  /**\n   * True if the button loader is visible.\n   */\n  readonly isLoaderVisible: Computed<boolean>;\n\n  /**\n   * True if the button is visible.\n   */\n  readonly isVisible: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * The complete button state.\n   */\n  readonly state: Computed<SecondaryButtonState>;\n\n  /**\n   * The button displayed text.\n   */\n  readonly text: Computed<string>;\n\n  /**\n   * The button text color.\n   *\n   * Note that this value is computed based on the external defaults. For\n   * example, if not explicitly set, this value may be equal to one of theme\n   * params colors.\n   */\n  readonly textColor: Computed<RGB>;\n  //#endregion\n\n  //#region Methods.\n  /**\n   * Shows the button.\n   * @since Mini Apps v7.10\n   */\n  readonly showFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<() => void, true>;\n\n  /**\n   * Hides the button.\n   * @since Mini Apps v7.10\n   */\n  readonly hideFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see hideFp\n   */\n  readonly hide: WithChecks<() => void, true>;\n\n  /**\n   * Enables the button.\n   * @since Mini Apps v7.10\n   */\n  readonly enableFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see enableFp\n   */\n  readonly enable: WithChecks<() => void, true>;\n\n  /**\n   * Enables the button.\n   * @since Mini Apps v7.10\n   */\n  readonly enableShineEffectFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see enableShineEffectFp\n   */\n  readonly enableShineEffect: WithChecks<() => void, true>;\n\n  /**\n   * Disables the button.\n   * @since Mini Apps v7.10\n   */\n  readonly disableFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see disableFp\n   */\n  readonly disable: WithChecks<() => void, true>;\n\n  /**\n   * Enables the button.\n   * @since Mini Apps v7.10\n   */\n  readonly disableShineEffectFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see disableShineEffectFp\n   */\n  readonly disableShineEffect: WithChecks<() => void, true>;\n\n  /**\n   * Updates the button background color.\n   * @since Mini Apps v7.10\n   */\n  readonly setBgColorFp: WithChecksFp<(value: RGB) => SecondaryButtonEither, true>;\n\n  /**\n   * @see setBgColorFp\n   */\n  readonly setBgColor: WithChecks<(value: RGB) => void, true>;\n\n  /**\n   * Updates the button text color.\n   * @since Mini Apps v7.10\n   */\n  readonly setTextColorFp: WithChecksFp<(value: RGB) => SecondaryButtonEither, true>;\n\n  /**\n   * @see setTextColorFp\n   */\n  readonly setTextColor: WithChecks<(value: RGB) => void, true>;\n\n  /**\n   * Updates the button text.\n   * @since Mini Apps v7.10\n   */\n  readonly setTextFp: WithChecksFp<(value: string) => SecondaryButtonEither, true>;\n\n  /**\n   * @see setTextFp\n   */\n  readonly setText: WithChecks<(value: string) => void, true>;\n\n  /**\n   * Updates the button position.\n   * @since Mini Apps v7.10\n   */\n  readonly setPositionFp: WithChecksFp<\n    (position: SecondaryButtonPosition) => SecondaryButtonEither,\n    true\n  >;\n\n  /**\n   * @see setPositionFp\n   */\n  readonly setPosition: WithChecks<(position: SecondaryButtonPosition) => void, true>;\n\n  /**\n   * Shows the button loader.\n   * @since Mini Apps v7.10\n   */\n  readonly showLoaderFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see showLoaderFp\n   */\n  readonly showLoader: WithChecks<() => void, true>;\n\n  /**\n   * Hides the button loader.\n   * @since Mini Apps v7.10\n   */\n  readonly hideLoaderFp: WithChecksFp<() => SecondaryButtonEither, true>;\n\n  /**\n   * @see hideLoaderFp\n   */\n  readonly hideLoader: WithChecks<() => void, true>;\n\n  /**\n   * Updates the button state.\n   * @param state - updates to apply.\n   * @since Mini Apps v7.10\n   * @example\n   * button.setParams({\n   *   text: 'Submit',\n   *   isEnabled: true,\n   *   hasShineEffect: true,\n   * });\n   */\n  readonly setParamsFp: WithChecksFp<\n    (state: Partial<SecondaryButtonState>) => SecondaryButtonEither,\n    true\n  >;\n\n  /**\n   * @see setParamsFp\n   */\n  readonly setParams: WithChecks<(state: Partial<SecondaryButtonState>) => void, true>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v7.10\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @since Mini Apps v7.10\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * @see onClick\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @since Mini Apps v7.10\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<(listener: VoidFunction, once?: boolean) => void, true>;\n\n  /**\n   * @see offClick\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, true>;\n  //#endregion\n}\n","import { computed } from '@tma.js/signals';\n\nimport { miniApp } from '@/features/MiniApp/instance.js';\nimport { SecondaryButton } from '@/features/SecondaryButton/SecondaryButton.js';\nimport { themeParams } from '@/features/ThemeParams/instance.js';\nimport { bottomButtonOptions } from '@/fn-options/bottomButtonOptions.js';\n\nfunction instantiate() {\n  return new SecondaryButton(\n    bottomButtonOptions('secondaryButton', 'secondary_button_pressed', {\n      bgColor: computed(() => miniApp.bottomBarColorRgb() || '#000000'),\n      textColor: computed(() => themeParams.buttonColor() || '#2481cc'),\n    }),\n  );\n}\n\nexport const secondaryButton = /* @__PURE__*/ instantiate();\n","import { EventPayload, type MethodParams, type Request2CaptureFn, RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport { SecureStorageMethodError } from '@/errors.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithCreateRequestId } from '@/fn-options/withCreateRequestId.js';\nimport type { WithRequest } from '@/fn-options/withRequest.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport {\n  createWithChecksFp,\n  type WithChecks,\n  type WithChecksFp,\n} from '@/with-checks/withChecksFp.js';\n\nexport type SecureStorageError = RequestError | SecureStorageMethodError;\n\nexport interface SecureStorageOptions extends SharedFeatureOptions,\n  WithVersion,\n  WithRequest,\n  WithCreateRequestId {\n}\n\n/**\n * @since Mini Apps v9.0\n */\nexport class SecureStorage {\n  constructor({ isTma, request, version, createRequestId }: SecureStorageOptions) {\n    const wrapSupportedTask = createWithChecksFp({\n      version,\n      requires: 'web_app_secure_storage_get_key',\n      isTma,\n      returns: 'task',\n    });\n\n    const invokeMethod = <\n      M extends (\n        | 'web_app_secure_storage_save_key'\n        | 'web_app_secure_storage_get_key'\n        | 'web_app_secure_storage_restore_key'\n        | 'web_app_secure_storage_save_key'\n        | 'web_app_secure_storage_clear'\n      ),\n      E extends (\n        | 'secure_storage_key_saved'\n        | 'secure_storage_key_received'\n        | 'secure_storage_key_restored'\n        | 'secure_storage_cleared'\n      ),\n    >(\n      method: M,\n      event: E,\n      params: Omit<MethodParams<M>, 'req_id'>,\n    ): TE.TaskEither<SecureStorageError, EventPayload<E>> => {\n      const requestId = createRequestId();\n      return fn.pipe(\n        request<M, ('secure_storage_failed' | E)[]>(method, ['secure_storage_failed', event], {\n          params: { ...params, req_id: requestId },\n          capture: (event => {\n            return 'payload' in event ? event.payload.req_id === requestId : true;\n          }) as Request2CaptureFn<('secure_storage_failed' | E)[]>,\n        }),\n        TE.chain(response => (\n          response.event === 'secure_storage_failed'\n            ? TE.left(new SecureStorageMethodError(response.payload.error || 'UNKNOWN_ERROR'))\n            : TE.right(response.payload as EventPayload<E>)\n        )),\n      );\n    };\n\n    this.getItemFp = wrapSupportedTask(key => {\n      return fn.pipe(\n        invokeMethod('web_app_secure_storage_get_key', 'secure_storage_key_received', { key }),\n        TE.map(payload => ({\n          value: payload.value,\n          canRestore: !!payload.can_restore,\n        })),\n      );\n    });\n    this.setItemFp = wrapSupportedTask((key, value) => {\n      return fn.pipe(\n        invokeMethod('web_app_secure_storage_save_key', 'secure_storage_key_saved', { key, value }),\n        TE.map(() => undefined),\n      );\n    });\n    this.deleteItemFp = wrapSupportedTask(key => {\n      return this.setItemFp(key, null);\n    });\n    this.clearFp = wrapSupportedTask(() => {\n      return fn.pipe(\n        invokeMethod('web_app_secure_storage_clear', 'secure_storage_cleared', {}),\n        TE.map(() => undefined),\n      );\n    });\n    this.restoreItemFp = wrapSupportedTask(key => {\n      return fn.pipe(\n        invokeMethod('web_app_secure_storage_restore_key', 'secure_storage_key_restored', { key }),\n        TE.map(payload => payload.value),\n      );\n    });\n\n    this.getItem = throwifyWithChecksFp(this.getItemFp);\n    this.setItem = throwifyWithChecksFp(this.setItemFp);\n    this.deleteItem = throwifyWithChecksFp(this.deleteItemFp);\n    this.clear = throwifyWithChecksFp(this.clearFp);\n    this.restoreItem = throwifyWithChecksFp(this.restoreItemFp);\n  }\n\n  /**\n    * Retrieves an item using its key.\n    * @since Mini Apps v9.0\n    */\n  readonly getItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<SecureStorageError, {\n      value: string | null;\n      canRestore: boolean;\n    }>,\n    true\n  >;\n\n  /**\n   * @see getItemFp\n   */\n  readonly getItem: WithChecks<\n    (key: string) => Promise<{ value: string | null; canRestore: boolean }>,\n    true\n  >;\n\n  /**\n   * Restores an item from the storage.\n   * @since Mini Apps v9.0\n   */\n  readonly restoreItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<SecureStorageError, string | null>,\n    true\n  >;\n\n  /**\n   * @see restoreItemFp\n   */\n  readonly restoreItem: WithChecks<(key: string) => Promise<string | null>, true>;\n\n  /**\n    * Sets a new item in the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly setItemFp: WithChecksFp<\n    (key: string, value: string | null) => TE.TaskEither<SecureStorageError, void>,\n    true\n  >;\n\n  /**\n   * @see setItemFp\n   */\n  readonly setItem: WithChecks<(key: string, value: string | null) => Promise<void>, true>;\n\n  /**\n    * Removes a key from the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly deleteItemFp: WithChecksFp<\n    (key: string) => TE.TaskEither<SecureStorageError, void>,\n    true\n  >;\n\n  /**\n   * @see deleteItemFp\n   */\n  readonly deleteItem: WithChecks<(key: string) => Promise<void>, true>;\n\n  /**\n    * Removes all keys from the storage.\n    * @since Mini Apps v9.0\n    */\n  readonly clearFp: WithChecksFp<() => TE.TaskEither<SecureStorageError, void>, true>;\n\n  /**\n   * @see clearFp\n   */\n  readonly clear: WithChecks<() => Promise<void>, true>;\n}\n","import { function as fn } from 'fp-ts';\n\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withCreateRequestId } from '@/fn-options/withCreateRequestId.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nimport { SecureStorage } from './SecureStorage.js';\n\nfunction instantiate() {\n  return new SecureStorage(fn.pipe(\n    sharedFeatureOptions(),\n    withVersion,\n    withRequest,\n    withCreateRequestId,\n  ));\n}\n\nexport const secureStorage = /* @__PURE__*/ instantiate();\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { either as E } from 'fp-ts';\n\nimport { Button, type ButtonOptions } from '@/composables/Button.js';\nimport type { WithChecksFp, WithChecks } from '@/with-checks/withChecksFp.js';\n\nexport interface SettingsButtonState {\n  isVisible: boolean;\n}\n\nexport type SettingsButtonOptions = Omit<\n  ButtonOptions<SettingsButtonState, 'web_app_setup_settings_button'>,\n  'method' | 'payload' | 'initialState'\n>;\n\n/**\n * @since Mini Apps v6.10\n */\nexport class SettingsButton {\n  constructor(options: SettingsButtonOptions) {\n    const button = new Button({\n      ...options,\n      method: 'web_app_setup_settings_button',\n      payload: state => ({ is_visible: state.isVisible }),\n      initialState: { isVisible: false },\n    });\n\n    this.isVisible = button.stateGetter('isVisible');\n    this.isMounted = button.isMounted;\n    this.isSupported = button.isSupported;\n    [[this.hide, this.hideFp], [this.show, this.showFp]] = button.stateBoolSetters('isVisible');\n    this.onClick = button.onClick;\n    this.onClickFp = button.onClickFp;\n    this.offClick = button.offClick;\n    this.offClickFp = button.offClickFp;\n    this.mount = button.mount;\n    this.mountFp = button.mountFp;\n    this.unmount = button.unmount;\n  }\n\n  /**\n   * Signal indicating if the component is currently visible.\n   */\n  readonly isVisible: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Hides the button.\n   * @since Mini Apps v6.10\n   */\n  readonly hideFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see hideFp\n   */\n  readonly hide: WithChecks<() => void, true>;\n\n  /**\n   * Shows the button.\n   * @since Mini Apps v6.10\n   */\n  readonly showFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see showFp\n   */\n  readonly show: WithChecks<() => void, true>;\n\n  /**\n   * Adds a new button listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @returns A function to remove bound listener.\n   * @since Mini Apps v6.10\n   * @example\n   * const off = button.onClick(() => {\n   *   console.log('User clicked the button');\n   *   off();\n   * });\n   */\n  readonly onClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => VoidFunction,\n    true\n  >;\n\n  /**\n   * @see onClickFp\n   */\n  readonly onClick: WithChecks<(listener: VoidFunction, once?: boolean) => VoidFunction, true>;\n\n  /**\n   * Removes the button click listener.\n   * @param listener - event listener.\n   * @param once - should the listener be called only once.\n   * @since Mini Apps v6.10\n   * @example\n   * function listener() {\n   *   console.log('User clicked the button');\n   *   button.offClick(listener);\n   * }\n   * button.onClick(listener);\n   */\n  readonly offClickFp: WithChecksFp<\n    (listener: VoidFunction, once?: boolean) => void,\n    true\n  >;\n\n  /**\n   * @see offClickFp\n   */\n  readonly offClick: WithChecks<(listener: VoidFunction, once?: boolean) => void, true>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v6.10\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   *\n   * Note that this function does not remove listeners added via the `onClick`\n   * function, so you have to remove them on your own.\n   * @see onClick\n   */\n  readonly unmount: () => void;\n}\n","import { SettingsButton } from '@/features/SettingsButton/SettingsButton.js';\nimport { buttonOptions } from '@/fn-options/buttonOptions.js';\n\nexport const settingsButton = /* @__PURE__*/ new SettingsButton(\n  buttonOptions('settingsButton', 'settings_button_pressed'),\n);\n","import type { PostEventError } from '@tma.js/bridge';\nimport type { Computed } from '@tma.js/signals';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { Mountable } from '@/composables/Mountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport type { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport type { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport type { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport type { WithVersion } from '@/fn-options/withVersion.js';\nimport { createIsSupportedSignal } from '@/helpers/createIsSupportedSignal.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, type WithChecks, type WithChecksFp } from '@/with-checks/withChecksFp.js';\n\nexport interface SwipeBehaviorState {\n  isVerticalEnabled: boolean;\n}\n\nexport interface SwipeBehaviorOptions\n  extends WithStateRestore<SwipeBehaviorState>,\n  WithVersion,\n  WithPostEvent,\n  SharedFeatureOptions {\n}\n\n/**\n * @since Mini Apps v7.7\n */\nexport class SwipeBehavior {\n  constructor({ postEvent, storage, isTma, isPageReload, version }: SwipeBehaviorOptions) {\n    const initialState = { isVerticalEnabled: true };\n    const stateful = new Stateful({\n      initialState,\n      onChange(state) {\n        storage.set(state);\n      },\n    });\n    const mountable = new Mountable({\n      initialState,\n      isPageReload,\n      onMounted: stateful.setState,\n      restoreState: storage.get,\n    });\n\n    const wrapOptions = { requires: 'web_app_setup_swipe_behavior', isTma, version } as const;\n    const wrapSupportedPlain = createWithChecksFp({\n      ...wrapOptions,\n      returns: 'plain',\n    });\n    const wrapMountedEither = createWithChecksFp({\n      ...wrapOptions,\n      isMounted: mountable.isMounted,\n      returns: 'either',\n    });\n\n    const setVerticalEnabled = (isVerticalEnabled: boolean) => {\n      const update = { isVerticalEnabled };\n      if (!stateful.hasDiff(update)) {\n        return E.right(undefined);\n      }\n      return fn.pipe(\n        postEvent('web_app_setup_swipe_behavior', { allow_vertical_swipe: isVerticalEnabled }),\n        E.map(() => {\n          stateful.setState(update);\n        }),\n      );\n    };\n\n    this.isSupported = createIsSupportedSignal('web_app_setup_swipe_behavior', version);\n    this.isVerticalEnabled = stateful.getter('isVerticalEnabled');\n    this.isMounted = mountable.isMounted;\n    this.disableVerticalFp = wrapMountedEither(() => {\n      return setVerticalEnabled(false);\n    });\n    this.enableVerticalFp = wrapMountedEither(() => {\n      return setVerticalEnabled(true);\n    });\n    this.mountFp = wrapSupportedPlain(() => {\n      const nothing = () => undefined;\n      return fn.pipe(mountable.mount(), E.match(nothing, nothing));\n    });\n    this.unmount = mountable.unmount;\n\n    this.disableVertical = throwifyWithChecksFp(this.disableVerticalFp);\n    this.enableVertical = throwifyWithChecksFp(this.enableVerticalFp);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n  }\n\n  /**\n   * Signal indicating if the component is supported.\n   */\n  readonly isSupported: Computed<boolean>;\n\n  /**\n   * Signal indicating if vertical swipes are enabled.\n   */\n  readonly isVerticalEnabled: Computed<boolean>;\n\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component restoring its state.\n   * @since Mini Apps v7.7\n   */\n  readonly mountFp: WithChecksFp<() => void, true>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<() => void, true>;\n\n  /**\n   * Unmounts the component.\n   */\n  readonly unmount: () => void;\n\n  /**\n   * Disables the closing confirmation dialog.\n   * @since Mini Apps v7.7\n   */\n  readonly disableVerticalFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see disableVerticalFp\n   */\n  readonly disableVertical: WithChecks<() => void, true>;\n\n  /**\n   * Enables the closing confirmation dialog.\n   * @since Mini Apps v7.7\n   */\n  readonly enableVerticalFp: WithChecksFp<() => E.Either<PostEventError, void>, true>;\n\n  /**\n   * @see enableVerticalFp\n   */\n  readonly enableVertical: WithChecks<() => void, true>;\n}\n","import { function as fn } from 'fp-ts';\n\nimport { SwipeBehavior, type SwipeBehaviorState } from '@/features/SwipeBehavior/SwipeBehavior.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction instantiate() {\n  return new SwipeBehavior(fn.pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n    withStateRestore<SwipeBehaviorState>('swipeBehavior'),\n  ));\n}\n\nexport const swipeBehavior = /* @__PURE__*/ instantiate();\n","/**\n * Copies specified text to the clipboard.\n * @param text - text to copy.\n */\nexport async function copyTextToClipboard(text: string): Promise<void> {\n  try {\n    const { clipboard } = navigator;\n    if (clipboard) {\n      return await clipboard.writeText(text);\n    }\n  } catch {\n  }\n  const textArea = document.createElement('textarea');\n  textArea.value = text;\n\n  // Avoid scrolling to bottom\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.position = 'fixed';\n\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    document.execCommand('copy');\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\n","import { RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport { AccessDeniedError } from '@/errors.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nexport type DownloadFileError = RequestError | AccessDeniedError;\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    url: string,\n    fileName: string,\n    options?: AsyncOptions,\n  ): TE.TaskEither<DownloadFileError, void> => {\n    return fn.pipe(\n      request(\n        'web_app_request_file_download',\n        'file_download_requested',\n        { ...options, params: { url, file_name: fileName } },\n      ),\n      TE.chain(response => {\n        return response.status === 'downloading'\n          ? TE.right(undefined)\n          : TE.left(new AccessDeniedError('User denied the action'));\n      }),\n    );\n  }, { ...rest, requires: 'web_app_request_file_download', returns: 'task' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withRequest,\n    withVersion,\n  ));\n}\n\n/**\n * Displays a native popup prompting the user to download a file.\n * @param url - the HTTPS URL of the file to be downloaded.\n * @param file - the suggested name for the downloaded file.\n * @param options - additional request execution options.\n * @since Mini Apps v8.0\n * @example\n * fn.pipe(\n *   downloadFileFp('https://telegram.org/js/telegram-web-app.js', 'telegram-sdk.js'),\n *   TE.map(() => {\n *     console.log('Downloading');\n *   })\n * )\n */\nexport const downloadFileFp = instantiate();\n\nexport const downloadFile = throwifyWithChecksFp(downloadFileFp);\n","import { taskEither as TE, function as fn } from 'fp-ts';\nimport { date, integer, number, transform, pipe as valiPipe, safeParse } from 'valibot';\n\nimport { ValidationError } from '@/errors.js';\nimport {\n  type SharedFeatureOptions,\n  sharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport {\n  type WithInvokeCustomMethod,\n  withInvokeCustomMethod,\n  type InvokeCustomMethodError,\n} from '@/fn-options/withInvokeCustomMethod.js';\nimport { type WithVersion, withVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithInvokeCustomMethod, WithVersion {\n}\n\nexport type GetCurrentTimeError = InvokeCustomMethodError | ValidationError;\n\nfunction create({ invokeCustomMethod, ...rest }: CreateOptions) {\n  return withChecksFp((options?: AsyncOptions): TE.TaskEither<GetCurrentTimeError, Date> => {\n    return fn.pipe(\n      invokeCustomMethod('getCurrentTime', {}, options),\n      TE.chain(response => {\n        const parsed = safeParse(\n          valiPipe(number(), integer(), transform(v => new Date(v * 1000)), date()),\n          response,\n        );\n        return parsed.success\n          ? TE.right(parsed.output)\n          : TE.left(new ValidationError(response, parsed.issues));\n      }),\n    );\n  }, { ...rest, requires: 'web_app_invoke_custom_method', returns: 'task' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withInvokeCustomMethod,\n    withVersion,\n  ));\n}\n\n/**\n * @returns The current time according to the Telegram server time.\n * @param options - additional options.\n * @since Mini Apps v6.9\n */\nexport const getCurrentTimeFp = instantiate();\n\n/**\n * @see getCurrentTimeFp\n */\nexport const getCurrentTime = throwifyWithChecksFp(getCurrentTimeFp);\n","import type { PostEventError } from '@tma.js/bridge';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n}\n\nexport type HideKeyboardError = PostEventError;\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((): E.Either<HideKeyboardError, void> => {\n    return postEvent('web_app_hide_keyboard');\n  }, { ...rest, returns: 'either', requires: 'web_app_hide_keyboard' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n  ));\n}\n\n/**\n * Hides the on-screen keyboard, if it is currently visible. Does nothing if the keyboard is\n * not active.\n * @since Mini Apps v9.1\n */\nexport const hideKeyboardFp = instantiate();\n\n/**\n * @see hideKeyboardFp\n */\nexport const hideKeyboard = throwifyWithChecksFp(hideKeyboardFp);\n","import { captureSameReq, type RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { createRequestId } from '@/globals/createRequestId.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithVersion, WithRequest {\n  createRequestId: () => string;\n}\n\nexport type ReadTextFromClipboardError = RequestError;\n\nfunction create({ request, createRequestId, ...rest }: CreateOptions) {\n  return withChecksFp((\n    options?: AsyncOptions,\n  ): TE.TaskEither<ReadTextFromClipboardError, string | null> => {\n    const reqId = createRequestId();\n    return fn.pipe(\n      request('web_app_read_text_from_clipboard', 'clipboard_text_received', {\n        ...options,\n        params: { req_id: reqId },\n        capture: captureSameReq(reqId),\n      }),\n      TE.map(({ data = null }) => data),\n    );\n  }, { ...rest, requires: 'web_app_read_text_from_clipboard', returns: 'task' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create({\n    ...fn.pipe(\n      sharedFeatureOptions(),\n      withVersion,\n      withRequest,\n    ),\n    createRequestId,\n  });\n}\n\n/**\n * Reads a text from the clipboard and returns a `string` or `null`. `null` is returned\n * in one of the following cases:\n * - A value in the clipboard is not a text.\n * - Access to the clipboard is not granted.\n * @since Mini Apps v6.4\n */\nexport const readTextFromClipboardFp = instantiate();\n\nexport const readTextFromClipboard = throwifyWithChecksFp(readTextFromClipboardFp);\n","export interface AndroidDeviceData {\n  appVersion?: string;\n  manufacturer?: string;\n  model?: string;\n  androidVersion?: string;\n  sdkVersion?: number;\n  performanceClass?: 'LOW' | 'AVERAGE' | 'HIGH' | string;\n}\n\n/**\n * Retrieves Android device data from the specified User Agent.\n * @see https://core.telegram.org/bots/webapps#additional-data-in-user-agent\n * @param userAgent - user agent.\n */\nexport function retrieveAndroidDeviceDataFrom(userAgent: string): AndroidDeviceData {\n  const result: AndroidDeviceData = {};\n  const match = userAgent.match(/Telegram-Android(?:\\/([^ ]+))?(?: (\\([^)]+\\))?|$)/);\n  if (match) {\n    const [, appVersion, systemInfo] = match;\n    appVersion && (result.appVersion = appVersion);\n    systemInfo && systemInfo\n      .slice(1, systemInfo.length - 1)\n      .split(';')\n      .forEach(item => {\n        const [key, value] = item.trim().split(' ');\n        if (key === 'Android') {\n          result.androidVersion = value;\n        } else if (key === 'SDK') {\n          const parsed = parseInt(value, 10);\n          parsed && (result.sdkVersion = parsed);\n        } else if (value) {\n          result.manufacturer = key;\n          result.model = value;\n        } else {\n          result.performanceClass = key;\n        }\n      });\n  }\n  return result;\n}\n","import {\n  type AndroidDeviceData,\n  retrieveAndroidDeviceDataFrom,\n} from './retrieveAndroidDeviceDataFrom.js';\n\n/**\n * Retrieves Android device data from the navigator.userAgent.\n * @see https://core.telegram.org/bots/webapps#additional-data-in-user-agent\n */\nexport function retrieveAndroidDeviceData(): AndroidDeviceData {\n  return retrieveAndroidDeviceDataFrom(navigator.userAgent);\n}\n","import type { PostEventError } from '@tma.js/bridge';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { InvalidArgumentsError } from '@/errors.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent {\n}\n\nexport type SendDataError = PostEventError | InvalidArgumentsError;\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((data: string): E.Either<SendDataError, void> => {\n    const { size } = new Blob([data]);\n    if (!size || size > 4096) {\n      return E.left(\n        new InvalidArgumentsError(size\n          ? 'Maximum size of data to send is 4096 bytes'\n          : 'Attempted to send empty data'),\n      );\n    }\n    return postEvent('web_app_data_send', { data });\n  }, { ...rest, returns: 'either' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(sharedFeatureOptions(), withPostEvent));\n}\n\n/**\n * Sends data to the bot.\n *\n * When this method called, a service message sent to the bot containing the data of the length\n * up to 4096 bytes, and the Mini App closed.\n *\n * See the field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n *\n * This method is only available for Mini Apps launched via a Keyboard button.\n * @param data - data to send to bot.\n */\nexport const sendDataFp = instantiate();\n\n/**\n * @see sendDataFp\n */\nexport const sendData = throwifyWithChecksFp(sendDataFp);\n","import { RequestError } from '@tma.js/bridge';\nimport { taskEither as TE, function as fn } from 'fp-ts';\n\nimport { ShareMessageError } from '@/errors.js';\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withRequest, type WithRequest } from '@/fn-options/withRequest.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport type { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithRequest, WithVersion {\n}\n\nexport type ShareMessageFnError = RequestError | ShareMessageError;\n\nfunction create({ request, ...rest }: CreateOptions) {\n  return withChecksFp((\n    messageId: string,\n    options?: AsyncOptions,\n  ): TE.TaskEither<ShareMessageFnError, void> => {\n    return fn.pipe(\n      request(\n        'web_app_send_prepared_message',\n        ['prepared_message_failed', 'prepared_message_sent'],\n        {\n          ...options,\n          params: { id: messageId },\n        },\n      ),\n      TE.chain(response => (\n        response.event === 'prepared_message_failed'\n          ? TE.left(new ShareMessageError(response.payload.error))\n          : TE.right(undefined)\n      )),\n    );\n  }, { ...rest, requires: 'web_app_send_prepared_message', returns: 'task' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withRequest,\n    withVersion,\n  ));\n}\n\n/**\n * Opens a dialog allowing the user to share a message provided by the bot.\n * @since Mini Apps v8.0\n */\nexport const shareMessageFp = instantiate();\n\n/**\n * @see shareMessageFp\n */\nexport const shareMessage = throwifyWithChecksFp(shareMessageFp);\n","import type { PostEventError } from '@tma.js/bridge';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n}\n\nexport interface ShareStoryOptions {\n  /**\n   * The caption to be added to the media.\n   * 0-200 characters for regular users and 0-2048 characters for premium subscribers.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  text?: string;\n  /**\n   * An object that describes a widget link to be included in the story.\n   * Note that only premium subscribers can post stories with links.\n   * @see https://telegram.org/faq_premium#telegram-premium\n   */\n  widgetLink?: {\n    /**\n     * The URL to be included in the story.\n     */\n    url: string;\n    /**\n     * The name to be displayed for the widget link, 0-48 characters.\n     */\n    name?: string;\n  };\n}\n\nexport type ShareStoryError = PostEventError;\n\nfunction create({ postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((\n    mediaUrl: string,\n    options: ShareStoryOptions = {},\n  ): E.Either<ShareStoryError, void> => {\n    return postEvent('web_app_share_to_story', {\n      text: options.text,\n      media_url: mediaUrl,\n      widget_link: options.widgetLink,\n    });\n  }, { ...rest, requires: 'web_app_share_to_story', returns: 'either' });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create(fn.pipe(\n    sharedFeatureOptions(),\n    withPostEvent,\n    withVersion,\n  ));\n}\n\n/**\n * Opens the native story editor.\n * @since Mini Apps v7.8\n * @example\n * fn.pipe(\n *   shareStory('https://example.com/background.png', {\n *     text: 'Look at this cool group!',\n *     widgetLink: {\n *       url: 'https://t.me/heyqbnk',\n *       name: 'Vlad\\'s community',\n *     },\n *   }),\n *   TE.match(error => {\n *     console.error('Something went wrong', error);\n *   }, () => {\n *     console.log('Call was successful');\n *   }),\n * );\n */\nexport const shareStoryFp = instantiate();\n\n/**\n * @see shareStoryFp\n */\nexport const shareStory = throwifyWithChecksFp(shareStoryFp);\n","import { createSignal } from '@/globals/signals-registry.js';\n\n/**\n * True if the application is launched in inline mode.\n */\nexport const isInlineMode = createSignal(false);\n","import type { PostEventError, SwitchInlineQueryChatType } from '@tma.js/bridge';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport {\n  sharedFeatureOptions,\n  type SharedFeatureOptions,\n} from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent, type WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withVersion, type WithVersion } from '@/fn-options/withVersion.js';\nimport { isInlineMode } from '@/globals/isInlineMode.js';\nimport { access } from '@/helpers/access.js';\nimport type { MaybeAccessor } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { withChecksFp } from '@/with-checks/withChecksFp.js';\n\ninterface CreateOptions extends SharedFeatureOptions, WithPostEvent, WithVersion {\n  isInlineMode: MaybeAccessor<boolean>;\n}\n\nexport type SwitchInlineQueryError = PostEventError;\n\nfunction create({ isInlineMode, postEvent, ...rest }: CreateOptions) {\n  return withChecksFp((\n    query: string,\n    chatTypes?: SwitchInlineQueryChatType[],\n  ): E.Either<SwitchInlineQueryError, void> => {\n    return postEvent('web_app_switch_inline_query', {\n      query: query,\n      chat_types: chatTypes || [],\n    });\n  }, {\n    ...rest,\n    requires: {\n      every: ['web_app_switch_inline_query', () => {\n        return access(isInlineMode)\n          ? undefined\n          : 'The application must be launched in the inline mode';\n      }],\n    },\n    returns: 'either',\n  });\n}\n\n// #__NO_SIDE_EFFECTS__\nfunction instantiate() {\n  return create({\n    ...fn.pipe(\n      sharedFeatureOptions(),\n      withPostEvent,\n      withVersion,\n    ),\n    isInlineMode,\n  });\n}\n\n/**\n * Inserts the bot's username and the specified inline query in the current chat's input field.\n * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n * the specified inline query in the input field.\n * @param query - text which should be inserted in the input after the current bot name. Max\n * length is 256 symbols.\n * @param chatTypes - List of chat types which could be chosen to send the message. Could be an\n * empty list.\n * @since Mini Apps v6.7\n * @example\n * fn.pipe(\n *   switchInlineQuery('my query goes here', ['users']),\n *   E.match(error => {\n *     console.error('Something went wrong', error);\n *   }, () => {\n *     console.log('Call was successful');\n *   }),\n * );\n */\nexport const switchInlineQueryFp = instantiate();\n\n/**\n * @see switchInlineQueryFp\n */\nexport const switchInlineQuery = throwifyWithChecksFp(switchInlineQueryFp);\n","import {\n  type SafeAreaInsets,\n  type EventListener,\n  supports,\n  type RequestError,\n  type PostEventError,\n} from '@tma.js/bridge';\nimport { Computed, computed, signal } from '@tma.js/signals';\nimport { camelToKebab } from '@tma.js/toolkit';\nimport { BetterPromise } from 'better-promises';\nimport { either as E, taskEither as TE, function as fn } from 'fp-ts';\n\nimport { AsyncMountable } from '@/composables/AsyncMountable.js';\nimport { Stateful } from '@/composables/Stateful.js';\nimport { CSSVarsBoundError, FullscreenFailedError } from '@/errors.js';\nimport { SharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { WithPostEvent } from '@/fn-options/withPostEvent.js';\nimport { WithRequest } from '@/fn-options/withRequest.js';\nimport { WithStateRestore } from '@/fn-options/withStateRestore.js';\nimport { WithVersion } from '@/fn-options/withVersion.js';\nimport { access } from '@/helpers/access.js';\nimport { deleteCssVar, setCssVar } from '@/helpers/css-vars.js';\nimport { AsyncOptions } from '@/types.js';\nimport { throwifyWithChecksFp } from '@/with-checks/throwifyWithChecksFp.js';\nimport { createWithChecksFp, WithChecks, WithChecksFp } from '@/with-checks/withChecksFp.js';\n\ntype FullscreenError = FullscreenFailedError | RequestError;\ntype ViewportChangedEventListener = EventListener<'viewport_changed'>;\ntype FullscreenChangedEventListener = EventListener<'fullscreen_changed'>;\ntype SafeAreaInsetsChangedEventListener = EventListener<'safe_area_changed'>;\ntype SafeAreaInsetCSSVarKey = `safeAreaInset${Capitalize<keyof SafeAreaInsets>}`;\n\nexport type GetCSSVarNameKey =\n  | 'width'\n  | 'height'\n  | 'stableHeight'\n  | SafeAreaInsetCSSVarKey\n  | `content${Capitalize<SafeAreaInsetCSSVarKey>}`;\n\nexport type GetCSSVarNameFn = (key: GetCSSVarNameKey) => string | null | undefined | false;\n\nexport interface ViewportState {\n  contentSafeAreaInsets: SafeAreaInsets;\n  height: number;\n  isExpanded: boolean;\n  isFullscreen: boolean;\n  safeAreaInsets: SafeAreaInsets;\n  stableHeight: number;\n  width: number;\n}\n\ntype WithListeners<On extends string, Off extends string, L> = {\n  [K in On | Off]: (listener: L) => void;\n};\n\nexport interface ViewportOptions<EViewportStable, EFullscreen>\n  extends WithStateRestore<ViewportState>,\n  WithVersion,\n  WithRequest,\n  WithPostEvent,\n  WithListeners<'onViewportChanged', 'offViewportChanged', ViewportChangedEventListener>,\n  WithListeners<'onFullscreenChanged', 'offFullscreenChanged', FullscreenChangedEventListener>,\n  WithListeners<'onSafeAreaInsetsChanged', 'offSafeAreaInsetsChanged', SafeAreaInsetsChangedEventListener>,\n  WithListeners<'onContentSafeAreaInsetsChanged', 'offContentSafeAreaInsetsChanged', SafeAreaInsetsChangedEventListener>,\n  SharedFeatureOptions {\n  /**\n   * True if the viewport is stable.\n   */\n  isViewportStable: boolean | (() => E.Either<EViewportStable, boolean>);\n  /**\n   * True if the application was opened in fullscreen initially.\n   */\n  isFullscreen: boolean | (() => E.Either<EFullscreen, boolean>);\n}\n\nexport class Viewport<EViewportStable, EFullscreen> {\n  constructor({\n    storage,\n    isPageReload,\n    onContentSafeAreaInsetsChanged,\n    onSafeAreaInsetsChanged,\n    onViewportChanged,\n    onFullscreenChanged,\n    offContentSafeAreaInsetsChanged,\n    offFullscreenChanged,\n    offSafeAreaInsetsChanged,\n    offViewportChanged,\n    request,\n    isViewportStable,\n    isFullscreen,\n    isTma,\n    version,\n    postEvent,\n  }: ViewportOptions<EViewportStable, EFullscreen>) {\n    const initialInsets: SafeAreaInsets = { top: 0, right: 0, left: 0, bottom: 0 };\n    const stateful = new Stateful<ViewportState>({\n      initialState: {\n        contentSafeAreaInsets: initialInsets,\n        height: 0,\n        isExpanded: false,\n        isFullscreen: false,\n        safeAreaInsets: initialInsets,\n        stableHeight: 0,\n        width: 0,\n      },\n      onChange: storage.set,\n    });\n\n    const viewportChangedListener: ViewportChangedEventListener = event => {\n      stateful.setState({\n        isExpanded: event.is_expanded,\n        height: event.height,\n        width: event.width,\n        stableHeight: event.is_state_stable ? event.height : undefined,\n      });\n    };\n    const fullscreenChangedListener: FullscreenChangedEventListener = event => {\n      stateful.setState({ isFullscreen: event.is_fullscreen });\n    };\n    const safeAreaInsetsChangedListener: SafeAreaInsetsChangedEventListener = event => {\n      stateful.setState({ safeAreaInsets: event });\n    };\n    const contentSafeAreaInsetsChangedListener: SafeAreaInsetsChangedEventListener = event => {\n      stateful.setState({ contentSafeAreaInsets: event });\n    };\n\n    const mountable = new AsyncMountable({\n      initialState(options) {\n        const genRequestInsets = (kind: 'safe-area' | 'content-safe-area') => {\n          return () => {\n            const [method, event] = kind === 'safe-area'\n              ? ['web_app_request_safe_area', 'safe_area_changed'] as const\n              : ['web_app_request_content_safe_area', 'content_safe_area_changed'] as const;\n\n            if (!supports(method, access(version))) {\n              return TE.right({ top: 0, left: 0, right: 0, bottom: 0 });\n            }\n            return request(method, event, options);\n          };\n        };\n        const genFlag = <E>(flag: boolean | (() => E.Either<E, boolean>)) => {\n          return () => (\n            typeof flag === 'boolean'\n              ? TE.right(flag)\n              : TE.fromEither(flag())\n          );\n        };\n\n        return fn.pipe(\n          TE.Do,\n          TE.bindW('safeAreaInsets', genRequestInsets('safe-area')),\n          TE.bindW('contentSafeAreaInsets', genRequestInsets('content-safe-area')),\n          TE.bindW('isFullscreen', genFlag(isFullscreen)),\n          TE.bindW('isViewportStable', genFlag(isViewportStable)),\n          TE.chainW(({ isViewportStable, ...shared }) => {\n            if (isViewportStable) {\n              return TE.right({\n                ...shared,\n                height: window.innerHeight,\n                isExpanded: true,\n                stableHeight: window.innerHeight,\n                width: window.innerWidth,\n              });\n            }\n            return fn.pipe(\n              request('web_app_request_viewport', 'viewport_changed', options),\n              TE.map(viewport => ({\n                ...shared,\n                height: viewport.height,\n                isExpanded: viewport.is_expanded,\n                stableHeight: viewport.is_state_stable ? viewport.height : 0,\n                width: viewport.width,\n              })),\n            );\n          }),\n        );\n      },\n      isPageReload,\n      onMounted(state) {\n        onViewportChanged(viewportChangedListener);\n        onFullscreenChanged(fullscreenChangedListener);\n        onSafeAreaInsetsChanged(safeAreaInsetsChangedListener);\n        onContentSafeAreaInsetsChanged(contentSafeAreaInsetsChangedListener);\n        stateful.setState(state);\n      },\n      onUnmounted() {\n        offViewportChanged(viewportChangedListener);\n        offFullscreenChanged(fullscreenChangedListener);\n        offSafeAreaInsetsChanged(safeAreaInsetsChangedListener);\n        offContentSafeAreaInsetsChanged(contentSafeAreaInsetsChangedListener);\n      },\n      restoreState: storage.get,\n    });\n\n    const saBased = <K extends keyof SafeAreaInsets>(key: K) => {\n      return computed(() => this.safeAreaInsets()[key]);\n    };\n    const csaBased = <K extends keyof SafeAreaInsets>(key: K) => {\n      return computed(() => this.contentSafeAreaInsets()[key]);\n    };\n\n    this.state = stateful.state;\n    this.height = stateful.getter('height');\n    this.stableHeight = stateful.getter('stableHeight');\n    this.width = stateful.getter('width');\n    this.isExpanded = stateful.getter('isExpanded');\n    this.safeAreaInsets = stateful.getter('safeAreaInsets');\n    this.safeAreaInsetTop = saBased('top');\n    this.safeAreaInsetBottom = saBased('bottom');\n    this.safeAreaInsetLeft = saBased('left');\n    this.safeAreaInsetRight = saBased('right');\n    this.contentSafeAreaInsets = stateful.getter('contentSafeAreaInsets');\n    this.contentSafeAreaInsetTop = csaBased('top');\n    this.contentSafeAreaInsetBottom = csaBased('bottom');\n    this.contentSafeAreaInsetLeft = csaBased('left');\n    this.contentSafeAreaInsetRight = csaBased('right');\n\n    const wrapTask = createWithChecksFp({ isTma, returns: 'task' });\n    const wrapMountedEither = createWithChecksFp({\n      isTma,\n      returns: 'either',\n    });\n    const wrapFullscreenTask = createWithChecksFp({\n      isTma,\n      requires: 'web_app_request_fullscreen',\n      version,\n      returns: 'task',\n    });\n    const genFullscreenFn = (enable: boolean) => {\n      return wrapFullscreenTask((options?: AsyncOptions) => {\n        return fn.pipe(\n          request(\n            enable ? 'web_app_request_fullscreen' : 'web_app_exit_fullscreen',\n            ['fullscreen_changed', 'fullscreen_failed'],\n            options,\n          ),\n          TE.chain(response => {\n            if (\n              response.event === 'fullscreen_failed'\n              && response.payload.error !== 'ALREADY_FULLSCREEN'\n            ) {\n              return TE.left(new FullscreenFailedError(response.payload.error));\n            }\n            stateful.setState({\n              isFullscreen: 'is_fullscreen' in response.payload\n                ? response.payload.is_fullscreen\n                : true,\n            });\n            return TE.right(undefined);\n          }),\n        );\n      });\n    };\n\n    // Mount.\n    this.isMounted = mountable.isMounted;\n    this.mountFp = wrapTask(mountable.mount);\n    this.mount = throwifyWithChecksFp(this.mountFp);\n\n    // Fullscreen.\n    this.isFullscreen = stateful.getter('isFullscreen');\n    this.requestFullscreenFp = genFullscreenFn(true);\n    this.requestFullscreen = throwifyWithChecksFp(this.requestFullscreenFp);\n    this.exitFullscreenFp = genFullscreenFn(false);\n    this.exitFullscreen = throwifyWithChecksFp(this.exitFullscreenFp);\n\n    // CSS vars.\n    const isCssVarsBound = signal(false);\n    this.isCssVarsBound = computed(isCssVarsBound);\n    this.bindCssVarsFp = wrapMountedEither(\n      (getCSSVarName?: GetCSSVarNameFn) => {\n        if (isCssVarsBound()) {\n          return E.left(new CSSVarsBoundError());\n        }\n        getCSSVarName ||= prop => `--tg-viewport-${camelToKebab(prop)}`;\n\n        const settings = ([\n          ['height', this.height],\n          ['stableHeight', this.stableHeight],\n          ['width', this.width],\n          ['safeAreaInsetTop', this.safeAreaInsetTop],\n          ['safeAreaInsetBottom', this.safeAreaInsetBottom],\n          ['safeAreaInsetLeft', this.safeAreaInsetLeft],\n          ['safeAreaInsetRight', this.safeAreaInsetRight],\n          ['contentSafeAreaInsetTop', this.contentSafeAreaInsetTop],\n          ['contentSafeAreaInsetBottom', this.contentSafeAreaInsetBottom],\n          ['contentSafeAreaInsetLeft', this.contentSafeAreaInsetLeft],\n          ['contentSafeAreaInsetRight', this.contentSafeAreaInsetRight],\n        ] as const).reduce<{\n          update: VoidFunction;\n          removeListener: VoidFunction;\n          cssVar: string;\n        }[]>((acc, [key, signal]) => {\n          const cssVar = getCSSVarName(key);\n          if (cssVar) {\n            const update = () => {\n              setCssVar(cssVar, `${signal()}px`);\n            };\n            acc.push({ update, removeListener: signal.sub(update), cssVar });\n          }\n          return acc;\n        }, []);\n\n        settings.forEach(setting => {\n          setting.update();\n        });\n        isCssVarsBound.set(true);\n\n        return E.right(() => {\n          settings.forEach(s => {\n            s.removeListener();\n            deleteCssVar(s.cssVar);\n          });\n          isCssVarsBound.set(false);\n        });\n      },\n    );\n    this.bindCssVars = throwifyWithChecksFp(this.bindCssVarsFp);\n\n    // Other methods.\n    this.expandFp = wrapMountedEither(() => postEvent('web_app_expand'));\n    this.expand = throwifyWithChecksFp(this.expandFp);\n  }\n\n  //#region Other properties.\n  /**\n   * Complete component state.\n   */\n  readonly state: Computed<ViewportState>;\n\n  /**\n   * Signal containing the current height of the **visible area** of the Mini App.\n   *\n   * The application can display just the top part of the Mini App, with its\n   * lower part remaining outside the screen area. From this position, the user\n   * can \"pull\" the Mini App to its maximum height, while the bot can do the same\n   * by calling `expand` method. As the position of the Mini App changes, the\n   * current height value of the visible area will be updated  in real time.\n   *\n   * Please note that the refresh rate of this value is not sufficient to\n   * smoothly follow the lower border of the window. It should not be used to pin\n   * interface elements to the bottom of the visible area. It's more appropriate\n   * to use the value of the `stableHeight` field for this purpose.\n   *\n   * @see stableHeight\n   */\n  readonly height: Computed<number>;\n\n  /**\n   * Signal containing the height of the visible area of the Mini App in its last stable state.\n   *\n   * The application can display just the top part of the Mini App, with its\n   * lower part remaining outside the screen area. From this position, the user\n   * can \"pull\" the Mini App to its maximum height, while the application can do\n   * the same by calling `expand` method.\n   *\n   * Unlike the value of `height`, the value of `stableHeight` does not change as\n   * the position of the Mini App changes with user gestures or during\n   * animations. The value of `stableHeight` will be updated after all gestures\n   * and animations are completed and the Mini App reaches its final size.\n   *\n   * @see height\n   */\n  readonly stableHeight: Computed<number>;\n\n  /**\n   * Signal containing the currently visible area width.\n   */\n  readonly width: Computed<number>;\n\n  /**\n   * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,\n   * if the Mini App occupies part of the screen and can be expanded to the full\n   * height using the `expand` method.\n   */\n  readonly isExpanded: Computed<boolean>;\n\n  /**\n   * Signal indicating if the current viewport height is stable and is not going to change in\n   * the next moment.\n   */\n  readonly isStable = computed(() => this.height() === this.stableHeight());\n  //#endregion\n\n  //#region Content safe area insets.\n  /**\n   * Signal containing content safe area insets.\n   */\n  readonly contentSafeAreaInsets: Computed<SafeAreaInsets>;\n\n  /**\n   * Signal containing top content safe area inset.\n   */\n  readonly contentSafeAreaInsetTop: Computed<number>;\n\n  /**\n   * Signal containing left content safe area inset.\n   */\n  readonly contentSafeAreaInsetLeft: Computed<number>;\n\n  /**\n   * Signal containing right content safe area inset.\n   */\n  readonly contentSafeAreaInsetRight: Computed<number>;\n\n  /**\n   * Signal containing bottom content safe area inset.\n   */\n  readonly contentSafeAreaInsetBottom: Computed<number>;\n  //#endregion\n\n  //#region Safe area insets.\n  /**\n   * Signal containing safe area insets.\n   */\n  readonly safeAreaInsets: Computed<SafeAreaInsets>;\n\n  /**\n   * Signal containing top safe area inset.\n   */\n  readonly safeAreaInsetTop: Computed<number>;\n\n  /**\n   * Signal containing left safe area inset.\n   */\n  readonly safeAreaInsetLeft: Computed<number>;\n\n  /**\n   * Signal containing right safe area inset.\n   */\n  readonly safeAreaInsetRight: Computed<number>;\n\n  /**\n   * Signal containing bottom safe area inset.\n   */\n  readonly safeAreaInsetBottom: Computed<number>;\n  //#endregion\n\n  //#region Fullscreen.\n  /**\n   * Signal indicating if the viewport is currently in fullscreen mode.\n   */\n  readonly isFullscreen: Computed<boolean>;\n\n  /**\n   * Requests fullscreen mode for the mini application.\n   * @since Mini Apps v8.0\n   */\n  readonly requestFullscreenFp: WithChecksFp<\n    (options?: AsyncOptions) => TE.TaskEither<FullscreenError, void>,\n    true\n  >;\n\n  /**\n   * @see requestFullscreenFp\n   */\n  readonly requestFullscreen: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, true>;\n\n  /**\n   * Exits mini application from the fullscreen mode.\n   * @since Mini Apps v8.0\n   */\n  readonly exitFullscreenFp: WithChecksFp<\n    (options?: AsyncOptions) => TE.TaskEither<FullscreenError, void>,\n    true\n  >;\n\n  /**\n   * @see exitFullscreenFp\n   */\n  readonly exitFullscreen: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, true>;\n  //#endregion\n\n  //#region CSS Vars.\n  /**\n   * Signal indicating if CSS variables are bound.\n   */\n  readonly isCssVarsBound: Computed<boolean>;\n\n  /**\n   * Creates CSS variables connected with the current viewport.\n   *\n   * By default, created CSS variables names are following the pattern \"--tg-theme-{name}\", where\n   * {name} is a viewport property name converted from camel case to kebab case.\n   *\n   * Default variables:\n   * - `--tg-viewport-height`\n   * - `--tg-viewport-width`\n   * - `--tg-viewport-stable-height`\n   * - `--tg-viewport-content-safe-area-inset-top`\n   * - `--tg-viewport-content-safe-area-inset-bottom`\n   * - `--tg-viewport-content-safe-area-inset-left`\n   * - `--tg-viewport-content-safe-area-inset-right`\n   * - `--tg-viewport-safe-area-inset-top`\n   * - `--tg-viewport-safe-area-inset-bottom`\n   * - `--tg-viewport-safe-area-inset-left`\n   * - `--tg-viewport-safe-area-inset-right`\n   *\n   * Variables are being automatically updated if the viewport was changed.\n   *\n   * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS\n   * variable will only be defined if the function returned non-empty string value.\n   * @returns Function to stop updating variables.\n   * @example Using no arguments\n   * bindCssVarsFp();\n   * @example Using custom CSS vars generator\n   * bindCssVarsFp(key => `--my-prefix-${key}`);\n   */\n  readonly bindCssVarsFp: WithChecksFp<(getCSSVarName?: GetCSSVarNameFn) => (\n    E.Either<CSSVarsBoundError, VoidFunction>\n  ), false>;\n\n  /**\n   * @see bindCssVarsFp\n   */\n  readonly bindCssVars: WithChecks<(getCSSVarName?: GetCSSVarNameFn) => VoidFunction, false>;\n  //#endregion\n\n  //#region Mount.\n  /**\n   * Signal indicating if the component is currently mounted.\n   */\n  readonly isMounted: Computed<boolean>;\n\n  /**\n   * Mounts the component.\n   */\n  readonly mountFp: WithChecksFp<(options?: AsyncOptions) => (\n    TE.TaskEither<EFullscreen | EViewportStable | RequestError, void>\n  ), false>;\n\n  /**\n   * @see mountFp\n   */\n  readonly mount: WithChecks<(options?: AsyncOptions) => BetterPromise<void>, false>;\n  //#endregion\n\n  //#region Other methods.\n  /**\n   * A method that expands the Mini App to the maximum available height. To find\n   * out if the Mini App is expanded to the maximum height, refer to the value of\n   * the `isExpanded`.\n   */\n  readonly expandFp: WithChecksFp<() => E.Either<PostEventError, void>, false>;\n\n  /**\n   * @see expandFp\n   */\n  readonly expand: WithChecks<() => void, false>;\n  //#endregion\n}\n","import { retrieveLaunchParamsFp, on, off, type EventName, EventListener } from '@tma.js/bridge';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { Viewport, type ViewportState } from '@/features/Viewport/Viewport.js';\nimport { sharedFeatureOptions } from '@/fn-options/sharedFeatureOptions.js';\nimport { withPostEvent } from '@/fn-options/withPostEvent.js';\nimport { withRequest } from '@/fn-options/withRequest.js';\nimport { withStateRestore } from '@/fn-options/withStateRestore.js';\nimport { withVersion } from '@/fn-options/withVersion.js';\n\nfunction create() {\n  const createListeners = <E extends EventName>(event: E) => {\n    return {\n      on: (listener: EventListener<E>) => {\n        on(event, listener);\n      },\n      off: (listener: EventListener<E>) => {\n        off(event, listener);\n      },\n    };\n  };\n  const viewportListeners = createListeners('viewport_changed');\n  const fullscreenListeners = createListeners('fullscreen_changed');\n  const safeAreaListeners = createListeners('safe_area_changed');\n  const contentSafeAreaListeners = createListeners('content_safe_area_changed');\n\n  return new Viewport({\n    ...fn.pipe(\n      sharedFeatureOptions(),\n      withStateRestore<ViewportState>('viewport'),\n      withVersion,\n      withPostEvent,\n      withRequest,\n    ),\n    isFullscreen() {\n      return fn.pipe(retrieveLaunchParamsFp(), E.map(lp => !!lp.tgWebAppFullscreen));\n    },\n    isViewportStable() {\n      return fn.pipe(retrieveLaunchParamsFp(), E.map(lp => {\n        return ['macos', 'tdesktop', 'unigram', 'webk', 'weba', 'web'].includes(lp.tgWebAppPlatform);\n      }));\n    },\n    offContentSafeAreaInsetsChanged: contentSafeAreaListeners.off,\n    offFullscreenChanged: fullscreenListeners.off,\n    offSafeAreaInsetsChanged: safeAreaListeners.off,\n    offViewportChanged: viewportListeners.off,\n    onContentSafeAreaInsetsChanged: contentSafeAreaListeners.on,\n    onFullscreenChanged: fullscreenListeners.on,\n    onSafeAreaInsetsChanged: safeAreaListeners.on,\n    onViewportChanged: viewportListeners.on,\n  });\n}\n\nexport const viewport = /* @__PURE__*/ create();\n","import {\n  on,\n  logger,\n  retrieveLaunchParamsFp,\n  type RetrieveLaunchParamsError,\n  type PostEventError,\n  type PostEventFpFn,\n} from '@tma.js/bridge';\nimport { createCbCollector, throwifyFpFn } from '@tma.js/toolkit';\nimport type { Version, ThemeParams } from '@tma.js/types';\nimport { either as E, function as fn } from 'fp-ts';\n\nimport { isInlineMode } from '@/globals/isInlineMode.js';\nimport { postEventFpSignal, postEventFp, postEvent } from '@/globals/postEvent.js';\nimport { themeParams } from '@/globals/themeParams.js';\nimport { version } from '@/globals/version.js';\n\nexport interface InitOptions {\n  /**\n   * True if SDK should accept styles sent from the Telegram application.\n   * @default true\n   */\n  acceptCustomStyles?: boolean;\n  /**\n   * True if the application is launched in inline mode.\n   * @default Will be calculated based on the launch parameters' tgWebAppBotInline field.\n   */\n  isInlineMode?: boolean;\n  /**\n   * A custom `postEvent` function to use across the package.\n   * @default tma.js/bridge's postEventFp function will be used.\n   */\n  postEvent?: PostEventFpFn;\n  /**\n   * Mini application theme parameters.\n   * @default Will be calculated based on the launch parameters' tgWebAppThemeParams field.\n   */\n  themeParams?: ThemeParams;\n  /**\n   * Telegram Mini Apps version supported by the Telegram client.\n   * @default Will be calculated based on the launch parameters' tgWebAppVersion field.\n   */\n  version?: Version;\n}\n\n/**\n * Initializes the SDK allowing it to properly handle events, sent from the native Telegram\n * application. This function also configure the package's global dependencies (functions,\n * variables used across the package).\n * @param options - function options.\n * @returns A function, to perform a cleanup.\n */\nexport function initFp(\n  options: InitOptions = {},\n): E.Either<RetrieveLaunchParamsError | PostEventError, VoidFunction> {\n  const {\n    version: optionsVersion,\n    isInlineMode: optionsInlineMode,\n    themeParams: optionsThemeParams,\n  } = options;\n\n  if (optionsVersion && typeof optionsInlineMode === 'boolean' && optionsThemeParams) {\n    version.set(optionsVersion);\n    isInlineMode.set(optionsInlineMode);\n    themeParams.set(optionsThemeParams);\n  } else {\n    const error = fn.pipe(retrieveLaunchParamsFp(), E.matchW(\n      err => err,\n      lp => {\n        version.set(optionsVersion || lp.tgWebAppVersion);\n        isInlineMode.set(typeof optionsInlineMode === 'boolean'\n          ? optionsInlineMode\n          : !!lp.tgWebAppBotInline);\n        themeParams.set(optionsThemeParams || lp.tgWebAppThemeParams);\n      },\n    ));\n    if (error) {\n      return E.left(error);\n    }\n  }\n  if (options.postEvent) {\n    postEventFpSignal.set(options.postEvent);\n  }\n\n  const [addCleanup, cleanup] = createCbCollector(\n    on('reload_iframe', () => {\n      logger().log('Received a request to reload the page');\n      postEvent('iframe_will_reload');\n      window.location.reload();\n    }),\n  );\n\n  const { acceptCustomStyles = true } = options;\n  if (acceptCustomStyles) {\n    const style = document.createElement('style');\n    style.id = 'telegram-custom-styles';\n    document.head.appendChild(style);\n\n    addCleanup(\n      on('set_custom_style', html => {\n        // It is safe to use innerHTML here as long as style tag has a special behavior related\n        // to the specified content.\n        // In case any script will be passed here, it will not be executed, so XSS is not possible.\n        style.innerHTML = html;\n      }),\n      () => {\n        document.head.removeChild(style);\n      },\n    );\n  }\n\n  // Notify Telegram that the application is ready.\n  //\n  // This will result in sending style tag html content from the Telegram web application.\n  // We should call this method also to start receiving \"reload_iframe\" events from the Telegram\n  // application.\n  //\n  // It really has no effect outside non-Telegram web environment.\n  return fn.pipe(\n    postEventFp('iframe_ready', { reload_supported: true }),\n    E.map(() => {\n      logger().log('The package was initialized');\n      return cleanup;\n    }),\n  );\n}\n\n/**\n * @see initFp\n */\nexport const init = throwifyFpFn(initFp);\n"],"names":["r","y","e","c","m","S","g","u","s","t","l","o","d","n","h","p","j","b","x","__spreadArray","to","from","pack","i","ar","identity","a","flow","ab","bc","cd","de","ef","fg","gh","hi","ij","pipe","ret","dual","arity","body","isDataFirst","args","self","none","some","isLeft","ma","left","right","emptyRecord","ap","F","G","fa","fab","gab","ga","map","f","bind","M","name","_a","_.none","_.some","_map","_ap","URI","isNone","of","flatMap","Chain","matchW","onNone","onSome","match","Do","_.emptyRecord","chainable.bind","_.left","_.right","Functor","apW","Apply","bimap","mapLeft","_.isLeft","onLeft","onRight","foldW","fold","tryCatch","onThrow","bindW","chainW","chain","E.right","E.left","map_","E.Functor","ap_","E.Apply","E.isLeft","mapBoth","E.bimap","E.match","parse","_apPar","Pointed","ApplyPar","Monad","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","reject","fulfilled","step","rejected","result","__generator","_","verb","v","op","ET.left","T.Pointed","ET.right","fromEither","T.of","ET.match","T.Functor","onRejected","reason_1","ET.map","ET.mapBoth","ET.ap","T.ApplyPar","ET.flatMap","T.Monad","access","Mountable","onMounted","restoreState","initialState","onUnmounted","isPageReload","__publicField","signal","computed","restored","state","fn.pipe","E.map","batch","removeUndefined","k","shallowEqual","aKeys","bKeys","aKey","Stateful","onChange","nextState","key","store","getGlobalConfig","config2","store2","getGlobalMessage","lang","store3","getSchemaMessage","store4","getSpecificMessage","reference","_stringify","input","type","_b","_addIssue","context","label","dataset","other","expected","received","issue","isSchema","message2","_getStandardProps","value2","_isValidObjectKey","object2","_joinExpects","values2","separator","list","ValiError","issues","check","requirement","integer","transform","operation","getFallback","schema","getDefault","is","any","array","item","itemDataset","pathItem","boolean","date","function_","instance","class_","looseObject","entries2","valueSchema","valueDataset","nullish","wrapped","default_","number","optional","record","entryKey","entryValue","keyDataset","string","_subIssues","datasets","union","options","option","validDataset","typedDatasets","untypedDatasets","optionDataset","unknown","pipe2","safeParse","$","q","w","D","E","I","L","H","C","O","T","A","R","K","z","J","f.pipe","i.match","u.match","i.tryCatch","u.right","u.left","i.chainW","i.left","i.right","i.fromEither","i.matchW","N","B","U","V","s.right","s.left","G.pipe","s.map","tt","W","Q","et","s.tryCatch","nt","at","X","it","ke","se","Y","ie","xe","Se","Te","ye","Ae","pe","Ce","c.chainW","re","qe","c.map","L.some","L.none","rt","c.fold","L.match","c.foldW","c.right","c.left","We","Fe","ce","ae","ot","Oe","_e","ge","ue","Le","me","ve","ne","oe","Re","je","Ue","Ie","c.mapLeft","Z","w.chainW","ee","w.mapBoth","pt","$e","te","c.match","w.right","w.match","be","ct","Ee","Pe","ze","Ve","_t","we","Be","w.chain","w.left","Ge","ft","le","c.tryCatch","mt","fe","De","wt","dt","Je","c.chain","he.parse","gt","createIsSupportedSignal","method","version","supports","throwifyWithChecksFp","fn_","throwifyFpFn","O.match","data","throwifyAnyEither","msgToTuple","message","ValidationError","errorClassWithData","CSSVarsBoundError","errorClass","DeviceStorageMethodError","error","SecureStorageMethodError","NotAvailableError","InvalidEnvError","FunctionUnavailableError","InvalidArgumentsError","cause","ConcurrentCallError","SetEmojiStatusError","AccessDeniedError","FullscreenFailedError","ShareMessageError","UnknownThemeParamsKeyError","withChecksFp","fn","isTma","optionsIsSupported","returns","isSupportedSimplified","isOptionSupported","optionName","optionSettings","calculateSupportError","mode","requirements","calculateOptionSupportError","isSupported","isInitialized","isMounted","isAvailable","wrapError","err","TE.left","call","E.tryCatch","TE.tryCatch","errMessagePrefix","supportErr","supportsOptionErr","O.some","O.none","createWithChecksFp","Button","storage","onClick","offClick","postEvent","payload","stateful","mountable","wrapOptions","wrapSupportedPlain","wrapMountedEither","nothing","setFp","setFalse","setTrue","BackButton","button","sharedFeatureOptions","isTMAFp","createFnOption","mix","obj","createSignal","initialValue","postEventFpSignal","_postEventFp","postEventFp","withPostEvent","createComponentSessionStorage","getStorageValue","setStorageValue","getFirstNavigationEntry","entry","withStateRestore","storageName","withVersion","buttonOptions","trackedClickEvent","listener","once","on","off","backButton","AsyncMountable","TE.right","TE.map","createNotAvailableError","eventToState","event","available","tokenSaved","deviceId","accessRequested","accessGranted","Biometry","request","onInfoReceived","offInfoReceived","wrapSupportedEither","wrapSupportedTask","wrapMountedTask","response","TE.chain","requestFp","events","_requestFp","request2Fp","_request2Fp","BetterPromise","request2","withRequest","instantiate","biometry","ClosingBehavior","setClosingConfirmation","isConfirmationEnabled","closingBehavior","CloudStorage","invokeCustomMethod","keyOrKeys","keys","values","acc","lastRequestId","createRequestId","params","invokeCustomMethodFp","withInvokeCustomMethod","cloudStorage","DeviceStorage","invokeMethod","requestId","withCreateRequestId","deviceStorage","create","rest","requestEmojiStatusAccessFp","requestEmojiStatusAccess","customEmojiId","TE.chainW","setEmojiStatusFp","setEmojiStatus","HapticFeedback","HAPTIC_METHOD_NAME","wrapSupported","style","hapticFeedback","addToHomeScreenFp","addToHomeScreen","checkHomeScreenStatusFp","checkHomeScreenStatus","InitData","retrieveInitData","authDateValue","canSendAfterValue","raw","E.Do","E.bindW","retrieveLaunchParamsFp","tgWebAppData","retrieveRawInitDataFp","O.Do","O.bind","initData","Invoice","isOpened","toggleClosed","slug","TE.mapBoth","url","hostname","pathname","invoice","openLinkFp","openLink","urlString","openTelegramLinkFp","openTelegramLink","text","shareURLFp","shareURL","LocationManager","locationManager","MainButton","defaults","withDefault","field","fromState","setCssVar","deleteCssVar","isColorDarkFp","color","toRGBFullFp","rgb","modifier","idx","dec","isColorDark","ThemeParams","offChange","getCSSVarName","prop","snakeToKebab","forEachEntry","actualize","themeParams","globalThemeParams","bottomButtonOptions","mainButton","MiniApp","theme","onVisibilityChanged","offVisibilityChanged","visibilityChangedListener","themeChangedListener","isRGB","rgbBasedOn","computedRgbBasedOn","isCssVarsBound","addCleanup","cleanup","createCbCollector","cssVar","update","camelToKebab","genColorToolset","stateKey","rawColor","rgbColor","fp","withBasicEither","returnBack","miniApp","prepareParams","title","paramsButtons","buttons","id","Popup","TE.fromEither","preparedOptions","popup","requestPhoneAccessFp","requestPhoneAccess","createComplete","getContact","toStringResult","toParsedResult","pipeQueryToSchema","pipeJsonToSchema","valiPipe","getContactWithErrorsIgnore","TE.match","contact","pollContact","ctx","BetterTaskEither","res","rej","sleepTime","status","instantiateComplete","createParsed","requestContact","instantiateParsed","requestContactCompleteFp","requestContactComplete","requestContactFp","requestWriteAccessFp","requestWriteAccess","QrScanner","onClosed","onTextReceived","setClosed","captured","qr","addToCleanup","onSettled","isOpenedValue","qrScanner","SecondaryButton","secondaryButton","SecureStorage","secureStorage","SettingsButton","settingsButton","SwipeBehavior","setVerticalEnabled","isVerticalEnabled","swipeBehavior","copyTextToClipboard","clipboard","textArea","fileName","downloadFileFp","downloadFile","parsed","getCurrentTimeFp","getCurrentTime","hideKeyboardFp","hideKeyboard","reqId","captureSameReq","readTextFromClipboardFp","readTextFromClipboard","retrieveAndroidDeviceDataFrom","userAgent","appVersion","systemInfo","retrieveAndroidDeviceData","size","sendDataFp","sendData","messageId","shareMessageFp","shareMessage","mediaUrl","shareStoryFp","shareStory","isInlineMode","query","chatTypes","switchInlineQueryFp","switchInlineQuery","Viewport","onContentSafeAreaInsetsChanged","onSafeAreaInsetsChanged","onViewportChanged","onFullscreenChanged","offContentSafeAreaInsetsChanged","offFullscreenChanged","offSafeAreaInsetsChanged","offViewportChanged","isViewportStable","isFullscreen","initialInsets","viewportChangedListener","fullscreenChangedListener","safeAreaInsetsChangedListener","contentSafeAreaInsetsChangedListener","genRequestInsets","kind","genFlag","flag","TE.Do","TE.bindW","shared","viewport","saBased","csaBased","wrapTask","wrapFullscreenTask","genFullscreenFn","enable","settings","setting","createListeners","viewportListeners","fullscreenListeners","safeAreaListeners","contentSafeAreaListeners","lp","initFp","optionsVersion","optionsInlineMode","optionsThemeParams","E.matchW","logger","acceptCustomStyles","html","init"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,17,18,20,22]}