{"version":3,"file":"index.cjs","sources":["../src/casing/camelToKebab.ts","../src/casing/camelToSnake.ts","../src/casing/camelToSnakeObjKeys.ts","../src/casing/snakeToCamel.ts","../src/casing/snakeToCamelObjKeys.ts","../src/casing/deepSnakeToCamelObjKeys.ts","../src/casing/snakeToKebab.ts","../src/storage/storage.ts","../src/createCbCollector.ts","../src/createLogger.ts","../src/monads.ts"],"sourcesContent":["/**\n * Converts string value from camel case to kebab case.\n * @param value - value to convert.\n */\nexport function camelToKebab(value: string): string {\n  return value.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\n}\n","export type CamelToSnakeCase<T extends string> = T extends `${infer First}${infer Rest}`\n  ? `${First extends Capitalize<First> ? '_' : ''}${Lowercase<First>}${CamelToSnakeCase<Rest>}`\n  : T;\n\n/**\n * Converts string value from camel case to snake case.\n * @param value - value to convert.\n */\nexport function camelToSnake<T extends string>(value: T): CamelToSnakeCase<T> {\n  return value.replace(/[A-Z]/g, match => `_${match.toLowerCase()}`) as CamelToSnakeCase<T>;\n}\n","import { camelToSnake, type CamelToSnakeCase } from '@/casing/camelToSnake.js';\n\nexport type ConvertCamelKeysToSnakeCase<T> = {\n  [K in keyof T as CamelToSnakeCase<string & K>]: T[K];\n};\n\n/**\n * Converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function camelToSnakeObjKeys<T extends object>(value: T): ConvertCamelKeysToSnakeCase<T> {\n  return Object.entries(value).reduce<ConvertCamelKeysToSnakeCase<T>>((acc, [k, v]) => {\n    acc[camelToSnake(k) as keyof ConvertCamelKeysToSnakeCase<T>] = v;\n    return acc;\n  }, {} as ConvertCamelKeysToSnakeCase<T>);\n}\n","export type SnakeToCamelCase<S extends string> =\n  S extends `${infer Head}_${infer Tail}`\n    ? `${Head}${Capitalize<SnakeToCamelCase<Tail>>}`\n    : S;\n\n/**\n * Converts string value from snake case to camel case.\n * @param value - value to convert.\n */\nexport function snakeToCamel<T extends string>(value: T): SnakeToCamelCase<T> {\n  return value.replace(/_[a-z]/g, m => m[1].toUpperCase()) as SnakeToCamelCase<T>;\n}\n","import { snakeToCamel, type SnakeToCamelCase } from '@/casing/snakeToCamel.js';\n\nexport type ConvertSnakeKeysToCamelCase<T> = {\n  [K in keyof T as SnakeToCamelCase<string & K>]: T[K];\n};\n\n/**\n * Converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function snakeToCamelObjKeys<T extends object>(value: T): ConvertSnakeKeysToCamelCase<T> {\n  return Object.entries(value).reduce<ConvertSnakeKeysToCamelCase<T>>((acc, [k, v]) => {\n    acc[snakeToCamel(k) as keyof ConvertSnakeKeysToCamelCase<T>] = v;\n    return acc;\n  }, {} as ConvertSnakeKeysToCamelCase<T>);\n}\n","import type { SnakeToCamelCase } from '@/casing/snakeToCamel.js';\nimport { snakeToCamelObjKeys } from '@/casing/snakeToCamelObjKeys.js';\n\nexport type DeepConvertSnakeKeysToCamelCase<T> = T extends infer U\n  ? U extends object\n    ? U extends Date\n      ? U\n      : U extends (infer Item)[]\n        ? DeepConvertSnakeKeysToCamelCase<Item>[]\n        : {\n          [K in keyof U as SnakeToCamelCase<string & K>]: DeepConvertSnakeKeysToCamelCase<U[K]>\n        } & {}\n    : U\n  : T;\n\n/**\n * Deeply converts object keys from snake to camel case.\n * @param value - value to convert.\n */\nexport function deepSnakeToCamelObjKeys<T extends object>(\n  value: T,\n): DeepConvertSnakeKeysToCamelCase<T> {\n  const camelCased = snakeToCamelObjKeys(value);\n  for (const key in camelCased) {\n    const value = camelCased[key];\n    if (value && typeof value === 'object' && !(value instanceof Date)) {\n      (camelCased as any)[key] = Array.isArray(value)\n        ? value.map(deepSnakeToCamelObjKeys)\n        : deepSnakeToCamelObjKeys(value);\n    }\n  }\n  return camelCased as DeepConvertSnakeKeysToCamelCase<T>;\n}\n","/**\n * Converts string value from snake case to kebab case.\n * @param value - value to convert.\n */\nexport function snakeToKebab(value: string): string {\n  return value.replace(/_([a-z])/g, (_, letter) => `-${letter.toLowerCase()}`);\n}\n","/**\n * Converts a passed storage key to the formatted state.\n * @param key - storage key.\n */\nfunction formatKey(key: string): string {\n  return `tapps/${key}`;\n}\n\n/**\n * Saves value in the storage.\n * @param key - storage key.\n * @param value - storage value.\n */\nexport function setStorageValue<T>(key: string, value: T): void {\n  sessionStorage.setItem(formatKey(key), JSON.stringify(value));\n}\n\n/**\n * Extracts value from the storage.\n * @param key - storage key.\n */\nexport function getStorageValue<R>(key: string): R | undefined {\n  const value = sessionStorage.getItem(formatKey(key));\n  try {\n    return value ? JSON.parse(value) as R : undefined;\n  } catch {\n  }\n}\n","export type CallbackFn = () => void;\n\n/**\n * Returns a tuple, containing function to add cleanup, call cleanup, and flag showing whether\n * cleanup was called. Cleanup will not be performed in case, it was done before.\n */\nexport function createCbCollector(...cbs: (CallbackFn | CallbackFn[])[]): [\n  add: (...fns: CallbackFn[]) => void,\n  call: () => void,\n] {\n  const callbacks = cbs.flat(1);\n\n  return [\n    callbacks.push.bind(callbacks),\n    () => {\n      callbacks.forEach(cb => {\n        cb();\n      });\n    },\n  ];\n}\n","/**\n * Message log level.\n */\nexport type LogLevel = 'log' | 'error' | 'warn';\n\nexport interface LoggerOptions {\n  bgColor?: string;\n  textColor?: string;\n  /**\n   * True if logs are enabled.\n   * @default true\n   */\n  shouldLog?: boolean | (() => boolean);\n}\n\nexport type LoggerFn = (...args: any[]) => void;\nexport type LoggerForceFn = (...args: any[]) => void;\n\nexport interface Logger {\n  /**\n   * Prints an error message into the console.\n   * @param args - items to log.\n   */\n  error: LoggerFn;\n  /**\n   * Prints an error message into the console ignoring the `shouldLog`\n   * constructor option.\n   * @param args - items to log.\n   */\n  forceError: LoggerForceFn;\n  /**\n   * Prints a log message into the console ignoring the `shouldLog` constructor\n   * option.\n   * @param args - items to log.\n   */\n  forceLog: LoggerForceFn;\n  /**\n   * Prints a warning message into the console ignoring the `shouldLog`\n   * constructor option.\n   * @param args - items to log.\n   */\n  forceWarn: LoggerForceFn;\n  /**\n   * Prints a log message into the console.\n   * @param args - items to log.\n   */\n  log: LoggerFn;\n  /**\n   * Prints a warning message into the console.\n   * @param args - items to log.\n   */\n  warn: LoggerFn;\n}\n\n/* @__NO_SIDE_EFFECTS__*/\nexport function createLogger(scope: string, options?: LoggerOptions): Logger {\n  options ||= {};\n  const {\n    textColor,\n    bgColor,\n    shouldLog: optionsShouldLog,\n  } = options;\n  const shouldLogValue = optionsShouldLog === undefined ? true : optionsShouldLog;\n  const shouldLog = typeof shouldLogValue === 'boolean'\n    ? () => shouldLogValue\n    : shouldLogValue;\n\n  /**\n   * Prints a message into the console.\n   * @param level - log level.\n   * @param force - should `shouldLog` value be ignored.\n   * @param args - arguments.\n   */\n  const print = (level: LogLevel, force: boolean, ...args: any[]): void => {\n    if (force || shouldLog()) {\n      const commonCss = 'font-weight:bold;padding:0 5px;border-radius:100px';\n      const [timeBgColor, timeTextColor, prefix] = {\n        log: ['#0089c3', 'white', 'INFO'],\n        error: ['#ff0000F0', 'white', 'ERR'],\n        warn: ['#D38E15', 'white', 'WARN'],\n      }[level];\n      console[level](\n        `%c${prefix} ${\n          Intl\n            .DateTimeFormat('en-GB', {\n              hour: '2-digit',\n              minute: '2-digit',\n              second: '2-digit',\n              fractionalSecondDigits: 3,\n              timeZone: 'UTC',\n            })\n            .format(new Date())\n        }%c %c${scope}`,\n        `${commonCss};background-color:${timeBgColor};color:${timeTextColor}`,\n        '',\n        `${commonCss};${textColor ? `color:${textColor};` : ''}${bgColor ? `background-color:${bgColor}` : ''}`,\n        ...args,\n      );\n    }\n  };\n\n  return ([\n    ['log', 'forceLog'],\n    ['warn', 'forceWarn'],\n    ['error', 'forceError'],\n  ] as const).reduce<Logger>((acc, [level, forceMethod]) => {\n    acc[level] = print.bind(undefined, level, false);\n    acc[forceMethod] = print.bind(undefined, level, true);\n    return acc;\n  }, {} as Logger);\n}\n","import {\n  BetterPromise,\n  type BetterPromiseExecutorContext,\n  type BetterPromiseOptions,\n  type TimeoutError,\n} from 'better-promises';\nimport { either as E, taskEither as TE, function as fn } from 'fp-ts';\n\nimport type { AnyFn } from '@/types/misc.js';\n\nexport type AnyEither<L = any, R = any> = E.Either<L, R> | TE.TaskEither<L, R>;\nexport type AnyFnAnyEither<L = any, R = any> = (...args: any) => AnyEither<L, R>;\n\nexport type RightOfEither<T extends AnyEither> = [T] extends [E.Either<any, infer U>]\n  ? U\n  : T extends TE.TaskEither<any, infer U>\n    ? U\n    : never;\nexport type LeftOfEither<T extends AnyEither> = [T] extends [E.Either<infer U, any>]\n  ? U\n  : T extends TE.TaskEither<infer U, any>\n    ? U\n    : never;\nexport type RightOfReturn<F extends AnyFnAnyEither> = RightOfEither<ReturnType<F>>;\nexport type LeftOfReturn<F extends AnyFnAnyEither> = LeftOfEither<ReturnType<F>>;\n\nexport type MaybeMonadToCommon<T> = [T] extends [E.Either<any, infer U>]\n  ? U\n  : T extends TE.TaskEither<any, infer U>\n    ? BetterPromise<U>\n    : T;\n\nexport type MaybeCommonToMonad<T> = T extends AnyEither\n  ? T\n  : T extends PromiseLike<infer U>\n    ? TE.TaskEither<unknown, U>\n    : E.Either<unknown, T>;\n\nexport type MaybeMonadReturnTypeToCommon<Fn extends AnyFn> = MaybeMonadToCommon<ReturnType<Fn>>;\n\nexport type MaybeCommonReturnTypeToMonad<Fn extends AnyFn> = MaybeCommonToMonad<ReturnType<Fn>>;\n\nexport function throwifyAnyEither<E extends AnyEither>(either: E): MaybeMonadToCommon<E> {\n  const onError = (e: unknown) => {\n    throw e;\n  };\n  return (\n    typeof either === 'function'\n      ? BetterPromise.resolve(fn.pipe(either, TE.match(onError, data => data))())\n      : fn.pipe(either, E.match(onError, data => data))\n  ) as MaybeMonadToCommon<E>;\n}\n\n// #__NO_SIDE_EFFECTS__\nexport function throwifyFpFn<Fn extends AnyFnAnyEither>(\n  fn: Fn,\n): (\n  & ((...args: Parameters<Fn>) => MaybeMonadReturnTypeToCommon<Fn>)\n  & { [K in keyof Fn]: Fn[K] }\n) {\n  return Object.assign(\n    (...args: Parameters<Fn>) => {\n      return throwifyAnyEither(fn(...args)) as MaybeMonadReturnTypeToCommon<Fn>;\n    },\n    fn,\n  );\n}\n\nexport type BetterTaskEitherError = TimeoutError;\n\nexport const BetterTaskEither = /* #__PURE__ */ Object.assign(\n  <E, T>(\n    executor: (\n      resolve: (data: T) => void,\n      reject: (reason: E) => void,\n      context: BetterPromiseExecutorContext<E.Either<E | BetterTaskEitherError, T>>,\n    ) => (void | Promise<void>),\n    options?: BetterPromiseOptions,\n  ): TE.TaskEither<E | BetterTaskEitherError, T> => {\n    return fn.pipe(\n      TE.tryCatch(\n        () => {\n          return new BetterPromise<E.Either<E, T>>((res, _rej, context) => {\n            return executor(\n              result => res(E.right(result)),\n              error => res(E.left(error)),\n              context,\n            );\n          }, options);\n        },\n        e => e as E,\n      ),\n      TE.chainW(E.match(TE.left, TE.right<E, T>)),\n    );\n  },\n  {\n    fn: <E, T>(\n      fn_: (context: BetterPromiseExecutorContext<E.Either<E | BetterTaskEitherError, T>>) => (\n        E.Either<E, T> | TE.TaskEither<E, T>\n      ),\n      options?: BetterPromiseOptions,\n    ): TE.TaskEither<E | BetterTaskEitherError, T> => {\n      return BetterTaskEither<E, T>((resolve, reject, context) => {\n        const result = fn_(context);\n        void fn.pipe(\n          typeof result === 'function' ? result : TE.fromEither(result),\n          TE.matchW(reject, resolve),\n        )();\n      }, options);\n    },\n  },\n);\n"],"names":["camelToKebab","value","match","camelToSnake","camelToSnakeObjKeys","acc","k","v","snakeToCamel","m","snakeToCamelObjKeys","deepSnakeToCamelObjKeys","camelCased","key","snakeToKebab","_","letter","formatKey","setStorageValue","getStorageValue","createCbCollector","cbs","callbacks","cb","createLogger","scope","options","textColor","bgColor","optionsShouldLog","shouldLogValue","shouldLog","print","level","force","args","commonCss","timeBgColor","timeTextColor","prefix","forceMethod","throwifyAnyEither","either","onError","e","BetterPromise","fn","TE","data","E","throwifyFpFn","BetterTaskEither","executor","res","_rej","context","result","error","fn_","resolve","reject"],"mappings":"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"}